/**
 * This class handles all aspects of custom WFRP tables.
 * 
 * The WFRP_Tables is given table objects on 'init' and 'ready' hooks by
 * both the system, modules, and the world. See the tables folder for 
 * how they're structured. All files in that folder will be
 * added to WFRP_Tables if possible. 
 */


class WFRP_Tables {


  /**
   * The base function to retrieve a result from a table given various parameters.
   * 
   * Options: 
   * `modifier` - modify the roll result by a certain amount
   * `minOne` - If true, the minimum roll on the table is 1 (used when a negative modifier is applied)
   * `lookup` - forego rolling and use this value to lookup the result on the table.
   * 
   * @param {String} table Table name - the filename of the table file
   * @param {Object} options Various options for rolling the table, like modifier
   * @param {String} column Which column to roll on, if possible.
   */
  static async rollTable(tableKey, options = {}, column = null) {
    let modifier = options.modifier || 0;
    let minOne = options.minOne || false;

    let table = this.findTable(tableKey.toLowerCase(), column);


    if (table) {

      if (table.columns)
        throw new Error(game.i18n.localize("ERROR.Column"))

      let formula = table.formula;
      let tableSize = Array.from(table.results).length;

      // If no die specified, just use the table size and roll
      let roll = await new Roll(`${formula} + @modifier`, { modifier }).roll( { async: true });
      if (options.showRoll)
      {
        let msg = await roll.toMessage({rollMode : game.settings.get("core", "rollMode"), });
        if (game.dice3d)
          await game.dice3d.waitFor3DAnimationByMessageID(msg.id);
      }

      if (game.dice3d && !options.hideDSN && !options.showRoll)
        await game.dice3d.showForRoll(roll);

      let rollValue = options.lookup || roll.total; // options.lookup will ignore the rolled value for the input value
      let displayTotal = options.lookup || roll.result; // Roll value displayed to the user
      if (modifier == 0)
        displayTotal = (0, eval)(displayTotal); // Clean up display value if modifier 0 (59 instead of 59 + 0)
      if (rollValue <= 0 && minOne) // Min one provides a lower bound of 1 on the result
        rollValue = 1;

      else if (rollValue <= 0)
        return {
          roll: rollValue
        };

      let resultList = Array.from(table.results);

      tableSize = resultList.sort((a, b) => a.range[1] - b.range[1])[resultList.length - 1].range[1];

      if (rollValue > tableSize)
        rollValue = tableSize;

      let rollResult = table.getResultsForRoll(rollValue)[0];
      let flags = rollResult.flags.wfrp4e || {};
      let result = {
        result : rollResult.getChatText(),
        roll : displayTotal,
        object : rollResult.toObject(),
        title : table.name,
      };



      // If table result text is a UUID link, add a text property with just the label
      result.text = WFRP_Utility$1.extractLinkLabel(result.result);

      mergeObject(result, flags);

      if (Object.keys(game.wfrp4e.config.hitLocationTables).includes(tableKey))
        result = this.formatHitloc(rollResult, rollValue);

      return result

    }
    else if (tableKey == "hitloc" || tableKey == "scatter") {

      // Scatter is a special table - calculate distance and return
      if (tableKey == "scatter") {
        let roll = (await new Roll(`1d10`).roll({ async: true })).total;
        let dist = (await new Roll('2d10').roll({ async: true })).total;

        return { result: this.scatterResult({roll, dist}), roll }

      }
      else if (tableKey == "hitloc") {
        let roll = await new Roll(`1d100`).roll();
        let result = this._lookup("hitloc", options.lookup || roll.total);
        result.roll = roll.total;
        return result
      }
    }
    else {
      if (tableKey != "menu")
        return ui.notifications.error(game.i18n.format("ERROR.Table", {key : tableKey}))
      else 
        return this.tableMenu()
    }
  }

  /**
   * Retrieves a value from a table, using the column if specified
   * 
   * @param {String} table table name
   * @param {Number} value value to lookup
   * @param {String} column column to look under, if needed
   */
  static _lookup(table, value, column = null) {
    if (column && this[table].columns) {
      for (let row of this[table].rows) {
        if (WFRP_Tables._inRange(value, row.range[column]))
          return duplicate(row)
      }
    }

    else if (column && this[table].multi) {
      for (let row of this[table].rows) {
        if (WFRP_Tables._inRange(value, row.range[column]))
          return duplicate(row[column])
      }
    }

    else {
      for (let row of this[table].rows) {
        if (WFRP_Tables._inRange(value, row.range))
          return duplicate(row)
      }
    }
  }

  static _inRange(value, range) {
    if (range.length == 0)
      return false
    if (range.length == 1)
      range.push(range[0]);
    if (value >= range[0] && value <= range[1])
      return true
  }

  /* -------------------------------------------- */

  // critlleg doesn't exist, yet will be asked for because hit location and 'crit' are concatenated
  // Therefore, change specific locations to generalized ones (rarm -> arm)
  static generalizeTable(table) {
    table = table.toLowerCase();
    table = table.replace("lleg", "leg");
    table = table.replace("rleg", "leg");
    table = table.replace("rarm", "arm");
    table = table.replace("larm", "arm");
    return table;
  }

  
  static formatHitloc(result, roll) {
    let flags = result.flags.wfrp4e || {};
    return {
      description : result.getChatText(),
      result : flags.loc,
      roll
    }
  }

  static async rollToChat(table, options = {}, column = null, rollMode) {
    let chatOptions = game.wfrp4e.utility.chatDataSetup("", rollMode, true);
    chatOptions.content = await this.formatChatRoll(table, options, column);
    chatOptions.type = 0;
    if (chatOptions.content)
      ChatMessage.create(chatOptions);
    ui.sidebar.activateTab("chat");
  }

  static findTable(key, column) {
    WFRP_Utility$1.log(`Finding Table key: ${key} column: ${column}`);
    let tables = game.tables.filter(i => i.getFlag("wfrp4e", "key") == key);
    let table; 

    // Look at table settings first
    let tableSettings = game.settings.get("wfrp4e", "tableSettings");
    WFRP_Utility$1.log(`Table Settings: `, undefined, tableSettings);

    // If tableSettings has comma separated ids, return them as columns
    let id = tableSettings[`${key}${column ? "-"+column : ""}`]?.split(",");
    if (id && id.length)
    {
      if (id.length > 1)
      {
        tables = id.map(i => game.tables.get(i));
      }
      else // If only one id in table settings, just use that table
      {
        table = game.tables.get(id[0]);
      }
    }

    if (table)
    {
      WFRP_Utility$1.log("Found Table with settings");
    }

    if (!table)
    {

      WFRP_Utility$1.log("Table not found with settings, finding first table that matches");

      // If more than one table with that key, and column is specified, return that column
      if (tables.length > 1 && column)
        table = tables.find(i => i.getFlag("wfrp4e", "column") == column);

      // If only one result with that key, or multiple results that don't have a column, return the first one (this condition is needed to return Minor Miscast table if Minor Miscast (Moo) also exists at the same time)
      else if (tables.length == 1 || tables.map(t => t.getFlag("wfrp4e", "column")).filter(t => t).length < 1) 
      {
        table = tables[0];
      }

      // If multiple results, return a special object that has a generalized name and columns array listing the tables 
      else  if (tables.length)
        table =  {name : tables[0].name.split("-")[0].trim(), columns: tables};

      }
    WFRP_Utility$1.log("Find Table returns", undefined, table);
    return table;

  }

  /**
   * Takes the key of an existing hit location Rollable Table and returns a simple hitloc object.
   * 
   * {
   *  lArm : "Left Arm",
   *  rArm : "Right Arm",
   *  ....
   * }
   * 
   * @param {String} key key of the hit location table
   */
  static getHitLocTable(key)
  {
    let hitloc = {};
    let table = this.findTable(key);

    if (table)
    {
      table.results.forEach(result => {
        if (result.flags.wfrp4e.loc)
          hitloc[result.flags.wfrp4e.loc] = result.text;
      });
    }
    return hitloc
  }


    /**
   * Takes a hitloc key and turns it into a result object
   * 
   * 
   * @param {String} key key of the hit location table
   */
     static hitLocKeyToResult(resultKey, tableKey = "hitloc")
     {
       let table = this.findTable(tableKey);
   
       if (table)
       {
         for(let result of table.results)
         {
           if (result.flags.wfrp4e?.loc == resultKey)
             return this.formatHitloc(result, result.range[0])
         }
       }
     }

  /* -------------------------------------------- */

  /**
   * 
   * Wrapper for rollTable to format rolls from chat commands nicely.
   * 
   * Calls rollTable() and displays the result in a specific format depending
   * on the table rolled on.
   * 
   * @param {String} table Table name - the filename of the table file
   * @param {Object} options Various options for rolling the table, like modifier
   * @param {String} column Which column to roll on, if possible.
   */
  static async formatChatRoll(table, options = {}, column = null) {
    if (options.minOne === undefined)
      options.minOne = true;

    table = this.generalizeTable(table);

    let tableObject = this.findTable(table, column);

    if (tableObject && tableObject.columns)
      return this.promptColumn(table);


    let result = await this.rollTable(table, options, column);
    if (options.lookup && !game.user.isGM) // If the player (not GM) rolled with a lookup value, display it so they can't be cheeky cheaters
      result.roll = game.i18n.localize("TABLE.Lookup") + result.roll;
    try {
      // Cancel the roll if below 1 and not minimum one
      if (result.roll <= 0 && !options.minOne)
        return game.i18n.format("TABLE.Cancel", { result: result.roll })
    }
    catch
    { }

    // If the roll is an item, don't post the link to chat, post the item to chat
    if (result.object?.documentCollection && result.object?.documentId)
    {
      let collection = game.packs.get(result.object.documentCollection);

      if (collection)
        await collection.getDocuments();

      if (!collection)
        collection = game.collections.get(result.object.documentCollection);

      if (collection)
      {
        let item = collection.get(result.object.documentId);
        if (item && item.documentName == "Item")
        {
          item.postItem("inf");
          return null
        }
      }

    }

    return result.result

  }

  /**
   * Show the table help menu, display all tables as clickables and hidden tables if requested.
   * 
   * @param {Boolean} showHidden Show hidden tables
   */
  static tableMenu() {
    let tableMenu = `<b><code>/table</code> ${game.i18n.localize("Commands")}</b><br>`;

    let tables = game.tables.filter(i => i.permission);

    let columnsAdded = [];

    // For each table, add a clickable link
    for (let table of tables)
    {
      let key = table.getFlag("wfrp4e", "key");
      let tableObject = this.findTable(key);

      // If the table is a column, add only the general table, and remember the table to not list again for future columns (Only list Weather, not Weather - Spring, Weather - Winter, etc)
      if (tableObject.columns && !columnsAdded.includes(key))
      {
        columnsAdded.push(key);
        tableMenu += `<a data-table='${key}' class='table-click'><i class="fas fa-list"></i> <code>${key}</code></a> - ${tableObject.name}<br>`;
      }
      // If no columns, just list tables
      else if (tableObject && !tableObject.columns)
        tableMenu += `<a data-table='${key}' class='table-click'><i class="fas fa-list"></i> <code>${key}</code></a> - ${table.name}<br>`;
    }
    return {result : tableMenu};
  }

  // When critical casting, there are few options available, one could be a critical wound on a location, so offer a clickable link.
  static criticalCastMenu(crittable) {
    return `${game.i18n.localize("CHAT.ChooseFrom")}:<ul>
      <li><b>${game.i18n.localize("ROLL.CritCast")}</b>: ${game.i18n.localize("CHAT.CritCast")} <a class=table-click data-table=${crittable}><i class="fas fa-list"></i> ${game.i18n.localize("Critical Wound")}</a></li>
      <li><b>${game.i18n.localize("ROLL.TotalPower")}</b>: ${game.i18n.localize("CHAT.TotalPower")}</li>
      <li><b>${game.i18n.localize("ROLL.UnstoppableForce")}</b>: ${game.i18n.localize("CHAT.UnstoppableForce")}</li>
      </ul`;
  }


  // Critical casting without reaching appropriate SL - forced to be Total power in order to get the spell off
  static restrictedCriticalCastMenu() {
    return `${game.i18n.localize("CHAT.MustChoose")}:<ul>
      <li><b>${game.i18n.localize("ROLL.TotalPower")}</b>: ${game.i18n.localize("CHAT.TotalPower")}</li>
      </ul`;
  }

  // Display all columns for a table so the user can click on them and roll them.
  static promptColumn(table) {
    let prompt = `<h3>${game.i18n.localize("CHAT.ColumnPrompt")}</h3>`;

    let tableObject = this.findTable(table);
    for (let c of tableObject.columns)
      prompt += `<div><a class = "table-click" data-table="${table}" data-column = "${c.getFlag("wfrp4e", "column")}"><i class="fas fa-list"></i> ${c.name}</a></div>`;

    return prompt;
  }


  static scatterResult({roll, dist}) {
    let tableHtml = '<table class = "scatter-table">' +
      " <tr>" +
      "<td position='1'> " +
      "</td>" +
      "<td position='2'> " +
      "</td>" +
      "<td position='3'> " +
      "</td>" +
      "</tr>" +
      " <tr>" +
      "<td position='4'> " +
      "</td>" +
      "<td position='10'> " + game.i18n.localize("CHAT.ScatterTarget") +
      "</td>" +
      "<td position='5'> " +
      "</td>" +
      "</tr>" +
      " <tr>" +
      "<td position='6'> " +
      "</td>" +
      "<td position='7'> " +
      "</td>" +
      "<td position='8'> " +
      "</td>" +
      "</tr>" +
      "</table>";

    if (roll == 9)
      tableHtml += game.i18n.localize("CHAT.ScatterYou");
    else if (roll == 10)
      tableHtml += game.i18n.localize("CHAT.ScatterThem");
    else
      tableHtml += game.i18n.localize("CHAT.ScatterNote");
    tableHtml = tableHtml.replace(`position='${roll}'`, "class='selected-position'");
    if (dist && roll <= 8) // Don't roll for 9 or 10
      tableHtml = tableHtml.replace("'selected-position'>", `'selected-position'> ${dist} ${game.i18n.localize("yds")}.`);
    return tableHtml
  }


  static get hitloc() {
    return {
      "name": game.i18n.localize("WFRP4E.LocationsTable"),
      "die": "1d100",
      "rows": [{
        "description": game.i18n.localize("WFRP4E.Locations.head"),
        "result": "head",
        "range": [1, 9]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.lArm"),
        "result": "lArm",
        "range": [10, 24]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.rArm"),
        "result": "rArm",
        "range": [25, 44]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.body"),
        "result": "body",
        "range": [45, 79]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.lLeg"),
        "result": "lLeg",
        "range": [80, 89]
      }, {
        "description": game.i18n.localize("WFRP4E.Locations.rLeg"),
        "result": "rLeg",
        "range": [90, 100]
      }]
    }
  }


  static get scatter() {
    return {
      name: game.i18n.localize("WFRP4E.ScatterTable"),
      die: "1d10",
      rows: [
        {
          name: game.i18n.localize("WFRP4E.Scatter.TopLeft"),
          range: [1, 1]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.TopMiddle"),
          range: [2, 2]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.TopRight"),
          range: [3, 3]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.CenterLeft"),
          range: [4, 4]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.CenterRight"),
          range: [5, 5]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.BottomLeft"),
          range: [6, 6]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.BottomMiddle"),
          range: [7, 7]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.BottomRight"),
          range: [8, 8]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.AtYourFeet"),
          range: [9, 9]
        },
        {
          name: game.i18n.localize("WFRP4E.Scatter.AtTargetFeet"),
          range: [10, 10]
        },
      ]
    }
  }


}

var WFRP4eDocumentMixin$1 = WFRP4eDocumentMixin = (cls) => class extends cls {

    // @@@@ _preHook Listeners @@@@
    async _preCreate(data, options, user) {
        if (data._id && !this.isOwned)
            options.keepId = WFRP_Utility$1._keepID(data._id, this);

        await super._preCreate(data, options, user);
        this.updateSource(await this.system.preCreateData(data, options, user));
    }

    async _preUpdate(data, options, user) {
        await super._preUpdate(data, options, user);
        await this.system.preUpdateChecks(data, options, user);
    }

    async _preDelete(options, user) {
        await super._preDelete(options, user);
        await this.system.preDeleteChecks(options, user);
    }

    _preUpdateDescendantDocuments(parent, collection, changes, options, userId) {
        super._preUpdateDescendantDocuments(parent, collection, changes, options, userId);
    }

    _onUpdateDescendantDocuments(parent, collection, documents, changes, options, userId) {
        super._onUpdateDescendantDocuments(parent, collection, documents, changes, options, userId);
    }

    _preDeleteDescendantDocuments(parent, collection, ids, options, userId) {
        super._preDeleteDescendantDocuments(parent, collection, ids, options, userId);
    }


    // @@@@ _onHook Listeners @@@@
    _onCreate(data, options, user) {
        if (game.user.id != user) {
            return;
        }
        super._onCreate(data, options, user);

        let update = this.system.createChecks(data, options, user);
        if (!foundry.utils.isEmpty(update)) {
            this.update(update);
        }
    }

    _onUpdate(data, options, user) {
        if (game.user.id != user) {
            return;
        }

        super._onUpdate(data, options, user);
        let update = this.system.updateChecks(data, options, user);
        if (!foundry.utils.isEmpty(update)) {
            this.update(update);
        }
    }

    _onDelete(options, user) {
        super._onDelete(options, user);
    }

    _onCreateDescendantDocuments(parent, collection, documents, data, options, userId) {
        super._onCreateDescendantDocuments(parent, collection, documents, data, options, userId);
    }

    _onUpdateDescendantDocuments(parent, collection, documents, changes, options, userId) {
        super._onUpdateDescendantDocuments(parent, collection, documents, changes, options, userId);
    }

    _onDeleteDescendantDocuments(parent, collection, documents, ids, options, userId) {
        super._onDeleteDescendantDocuments(parent, collection, documents, ids, options, userId);
    }

    /**
 * 
 * @param {String} trigger Script trigger to run
 * @param {Object} args Arguments for the script
 * 
 * @returns Array of executed script return values
 */
    runScripts(trigger, args) {
        let scripts = this.getScripts(trigger);

        let promises = [];

        for (let script of scripts) {
            if (script.async) {
                promises.push(script.execute(args));
            }
            else {
                script.execute(args);
            }
        }

        return promises;
    }

    /**
* Collect effect scripts being applied to the actor
* 
* @param {String} trigger Specify stript triggers to retrieve
* @param {Function} scriptFilter Optional function to filter out more scripts
* @returns 
*/
    getScripts(trigger, scriptFilter) {
        let effects = Array.from(this.allApplicableEffects()).filter(i => !i.disabled);
        let scripts = effects.reduce((prev, current) => prev.concat(current.scripts.filter(i => i.trigger == trigger)), []);
        if (scriptFilter) {
            scripts = scripts.filter(scriptFilter);
        }
        return scripts;
    }

    //#region Condition Handling
    async addCondition(effect, value = 1) {
        if (typeof (effect) === "string")
            effect = duplicate(game.wfrp4e.config.statusEffects.find(e => e.id == effect));
        if (!effect)
            return "No Effect Found"

        if (!effect.id)
            return "Conditions require an id field"


        let existing = this.hasCondition(effect.id);

        if (existing && existing.flags.wfrp4e.value == null)
            return existing
        else if (existing) {
            existing = duplicate(existing);
            existing.flags.wfrp4e.value += value;
            return this.updateEmbeddedDocuments("ActiveEffect", [existing])
        }
        else if (!existing) {
            effect.name = game.i18n.localize(effect.name);
            if (Number.isNumeric(effect.flags.wfrp4e.value))
                effect.flags.wfrp4e.value = value;
            delete effect.id;
            return this.createEmbeddedDocuments("ActiveEffect", [effect])
        }
    }

    async removeCondition(effect, value = 1) {
        if (typeof (effect) === "string")
            effect = duplicate(game.wfrp4e.config.statusEffects.find(e => e.id == effect));
        if (!effect)
            return "No Effect Found"

        if (!effect.id)
            return "Conditions require an id field"

        let existing = this.hasCondition(effect.id);

        if (existing && existing.flags.wfrp4e.value == null) {
            return this.deleteEmbeddedDocuments("ActiveEffect", [existing._id])
        }
        else if (existing) {
            await existing.setFlag("wfrp4e", "value", existing.conditionValue - value);

            if (existing.flags.wfrp4e.value <= 0)
                return this.deleteEmbeddedDocuments("ActiveEffect", [existing._id])
            else
                return this.updateEmbeddedDocuments("ActiveEffect", [existing])
        }
    }


    hasCondition(conditionKey) {
        let existing = this.effects.find(i => i.conditionId == conditionKey);
        return existing
    }

    
    // Assigns a property to all datamodels are their embedded models
    propagateDataModels(model, name, value)
    {
        if (model instanceof foundry.abstract.DataModel && !model[name])
        {
            Object.defineProperty(model, name, {
                value, 
                enumerable : false
            });
        }

        for(let property in model)
        {
            if (model[property] instanceof foundry.abstract.DataModel)
            {
                this.propagateDataModels(model[property], name, value);
            }
        }
    }

};

class ItemWfrp4e extends WFRP4eDocumentMixin$1(Item)
{
  async _preCreate(data, options, user) {
    let migration = game.wfrp4e.migration.migrateItemData(this);
    this.updateSource({effects : game.wfrp4e.migration.removeLoreEffects(data)}, {recursive : false});

    if (!isEmpty(migration))
    {
      this.updateSource(migration);
      WFRP_Utility$1.log("Migrating Item: " + this.name, true, migration);
    }

    await super._preCreate(data, options, user);

    if (options.fromEffect)
    {
      this.updateSource({"flags.wfrp4e.fromEffect" : options.fromEffect});
    }

    if (this.isOwned)
    {
        await Promise.all(this.actor.runScripts("createItem", this));
        await this._handleConditions(data, options);
    }

    //_preCreate for effects is where immediate scripts run
    // Effects that come with Items aren't called, so handle them here
    await this.handleImmediateScripts();
  }

  async _onCreate(data, options, user)
  {
    if (game.user.id != user)
    {
        return;
    }
    await super._onCreate(data, options, user);

    if (this.parent?.actor)
    {
      await Promise.all(this.parent.actor.runScripts("update", {item, context: "create"}));
    }

  }

  async _onUpdate(data, options, user)
  {
    if (game.user.id != user)
    {
        return;
    }

    if (this.actor) {
    // TODO change this trigger
      await Promise.all(this.actor.runScripts("update", {item : this, context: "update"}));
    }
  }

  async _onDelete(options, user) 
  {
    if (game.user.id != user)
    {
        return;
    }
    await super._onDelete(options, user);

    for(let effect of this.effects)
    {
        await effect.deleteCreatedItems();
    }

    if (this.actor) {
      // TODO change this trigger
      await Promise.all(this.actor.runScripts("update", {item : this, context: "delete"}));
    }
  }

  // Conditions shouldn't be tied to the item. Add them to the actor independently.
  async _handleConditions()
  {
      let conditions = this.effects.filter(e => e.isCondition);

      // updateSource doesn't seem to work here for some reason: 
      // this.updateSource({effects : []})
      this._source.effects = this.effects.filter(e => !e.isCondition).filter(e => e.toObject());

      this.actor?.createEmbeddedDocuments("ActiveEffect", conditions);
  }

    // This function runs the immediate scripts an Item contains in its effects
    // when the Item is added to an Actor. 
    async handleImmediateScripts()
    {
        let effects = Array.from(this.allApplicableEffects()).filter(effect => 
            effect.applicationData.type == "document" && 
            effect.applicationData.documentType == "Actor"); // We're looking for actor because if the immediate script was for the Item, it would've been called when it was created. 

        for(let e of effects)
        {
            let keepEffect = await e.handleImmediateScripts();
            if (keepEffect == false) // Can't actually delete the effect because it's owned by an item in _preCreate. Change it to `other` type so it doesn't show in the actor
            {
                e.updateSource({"flags.wfrp4e.applicationData.type" : "other"});
            }
        }

        // let scripts = effects.reduce((prev, current) => prev.concat(current.scripts.filter(i => i.trigger == "immediate")), []);

        // await Promise.all(scripts.map(s => s.execute()));
    }



  prepareBaseData()
  {
    this.system.computeBase();
    this.runScripts("prePrepareData", { item: this });
  }

  prepareDerivedData()
  {
    this.system.computeDerived();
    this.runScripts("prepareData", { item: this });
  }

  prepareOwnedData()
  {
    this.actor.runScripts("prePrepareItem", { item: this });
    this.system.computeOwned();
    this.actor.runScripts("prepareItem", { item: this });
    this.runScripts("prepareOwned", { item: this });

  }



  /**
   * Posts this item to chat.
   * 
   * postItem() prepares this item's chat data to post it to chat, setting up 
   * the image if it exists, as well as setting flags so drag+drop works.
   * 
   */
  async postItem(quantity) {
    const properties = this.system.chatData();
    let postedItem = this.toObject();
    let chatData = duplicate(postedItem);
    chatData["properties"] = properties;

    //Check if the posted item should have availability/pay buttons
    chatData.hasPrice = "price" in chatData.system && this.type != "cargo";
    if (chatData.hasPrice) {
      if (!chatData.system.price.gc || isNaN(chatData.system.price.gc || 0))
        chatData.system.price.gc = 0;
      if (!chatData.system.price.ss || isNaN(chatData.system.price.ss || 0))
        chatData.system.price.ss = 0;
      if (!chatData.system.price.bp || isNaN(chatData.system.price.bp))
        chatData.system.price.bp = 0;
    }

    let dialogResult;
    if (quantity == undefined && (this.type == "weapon" || this.type == "armour" || this.type == "ammunition" || this.type == "container" || this.type == "money" || this.type == "trapping")) {
      dialogResult = await new Promise((resolve, reject) => {
        new Dialog({
          content:
            `<p>${game.i18n.localize("DIALOG.EnterQuantity")}</p>
          <div class="form-group">
            <label> ${game.i18n.localize("DIALOG.PostQuantity")}</label>
            <input style="width:100px" name="post-quantity" type="number" value="1"/>
          </div>
          <div class="form-group">
          <label> ${game.i18n.localize("DIALOG.ItemQuantity")}</label>
          <input style="width:100px" name="item-quantity" type="number" value="${this.quantity.value}"/>
        </div>
        <p>${game.i18n.localize("DIALOG.QuantityHint")}</p>
          `,
          title: game.i18n.localize("DIALOG.PostQuantity"),
          buttons: {
            post: {
              label: game.i18n.localize("Post"),
              callback: (dlg) => {
                resolve({
                  post: dlg.find('[name="post-quantity"]').val(),
                  qty: dlg.find('[name="item-quantity"]').val()
                });
              }
            },
            inf: {
              label: game.i18n.localize("Infinite"),
              callback: (dlg) => {
                resolve({ post: "inf", qty: dlg.find('[name="item-quantity"]').val() });
              }
            },
          }
        }).render(true);
      });

      if (dialogResult.post != "inf" && (!Number.isNumeric(dialogResult.post) || parseInt(dialogResult.post) <= 0))
        return ui.notifications.error(game.i18n.localize("CHAT.PostError"))

      if (dialogResult.qty != "inf" && (!Number.isNumeric(dialogResult.qty) || parseInt(dialogResult.qty) < 0))
        return ui.notifications.error(game.i18n.localize("CHAT.PostError"))


      let totalQtyPosted = (dialogResult.post * dialogResult.qty);
      if (Number.isNumeric(totalQtyPosted)) {
        if (this.isOwned) {
          if (this.quantity.value < totalQtyPosted) {
            return ui.notifications.notify(game.i18n.format("CHAT.PostMoreThanHave"))
          }
          else {
            ui.notifications.notify(game.i18n.format("CHAT.PostQuantityReduced", { num: totalQtyPosted }));
            this.update({ "system.quantity.value": this.quantity.value - totalQtyPosted });
          }
        }
      }


      if (dialogResult.post != "inf")
        chatData.showQuantity = true;

      chatData.postQuantity = dialogResult.post;
      postedItem.system.quantity.value = dialogResult.qty;
      chatData.system.quantity.value = dialogResult.qty;
    }
    else if (quantity > 0) {
      chatData.postQuantity = quantity;
      chatData.showQuantity = true;
    }

    // if (dialogResult.post != "inf" && isNaN(dialogResult.post * dialogResult.qty))
    //   return


    // Don't post any image for the item (which would leave a large gap) if the default image is used
    if (chatData.img.includes("/blank.png"))
      chatData.img = null;

    renderTemplate('systems/wfrp4e/templates/chat/post-item.hbs', chatData).then(html => {
      let chatOptions = WFRP_Utility$1.chatDataSetup(html);

      // Setup drag and drop data
      chatOptions["flags.transfer"] = JSON.stringify(
        {
          type: "postedItem",
          payload: postedItem,
        });
      chatOptions["flags.postQuantity"] = chatData.postQuantity;
      chatOptions["flags.recreationData"] = chatData;
      ChatMessage.create(chatOptions);
    });
  }

  //#endregion
 

  // If item.getScripts is called, filter scripts specifying "Item" document type
  // if the item was "Actor" document type, it would be transferred to the actor and 
  // the actor's getScripts would run it instead
  // 
  // This is important as roll dialogs call actor.getScripts() and then item.getScripts()
  // so that when an item is used, it can specifically add its dialog scripts
  // (prevents the need to check in the script code whether or not the item is being used)
  getScripts(trigger)
  {
      let effects = Array.from(this.allApplicableEffects()).
          filter(effect => 
              effect.applicationData.type == "document" && 
              effect.applicationData.documentType == "Item");

      let fromActor = this.actor?.getScriptsApplyingToItem(this) || [];

      return effects.reduce((prev, current) => prev.concat(current.scripts), []).concat(fromActor).filter(i => i.trigger == trigger);
  }

  _getTypedEffects(type)
  {
      let effects = Array.from(this.allApplicableEffects()).filter(effect => effect.applicationData.type == type);

      return effects;
  }

   *allApplicableEffects() 
   {
     for(let effect of this.effects.contents.concat(this.system.getOtherEffects()))//.filter(e => this.system.effectIsApplicable(e));
     {
      if (!effect.disabled)
        yield effect;
     }
   }
 
   get damageEffects() 
   {
       return this._getTypedEffects("damage");
   }
 
   get targetEffects() 
   {
       return this._getTypedEffects("target").concat(this._getTypedEffects("aura").filter(e => e.applicationData.targetedAura));
   }
 
   get areaEffects() 
   {
       return this._getTypedEffects("area");
   }
   
  get mountDamage() { // TODO test this after moving to model
    this.system.mountDamage || this.system.Damage;
  }

  // Don't really like this, but I don't think I can change it easily (used by scripts)
  get characteristic() {
    if (!this.isOwned)
      return this.system.characteristic
    let char;
    if (this.type == "skill") {
      char = this.actor.characteristics[this.system.characteristic.value];
      char.key = this.system.characteristic.value;
    }
    if (this.type == "trait" && this.rollable.value) {
      char = this.actor.characteristics[this.system.rollable.rollCharacteristic];
      char.key = this.system.rollable.rollCharacteristic;
    }
    return char
  }

    // Used for item category display when in a container
  get trappingCategory() {
      if (this.type == "trapping")
        return game.wfrp4e.config.trappingCategories[this.trappingType.value];
      else
        return game.wfrp4e.config.trappingCategories[this.type];
  }

  // While I wish i could remove most of these, scripts use them and removing them would cause a lot of disruption
  // They made more sense in the `data.data` days
  get attackType()         { return this.system.attackType }
  get isMelee()            { return this.system.isMelee }
  get isRanged()           { return this.system.isRanged }
  get isEquipped()         { return this.system.isEquipped }
  get WeaponGroup()        { return this.system.WeaponGroup }
  get Reach()              { return this.system.Reach }
  get Max()                { return this.system.Max }
  get DisplayName()        { return this.system.DisplayName }
  get cost()               { return this.system.cost }
  get included()           { return !((this.actor.excludedTraits || []).includes(this.id)) }
  get reachNum()           { return this.system.reachNum }   
  get ammo()               { return this.system.ammo }   
  get ammoList()           { return this.system.ammoList }   
  get ingredient()         { return this.system.ingredient }   
  get ingredientList()     { return this.system.ingredientList }   
  get skillToUse()         { return this.system.skillToUse }   
  get loading()            { return this.system.loading }   
  get repeater()           { return this.system.repeater }   
  get reloadingTest()      { return this.actor.items.get(getProperty(this.data, "flags.wfrp4e.reloading")) }   
  get protects()           { return this.system.protects }   
  get properties()         { return this.system.properties }   
  get originalProperties() { return this.system.originalProperties }   
  get modified()           { return this.system.modified }   
  get Advances()           { return this.system.Advances }   
  get Qualities()          { return this.system.Qualities }   
  get UnusedQualities()    { return this.system.UnusedQualities }   
  get InactiveQualities()  { return this.system.InactiveQualities }   
  get Flaws()              { return this.system.Flaws }   
  get OriginalQualities()  { return this.system.OriginalQualities; }   
  get OriginalFlaws()      { return this.system.OriginalFlaws; }   
  get QualityGroups()      { return this.system.QualityGroups; }   
  get Target()             { return this.system.Target }   
  get Duration()           { return this.system.Duration }   
  get Range()              { return this.system.Range }   
  get Damage()             { return this.system.Damage }   
  get DamageString()       { return this.system.DamageString }  
  get Specification()      { return this.system.Specification }
  get SpecificationBonus() { return this.system.SpecificationBonus }
  get advanced()           { return this.system.advanced }
  get advances()           { return this.system.advances }
  get ammunitionGroup()    { return this.system.ammunitionGroup }
  get ammunitionType()     { return this.system.ammunitionType }
  get armorType()          { return this.system.armorType }
  get availability()       { return this.system.availability }
  get career()             { return this.system.career }
  get careergroup()        { return this.system.careergroup }
  get cargoType()          { return this.system.cargoType }
  get carries()            { return this.system.carries }
  get characteristics()    { return this.system.characteristics }
  get class()              { return this.system.class }
  get cn()                 { return this.system.cn }
  get coinValue()          { return this.system.coinValue }
  get complete()           { return this.system.complete }
  get completion()         { return this.system.completion }
  get consumesAmmo()       { return this.system.consumesAmmo }
  get contraction()        { return this.system.contraction }
  get countEnc()           { return this.system.countEnc }
  get current()            { return this.system.current }
  get currentAmmo()        { return this.system.currentAmmo }
  get currentAP()          { return this.system.currentAP }
  get currentIng()         { return this.system.currentIng }
  get damage()             { return this.system.damage }
  get damageToItem()       { return this.system.damageToItem }
  get description()        { return this.system.description }
  get duration()           { return this.system.duration }
  get encumbrance()        { return this.system.encumbrance }
  get equipped()           { return this.system.equipped }
  get failingDecreases()   { return this.system.failingDecreases }
  get flaws()              { return this.system.flaws }
  get gmdescription()      { return this.system.gmdescription }
  get god()                { return this.system.god }
  get grouped()            { return this.system.grouped }
  get hide()               { return this.system.hide }
  get incomeSkill()        { return this.system.incomeSkill }
  get incubation()         { return this.system.incubation }
  get ingredients()        { return this.system.ingredients }
  get level()              { return this.system.level }
  get loaded()             { return this.system.loaded }
  get location()           { return this.system.location }
  get lore()               { return this.system.lore }
  get magicMissile()       { return this.system.magicMissile }
  get max()                { return this.system.max }
  get AP()                 { return this.system.AP }
  get APdamage()           { return this.system.APdamage }
  get memorized()          { return this.system.memorized }
  get modeOverride()       { return this.system.modeOverride }
  get modifier()           { return this.system.modifier }
  get modifiesSkills()     { return this.system.modifiesSkills }
  get modType()            { return this.system.modType }
  get mutationType()       { return this.system.mutationType }
  get negativePossible()   { return this.system.negativePossible }
  get offhand()            { return this.system.offhand }
  get origin()             { return this.system.origin }
  get overcast()           { return this.system.overcast }
  get penalty()            { return this.system.penalty }
  get permanent()          { return this.system.permanent }
  get price()              { return this.system.price }
  get qualities()          { return this.system.qualities }
  get quality()            { return this.system.quality }
  get quantity()           { return this.system.quantity }
  get range()              { return this.system.range }
  get reach()              { return this.system.reach }
  get rollable()           { return this.system.rollable }
  get skill()              { return this.system.skill }
  get skills()             { return this.system.skills }
  get SL()                 { return this.system.SL }
  get special()            { return this.system.special }
  get specification()      { return this.system.specification }
  get spellIngredient()    { return this.system.spellIngredient }
  get status()             { return this.system.status }
  get symptoms()           { return this.system.symptoms }
  get talents()            { return this.system.talents }
  get target()             { return this.system.target }
  get test()               { return this.system.test }
  get tests()              { return this.system.tests }
  get total()              { return this.system.total }
  get trappings()          { return this.system.trappings }
  get trappingType()       { return this.system.trappingType }
  get twohanded()          { return this.system.twohanded }
  get prayerType()         { return this.system.type }
  get unitPrice()          { return this.system.unitPrice }
  get weaponGroup()        { return this.system.weaponGroup || "basic" }
  get wearable()           { return this.system.wearable }
  get wind()               { return this.system.wind }
  get worn()               { return this.system.worn }
  get wounds()             { return this.system.wounds }
  //#endregion
}

/**
 * WIP
 * This class contains functions and helpers related to the market and Pay system
 */
class TravelDistanceWfrp4e {


    /**
    * This method load the travel data from the internal JSON file
    */
    static async loadTravelData() {
        FilePicker.browse("data", `systems/wfrp4e/data/`).then(resp => {

        for (var file of resp.files) {
          try {
            if (!file.includes(".json"))
              continue
            let filename = file.substring(file.lastIndexOf("/") + 1, file.indexOf(".json"));

            fetch(file).then(r => r.json()).then(async records => {
                this.travel_data = records;
            });
          }
          catch (error) {
            console.error("Error reading " + file + ": " + error);
          }
        }
    });
  }

  /**
   * Returns a human-readable danger level for the road
  */
  static dangerToString( dangerLevel )
  {
    if ( dangerLevel == "") return game.i18n.localize("TRAVEL.DangerVeryLow");
    if ( dangerLevel == '!') return game.i18n.localize("TRAVEL.DangerLow");
    if ( dangerLevel == '!!') return game.i18n.localize("TRAVEL.DangerMedium");
    if ( dangerLevel == '!!!') return game.i18n.localize("TRAVEL.DangerHigh");
    return game.i18n.localize("TRAVEL.DangerVeryHigh");
  }

  /**
   * Returns either a decimal value or x.5 value
   * @param {Number} duration 
   * @returns new duration
   */
  static roundDuration( duration ) 
  {
    let trunc = Math.trunc(duration);
    let frac = duration - trunc;
    let adjust = 0;
    if ( frac > 0.75) adjust = 1;
    else if ( frac >= 0.25) adjust = 0.5;
    return trunc + adjust;
  }

    /**
    * This method either display the distances between 2 towns (ie when toTown is set) or display a list of destinations
    * @param {string} fromTown
    * @param {string} toTown
    * @returns 
    */
   static displayTravelDistance( fromTown, toTown ) {
    
    let message = "";

    //("TRAVEL ...", fromTown, toTown );
    if ( toTown ) {
      fromTown = fromTown.toLowerCase();
      toTown = toTown.toLowerCase();
      for ( var travel of this.travel_data) {
        if ( travel.from.toLowerCase() == fromTown && travel.to.toLowerCase() == toTown ) {
          message += `<p>${game.i18n.format("TRAVEL.TravelMessageBase", travel)}`;
          if ( travel.road_distance != "" ) {
            travel.road_horse_heavy_days = this.roundDuration( travel.road_days * 0.8);
            travel.road_horse_fast_days  = this.roundDuration( travel.road_days * 0.65);
            travel.road_feet_days  = this.roundDuration( travel.road_days * 1.25 );
            travel.road_danger_string = this.dangerToString( travel.road_danger );
            travel.road_danger_feet_string = this.dangerToString( travel.road_danger + "!" ); // Increase danger level by feet
            message += `${game.i18n.format("TRAVEL.TravelMessageRoad", travel)}`;                    
          }
          if ( travel.river_distance != "" ) {
            travel.river_danger_string = this.dangerToString( travel.river_danger );
            message += `${game.i18n.format("TRAVEL.TravelMessageRiver", travel)}`;                    
          }
          if ( travel.sea_distance != "" ) {
            travel.sea_danger_string = this.dangerToString( travel.sea_danger );
            message += `${game.i18n.format("TRAVEL.TravelMessageSea", travel)}`;                    
          }
          message += "</p>";
        }
      }
    
    } else if ( fromTown && fromTown == "help") {
      message += `<p>${game.i18n.localize("TRAVEL.Helper")}</p>`;

    } else if ( fromTown) {
      fromTown = fromTown.toLowerCase();
      message += `<h3>${game.i18n.localize("TRAVEL.TownPrompt")}</h3>`;
      for ( var travel of this.travel_data) {
        if ( travel.from.toLowerCase() == fromTown ) {
          message += `<div><a class = "travel-click" data-fromtown="${travel.from}" data-totown = "${travel.to}"><i class="fas fa-list"></i> ${travel.to}</a></div>`;
        }
      }
    } else {
      message += `<h3>${game.i18n.localize("TRAVEL.TownOriginPrompt")}</h3>`;
      let uniqTown = {};
      for ( var travel of this.travel_data) {
        if ( uniqTown[travel.from] == undefined ) {
          uniqTown[travel.from] = 1; // Already added in the list
          message += `<div><a class = "travel-click" data-fromtown="${travel.from}"><i class="fas fa-list"></i> ${travel.from}</a></div>`;
        }
      }
    }
    ChatMessage.create( WFRP_Utility$1.chatDataSetup( message ) );      
   }

   /**
    * 
    */
   static handleTravelClick( event ) {
    let fromTown = $(event.currentTarget).attr("data-fromtown");
    let toTown = $(event.currentTarget).attr("data-totown");
    TravelDistanceWfrp4e.displayTravelDistance( fromTown, toTown);
   }

}

class WFRP_Audio {
  static PlayContextAudio(context) {
    this.MatchContextAudio(context).then(sound => {
      if (!sound || !sound.file) {
        console.warn("wfrp4e | Sound file not found for context: %o", context);
        return
      }
      game.wfrp4e.utility.log(`wfrp4e | Playing Sound: ${sound.file}`);
      AudioHelper.play({ src: sound.file }, sound.global);
    });
    
  }

  static FindContext(test) {
    let context = undefined;

    if (test.skill) {
      if (test.skill.name == game.i18n.localize("NAME.ConsumeAlcohol")) {
        context = { item: test.skill, action: "consumeAlcohol" };
        context.outcome = (test.result.roll <= 5 || test.result.roll <= test.result.target) ? "success" : "fail";
      }
      if (test.skill.name == game.i18n.localize("NAME.PickLock")) {
        context = { item: test.skill, action: "pickLock" };
      }
      else if (test.skill.name == game.i18n.localize("NAME.Stealth")) {
        context = { item: test.skill, action: "stealth" };
        context.outcome = (test.result.roll <= 5 || test.result.roll <= test.result.target) ? "success" : "fail";
      }
    }
    if (test.weapon) {
      context = { item: test.weapon, action: "fire" };
      if (test.result.misfire)
        context.action = "misfire";

      if (test.weapon.attackType == "ranged" && test.result.outcome == "failure" &&
        (test.weapon.weaponGroup.value === "bow"
          || test.weapon.weaponGroup.value === "crossbow"
          || test.weapon.weaponGroup.value === "blackpowder"
          || test.weapon.weaponGroup.value === "engineering")) {
        let delayedContext = foundry.utils.deepClone(context);
        delayedContext.action = "miss";
        setTimeout((delayedContext) => { this.PlayContextAudio(delayedContext); }, 1000, delayedContext);
      }

      if (test.weapon.weaponGroup == "explosives" || test.weapon.weaponGroup == "throwing")
        context.action = "throw";
    }
    if (test.result.critical && test.weapon && test.weapon.properties.qualities.impale) {
      context = { item: {}, action: "hit", outcome: "crit_impale" };
    }
    if (test.spell) {
        if (test.result.castOutcome == "success"){
        context = { item: test.spell, action: "cast" };
        if (test.spell.damage)
          context.outcome = "damage";
      }

      if (test.result.minormis || test.result.majormis)
        context = { item: test.spell, action: "miscast" };
    }
    if (test.prayer) {
      if (test.result.outcome == "success")
        context = { item: test.prayer, action: "cast" };

      if (test.result.wrath)
        context = { item: test.prayer, action: "miscast" };
    }

    return context
  }



  /** CONTEXTUAL MODEL
   *  context = {
   *      action : equip, cast, lose, gain, etc.
   *      item : item associated with the action
   *      outcome : typcially success or failure, or other specifier, sometimes unused
   *  }
   */

  static async MatchContextAudio(context) {
    if (!game.settings.get("wfrp4e", "soundPath") || !context)
      return {}

    try {
      let files, file, group;
      await FilePicker.browse("user", game.settings.get("wfrp4e", "soundPath")).then(resp => {
        files = resp.files;
      });
      if (context.action == "hit")
        file = "hit";
      let globalSound = false;
      {
        switch (context.item.type) {
          case "weapon":
            group = context.item.weaponGroup.value;
            if (group == "crossbow")
              file = context.action == "equip" ? "weapon_bow" : "weapon_xbow";
            else if (group == "bow")
              file = "weapon_bow";
            else if (group == "fencing" || group == "parry" || group == "twohanded")
              file = context.action == "fire" ? "weapon-" : "weapon_sword";
            else if (group == "flail" && context.action == "fire") {
              file = "weapon_flail-";
              if (context.item.properties.qualities.impact)
                file = "weapon_flail_impact";
            }
            else if (group == "blackpowder" || group == "engineering")
              file = "weapon_gun";
            else if (group == "explosives")
              file = "weapon_bomb";
            else if (group == "throwintg") {
              file = "weapon-";
              if (context.action != "equip") {
                file = "weapon_throw";
                if (context.item.properties.qualities.hack)
                  file = "weapon_axe_throw";
              }
            }
            else if (group == "entangling" && context.action != "swing")
              file = "weapon_entangling";
            else
              file = "weapon-";
            break;
          case "armour":
            if (context.action.includes("equip")) {
              group = context.item.armorType.value;
              file = group.includes("Leather") ? "leather" : group;
            }
            else if (context.action == "hit") {
              group = context.item.type;
              file = context.outcome || "";
            }
            break;
          case "trapping":
            file = context.item.trappingType.value.includes("clothing") ? "cloth" : "item";
            break;
          case "spell":
            file = "spell";
            break;
          case "prayer":
            file = "prayer";
            break;
          case "round":
            file = "round";
            globalSound = true;
            break;
          case "skill":
            file = "skill";
            break;
          case "money":
            file = "money";
            break;
          case "shield":
            file = "weapon_shield";
            break;
          case "throw":
            file = "hit_throw-";
            break;
          case "throw_axe":
            file = "hit_throw_axe";
            break;
        }
      }
      if (context.item.special == "warhammer")
        file = "warhammer";
      files = files.filter(f => f.includes(file));

      if (context.item.type == "weapon") {
        globalSound = true;

        if (context.action == "miss")
          files = files.filter(f => f.includes("-miss"));
        else if (context.action == "misfire")
          files = files.filter(f => f.includes("-misfire"));
        else if (context.action == "fire") {
          if (file == "weapon_xbow" || file == "weapon_bow" || file == "weapon_gun" || file.includes("throw"))
            files = files.filter(f => f.includes("-fire"));
          else if (file != "weapon_bomb")
            files = files.filter(f => f.includes("-swing"));
          else
            files = files.filter(f => f.includes("-throw"));
        }
        else if (context.action == "load")
          files = files.filter(f => f.includes("-load"));
        else if (context.action == "damage") {
          globalSound = false;
          files = files.filter(f => f.includes("damage"));
          if (context.outcome == "shield")
            files = files.filter(f => f.includes("shield"));
        }

      }
      if (context.item.type == "shield") {
        files = files.filter(f => f.includes(context.action));
      }
      if (context.action == "equip") {
        if (context.outcome || context.item.type == "weapon") {
          files = files.filter(f => f.includes("-equip"));
        }
        else {
          files = files.filter(f => f.includes("deequip"));
        }
      }
      if (context.action == "hit") {
        files = files.filter(f => f.includes("hit"));
      }

      if (context.item.type == "spell") {
        if (context.action == "memorize")
          files = files.filter(f => f.includes("-memorize"));
        else if (context.action == "unmemorize")
          files = files.filter(f => f.includes("unmemorize"));
        else if (context.action == "cast") {
          if (context.outcome == "damage")
            files = files.filter(f => f.includes("damage-cast"));
          else
            files = files.filter(f => f.includes("-cast") && !f.includes("damage"));
          globalSound = true;
        }
        else {
          files = files.filter(f => f.includes("miscast"));
          globalSound = true;
        }
      }

      if (context.item.type == "prayer") {
        globalSound = true;
        if (context.action == "cast")
          files = files.filter(f => f.includes("-cast"));
        else
          files = files.filter(f => f.includes("miscast"));
      }

      if (context.action == "hit") {
        globalSound = true;
        if (context.outcome == "blocked")
          files = files.filter(f => f.includes(context.item.armourType));
        else if (context.item.type == "armour")
          files = files.filter(f => f.includes("armour"));
        else
          files = files.filter(f => !f.includes("armour")); // all non-armour sounds

        if (context.outcome == "normal")
          files = files.filter(f => f.includes("normal"));

        if (context.outcome == "warhammer")
          files = files.filter(f => f.includes("warhammer"));


        if (context.outcome == "crit")
          files = files.filter(f => f.includes("crit-"));
        if (context.outcome == "crit_impale")
          files = files.filter(f => f.includes("crit_impale"));
      }

      if (context.item.type == "skill") {
        if (context.action == "consumeAlcohol")
          files = files.filter(f => f.includes(`consumeAlcohol-${context.outcome == "fail" ? 'fail' : 'success'}`));
        if (context.action == "stealth")
          files = files.filter(f => f.includes(`stealth-${context.outcome == "fail" ? 'fail' : 'success'}`));
        if (context.action == "pickLock")
          files = files.filter(f => f.includes(context.action));
      }

      return { file: files[(await new Roll(`1d${files.length}-1`).roll({ async: true })).total], global: globalSound }
    }
    catch (e) {
      WFRP_Utility$1.log("Sound Context Error: " + e, true);
    }
  }
}

/**
 * Shamelessly copied from dnd5e's spell template implementation
 * @extends {MeasuredTemplate}
 */
class AbilityTemplate extends MeasuredTemplate {

  /**
   * Track the timestamp when the last mouse move event was captured.
   * @type {number}
   */
  #moveTime = 0;

  /* -------------------------------------------- */

  /**
   * The initially active CanvasLayer to re-activate after the workflow is complete.
   * @type {CanvasLayer}
   */
  #initialLayer;

  /* -------------------------------------------- */

  /**
   * Track the bound event handlers so they can be properly canceled later.
   * @type {object}
   */
  #events;

    /**
     * A factory method to create an AOETemplate instance using provided string
     * @param {String} aoestring          string describing the area of effect (AoE(5 yards) or just 5 yards)
     * @return {AbilityTemplate|null}     The template object, or null if the item does not produce a template
     */
    static fromString(aoeString, actorId, itemId, messageId, diameter=true) 
    {
      if (aoeString.toLowerCase().includes(game.i18n.localize("AoE").toLowerCase()))
        aoeString = aoeString.substring(aoeString.indexOf("(")+1, aoeString.length-1);
      
      // Prepare template data
      const templateData = {
        t: "circle",
        user: game.user.id,
        distance: diameter ? parseInt(aoeString) / 2 : parseInt(aoeString),
        direction: 0,
        x: 0,
        y: 0,
        fillColor: game.user.color,
        flags: {
          wfrp4e: {
            itemuuid: `Actor.${actorId}.Item.${itemId}`,
            messageId: messageId,
            round: game.combat?.round ?? -1
          }
        }
      };
  
      const cls = CONFIG.MeasuredTemplate.documentClass;
      const template = new cls(templateData, {parent: canvas.scene});
  
      // Return the template constructed from the item data
      return new this(template);
    }

  static async fromEffect(effectUuid, messageId, radius) {

    let effect = fromUuidSync(effectUuid);
    radius = radius || await effect.computeAuraRadius(); 

    // Prepare template data
    const templateData = {
      t: "circle",
      user: game.user.id,
      distance: radius,
      direction: 0,
      x: 0,
      y: 0,
      fillColor: game.user.color,
      flags: {
        wfrp4e: {
          effectUuid: effectUuid,
          messageId: messageId,
          round: game.combat?.round ?? -1
        }
      }
    };

    const cls = CONFIG.MeasuredTemplate.documentClass;
    const template = new cls(templateData, { parent: canvas.scene });

    // Return the template constructed from the item data
    return new this(template);
  }
  /* -------------------------------------------- */

  /**
   * Creates a preview of the spell template.
   * @returns {Promise}  A promise that resolves with the final measured template if created.
   */
  drawPreview() {
    const initialLayer = canvas.activeLayer;

    // Draw the template and switch to the template layer
    this.draw();
    this.layer.activate();
    this.layer.preview.addChild(this);

    // Hide the sheet that originated the preview
    this.actorSheet?.minimize();

    // Activate interactivity
    return this.activatePreviewListeners(initialLayer);
  }

  /* -------------------------------------------- */

  /**
   * Activate listeners for the template preview
   * @param {CanvasLayer} initialLayer  The initially active CanvasLayer to re-activate after the workflow is complete
   * @returns {Promise}                 A promise that resolves with the final measured template if created.
   */
  activatePreviewListeners(initialLayer) {
    return new Promise((resolve, reject) => {
      this.#initialLayer = initialLayer;
      this.#events = {
        cancel: this._onCancelPlacement.bind(this),
        confirm: this._onConfirmPlacement.bind(this),
        move: this._onMovePlacement.bind(this),
        resolve,
        reject,
        rotate: this._onRotatePlacement.bind(this)
      };

      // Activate listeners
      canvas.stage.on("mousemove", this.#events.move);
      canvas.stage.on("mousedown", this.#events.confirm);
      canvas.app.view.oncontextmenu = this.#events.cancel;
      canvas.app.view.onwheel = this.#events.rotate;
    });
  }

  /* -------------------------------------------- */

  /**
   * Shared code for when template placement ends by being confirmed or canceled.
   * @param {Event} event  Triggering event that ended the placement.
   */
  async _finishPlacement(event) {
    this.layer._onDragLeftCancel(event);
    canvas.stage.off("mousemove", this.#events.move);
    canvas.stage.off("mousedown", this.#events.confirm);
    canvas.app.view.oncontextmenu = null;
    canvas.app.view.onwheel = null;
    this.#initialLayer.activate();
    await this.actorSheet?.maximize();
  }

  /* -------------------------------------------- */

  /**
   * Move the template preview when the mouse moves.
   * @param {Event} event  Triggering mouse event.
   */
  _onMovePlacement(event) {
    event.stopPropagation();
    let now = Date.now(); // Apply a 20ms throttle
    if ( now - this.#moveTime <= 20 ) return;
    const center = event.data.getLocalPosition(this.layer);
    const snapped = canvas.grid.getSnappedPosition(center.x, center.y, 2);
    this.document.updateSource({x: snapped.x, y: snapped.y});
    this.refresh();
    this.#moveTime = now;
    if (game.wfrp4e.utility.CtrlKeyPressed) {
      this.constructor.updateAOETargets(this.document);
    }
  }

  /* -------------------------------------------- */

  /**
   * Rotate the template preview by 3 increments when the mouse wheel is rotated.
   * @param {Event} event  Triggering mouse event.
   */
  _onRotatePlacement(event) {
    if ( event.ctrlKey ) event.preventDefault(); // Avoid zooming the browser window
    event.stopPropagation();
    let delta = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 30 : 15;
    let snap = event.shiftKey ? delta : 5;
    const update = {direction: this.document.direction + (snap * Math.sign(event.deltaY))};
    this.document.updateSource(update);
    this.refresh();
  }

  /* -------------------------------------------- */

  /**
   * Confirm placement when the left mouse button is clicked.
   * @param {Event} event  Triggering mouse event.
   */
  async _onConfirmPlacement(event) {
    await this._finishPlacement(event);
    const destination = canvas.grid.getSnappedPosition(this.document.x, this.document.y, 2);
    this.document.updateSource(destination);
    this.#events.resolve(canvas.scene.createEmbeddedDocuments("MeasuredTemplate", [this.document.toObject()]).then(templates => {
      let test = game.messages.get(templates[0].flags.wfrp4e.messageId)?.getTest();
      if (test && test.data.context.templates)
      {
        test.data.context.templates = test.data.context.templates.concat(templates[0].id);
        test.renderRollCard();
      }
    }));
  }

  /* -------------------------------------------- */

  /**
   * Cancel placement when the right mouse button is clicked.
   * @param {Event} event  Triggering mouse event.
   */
  async _onCancelPlacement(event) {
    await this._finishPlacement(event);
    this.#events.reject();
  }

  static updateAOETargets(templateData, onlyReturn = false)
  {
    let newTokenTargets = [];
    let type = templateData.t;
    let distance = templateData.distance;
    let angle = templateData.angle;
    let direction = templateData.direction;
    let width = templateData.width;
    switch ( type ) {
      case "circle":
        templateData.object.shape = MeasuredTemplate.getCircleShape(distance);
        break;
      case "cone":
        templateData.object.shape = MeasuredTemplate.getConeShape(direction, angle, distance);
        break;
      case "rect":
        templateData.object.shape = MeasuredTemplate.getRectShape(direction, distance);
        break;
      case "ray":
        templateData.object.shape = MeasuredTemplate.getRayShape(direction, distance, width);
        break;
    }

    let tokens = game.canvas.tokens.placeables.map(x=>x.document);
    for (let t of tokens) {
      if (templateData._boundsOverlap(t)) {
        newTokenTargets.push(t.id);
      }
    }
    if (!onlyReturn) {
      game.user.updateTokenTargets(newTokenTargets);
      game.user.broadcastActivity({targets: newTokenTargets});
    }
    return newTokenTargets;
  }
}

class AreaHelpers
{
    /**
     * Determines if a coordinate is within a Template's strokes
     *
     * @param {Object} {x, y} object being tested
     * @param {Template} template Template object being tested
     * @returns
     */
    static isInTemplate(point, template)
    {
        if (template.document.t == "rect")
        {
            return this._isInRect(point, template);
        }
        else if (["ray", "cone"].includes(template.document.t))
        {
            return this._isInPolygon(point, template);
        }
        else if (template.document.t == "circle")
        {
            return this._isInEllipse(point, template);
        }
    }


    /**
     * Get all Tokens inside template
     *
     * @returns
     */
    static tokensInTemplate(template)
    {
        let scene = template.scene;
        let tokens = scene.tokens.contents;
        return tokens.filter(t => this.isInTemplate(t.object.center, template));
    }

    static _isInEllipse(point, template)
    {
        let grid = canvas.scene.grid;
        let templateGridSize = template.document.distance/grid.distance * grid.size;
        // NEED TO USE template.document - hooks don't reflect template.x/y immediately
        let ellipse = new PIXI.Ellipse(template.document.x, template.document.y, templateGridSize, templateGridSize);
        return ellipse.contains(point.x, point.y);
    }


    // Not used currently
    static _isInRect(point, template)
    {
        // let x1 = template.document.x;
        // let x2 = x1 + template.document.shape.width;
        // let y1 = template.document.y;
        // let y2 = y1 + template.document.shape.height;

        // if (point.x > x1 && point.x < x2 && point.y > y1 && point.y < y2)
        // {
        //     return true;
        // }
    }

    // Not used currently
    static _isInPolygon(point, template)
    {                                                                                 // points are relative to origin of the template, needs to be origin of the map
        let polygon = new PIXI.Polygon(template.shape.points.map((coord, index) => coord += index % 2 == 0 ? template.document.x : template.document.y ));
        return polygon.contains(point.x, point.y);
    }


    // Perhaps this is expensive to run on every token update
    // but works for now
    static async checkAreas(scene)
    {
        let tokens = scene.tokens;
        let templates = scene.templates.contents.map(t => t.object).concat(await this.aurasInScene(scene));

        for(let token of tokens)
        {
            for(let template of templates)
            {
                // An area could be a template, but could be an effect (aura)
                let areaUuid = (template.document.id ? template.document?.uuid : template.document.flags.wfrp4e.effectUuid);

                let existingEffect = token.actor.currentAreaEffects.find(effect => effect.getFlag("wfrp4e", "fromArea") == areaUuid && !effect.applicationData.keep);
                let inTemplate = this.isInTemplate(token.object.center, template);
                if (inTemplate && !existingEffect)
                {
                    let effect = template.document.areaEffect() || template.auraEffect;
                    if (effect && template.auraEffect?.actor != token.actor) // Specifically don't apply auras to self
                    {
                        // if template was placed from a test
                        let messageId = template.document?.getFlag("wfrp4e", "messageId");
                        let effectData = effect.convertToApplied(game.messages.get(messageId)?.getTest());
                        setProperty(effectData, "flags.wfrp4e.fromArea",  areaUuid);
                        // Can't just send UUID because we need to include fromArea flags
                        token.actor.applyEffect({effectData : [effectData]});
                    }
                }
                else if (!inTemplate && existingEffect) // If not in template, remove all effects originating from that template
                {
                    existingEffect.delete();
                }
            }
        }
    }



    // Create temporary MeasuredTemplates so that auras can
    // be processed the same way as normal Area effects
    static aurasInScene(scene)
    {
        let templates = [];
        for(let token of scene.tokens)
        {
            let auraEffects = token.actor.auras;
            for (let effect of auraEffects)
            {
                templates.push(this.effectToTemplate(effect));
            }
        }
        return Promise.all(templates);
    }

    static async effectToTemplate(effect)
    {
        let token = effect.actor.getActiveTokens()[0];
        let template = new MeasuredTemplate(new CONFIG.MeasuredTemplate.documentClass({
            t: "circle",
            user: game.user.id,
            distance: await effect.computeAuraRadius(),
            direction: 0,
            x: token.center.x,
            y: token.center.y,
            flags: {
                wfrp4e: {
                    effectUuid: effect.uuid
                }
            }
            }, {parent : canvas.scene}));

        // For some reason, these temporary templates have 0,0 as their coordinates
        // instead of the ones provided by the document, so set them manually
        template.x = template.document.x;
        template.y = template.document.y;
        template.auraEffect = effect;
        return template
    }
}

class CharacteristicTest extends TestWFRP {
  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return

    if (this.actor.type == "vehicle")
      this.data.preData.item = "t";
      
    this.computeTargetNumber();
  }

  computeTargetNumber() {
    this.data.result.target = this.item.value;
    super.computeTargetNumber();
  }

  get item() {
    return this.actor.characteristics[this.data.preData.item]
  }
  get characteristic() {
    return this.item
  }
  get characteristicKey()
  {
      return this.preData.item
  }
}

/**
 * Easily handle and compute tooltips for dialog fields
 * 
 * Call #start to mark the initial values of the dialog
 * Call #finish to compare the initial with the current values
 */
class DialogTooltips 
{
    _modifier = [];
    _slBonus = [];
    _successBonus = [];
    _difficulty = [];

    _modifier1 = null;
    _slBonus1 = null;
    _successBonus1 = null;
    _difficulty1 = null;

    _modifier2 = null;
    _slBonus2 = null;
    _successBonus2 = null;
    _difficulty2 = null;

    constructor()
    {

    }

    get modifier() 
    {
        return this._formatTooltip("modifier");
    }
    get SL() 
    {
        return this._formatTooltip("SL");
    }
    get slBonus() 
    {
        return this._formatTooltip("slBonus");
    }
    get successBonus() 
    {
        return this._formatTooltip("successBonus");
    }
    get difficulty() 
    {
        return this._formatTooltip("difficulty");
    }

    clear() 
    {
        this.reset();
        this._modifier = [];
        this._slBonus = [];
        this._successBonus = [];
        this._difficulty = [];
    }

    reset()
    {
        this._modifier1 = null;
        this._slBonus1= null;
        this._successBonus1 = null;
        this._difficulty1 = null;

        this._modifier2 = null;
        this._slBonus2= null;
        this._successBonus2 = null;
        this._difficulty2 = null;
    }

    start(dialog)
    {
        this.reset();
        this._modifier1 = dialog.fields.modifier;
        this._slBonus1 = dialog.fields.slBonus;
        this._successBonus1 = dialog.successBonus;
        this._difficulty1 = dialog.fields.difficulty;
    }

    finish(dialog, label)
    {
        this._modifier2 = dialog.fields.modifier;
        this._slBonus2 = dialog.fields.slBonus;
        this._successBonus2 = dialog.successBonus;
        this._difficulty2 = dialog.fields.difficulty;

        this._computeDiff(label);
    }

    addModifier(value, label)
    {
        this._addTooltip("modifier", value, label);
    }

    addSLBonus(value, label)
    {
        this._addTooltip("slBonus", value, label);
    }

    addSuccessBonus(value, label)
    {
        this._addTooltip("successBonus", value, label);
    }

    _addTooltip(type, value, label)
    {
        if (value && label)
        {
            this[`_${type}`].push({value, label});
        }
    }

    _computeDiff(label)
    {

        let modifierDiff    = this._modifier2 - this._modifier1;
        let slBonusDiff     = this._slBonus2 - this._slBonus1;
        let successBonusDiff    = this._successBonus2 - this.successBonus1;
        let difficultyDiff  = this._difficulty2 != this._difficulty1;

        if (modifierDiff)
        {
            this._modifier.push({value : modifierDiff, label});
        }
        if (slBonusDiff)
        {
            this._slBonus.push({value : slBonusDiff, label});
        }
        if (successBonusDiff)
        {
            this._successBonus.push({value : successBonusDiff, label});
        }
        if (difficultyDiff)
        {
            this._difficulty.push({label});
        }
    }

    _formatTooltip(type)
    {
        if (this[`_${type}`].length == 0)
        {
            return "";
        }
        else 
        {
            return `<p>${this[`_${type}`].map(i => 
            {
                if (i.value)
                {
                    // Add sign to positive numbers
                    return `&#8226; ${i.label} (${i.value > 0 ? "+" + i.value : i.value})`;
                }
                else 
                { 
                    return `&#8226; ${i.label}`; 
                }

            }).join("</p><p>")}</p>`;
        }   
    }
}

class RollDialog extends Application {


    subTemplate = "";
    chatTemplate = ""
    selectedScripts = [];
    unselectedScripts = [];
    testClass = null;
    #onKeyPress;


    static get defaultOptions() {
        const options = super.defaultOptions;
        options.resizable = true;
        options.classes = options.classes.concat(["wfrp4e", "wfrp4e-dialog"]);
        return options;
    }
 
    get actor() 
    {
        return this.data.actor;
    }

    get template() 
    {
      return "systems/wfrp4e/templates/dialog/base-dialog.hbs";
    }

    constructor(fields, data, resolve, options)
    {
        super(options);
        this.data = data;
        this.fields = mergeObject(this._defaultFields(),fields);
        this.userEntry = foundry.utils.deepClone(this.fields);
        this.tooltips = new DialogTooltips();

        this.data.scripts = this._consolidateScripts(data.scripts);

        if (resolve)
        {
            this.resolve = resolve;
        }
    }

    /**
     * @abstract
     */
    static async setup(fields={}, data={}, options={})
    {
        throw new Error("Only subclasses of RollDialog can be setup")
    }

    activateListeners(html) {
        super.activateListeners(html);

        this.form = html[0];
        this.form.onsubmit = this.submit.bind(this);

        // Listen on all elements with 'name' property
        html.find(Object.keys(new FormDataExtended(this.form).object).map(i => `[name='${i}']`).join(",")).change(this._onInputChanged.bind(this));

        html.find(".dialog-modifiers .modifier").click(this._onModifierClicked.bind(this));

        html.find("[name='advantage']").change(this._onAdvantageChanged.bind(this));
        
        // Need to remember binded function to later remove
        this.#onKeyPress = this._onKeyPress.bind(this);
        document.addEventListener("keypress", this.#onKeyPress);

    }

    submit(ev) 
    {
        ev.preventDefault();
        ev.stopPropagation();
        
        for(let script of this.data.scripts)
        {
            if (script.isActive)
            {
                script.submission(this);
            }
        }

        let test = new this.testClass(this._constructTestData(), this.actor);
        
        if (this.resolve)
        {
            this.resolve(test);
        }
        this.close();
        return test;
    }

    _constructTestData()
    {
        if (!this.testClass)
        {
            throw new Error("Only subclasses of RollDialog can be submitted")
        }
        let data = mergeObject(this.data, this.fields);
        data.options = this.options;
        data.targets = Array.from(data.targets).map(t => t.actor.speakerData(t.document));
        data.chatOptions = this._setupChatOptions();
        return data
    }

    close() 
    {
        super.close();
        document.removeEventListener("keypress", this.#onKeyPress);
    }

    async getData() 
    {
        this.tooltips.clear();

        // Reset values so they don't accumulate 
        mergeObject(this.fields, this.userEntry);

        // calling tooltips.start/finish between the merge object caused issues
        this.tooltips.addModifier(this.userEntry.modifier, "User Entry");
        this.tooltips.addSLBonus(this.userEntry.slBonus, "User Entry");
        this.tooltips.addSuccessBonus(this.userEntry.successBonus, "User Entry");

        // For some reason cloning the scripts doesn't prevent isActive and isHidden from persisisting
        // So for now, just reset them manually
        this.data.scripts.forEach(script => 
        {
            script.isHidden = false;
            script.isActive = false;
        });
        
        this._hideScripts();
        this._activateScripts();
        await this.computeScripts();        
        await this.customPrefillModifiers();
        await this.computeFields();

        return {
            data : this.data,
            fields : this.fields,
            tooltips : this.tooltips,
            subTemplate : await this.getSubTemplate()
        };
    }

    /**
     * This is mostly for talents, where an actor likely has multiple
     * of the same talent. We don't want to show the same dialog effect
     * multiple times, so instead count the number of scripts that are the 
     * same. When executed, execute it the number of times there are scripts
     * 
     */
    _consolidateScripts(scripts)
    {
        let consolidated = [];

        for(let script of scripts)
        {
            let existing = consolidated.find(s => isSameScript(script, s));
            if (!existing)
            {
                script.scriptCount = 1;
                consolidated.push(script);
            }
            else 
            {
                existing.scriptCount++;
            }
        }

        function isSameScript(a, b)
        {
            return (a.label == b.label) &&
             (a.script == b.script) && 
             (a.hideScript == b.hideScript) && 
             (a.activateScript == b.activateScript) &&
             (a.submissionScript == b.submissionScript)
        }
        return consolidated
    }

    _hideScripts()
    {
        this.data.scripts.forEach((script, index) => 
        {
            // If user selected script, make sure it is not hidden, otherwise, run its script to determine
            if (this.selectedScripts.includes(index))
            {
                script.isHidden = false;
            }
            else
            {
                script.isHidden = script.hidden(this);
            }
        });
    }

    _activateScripts()
    {
        this.data.scripts.forEach((script, index) => 
        {
            // If user selected script, activate it, otherwise, run its script to determine
            if (this.selectedScripts.includes(index))
            {
                script.isActive = true;
            }
            else if (this.unselectedScripts.includes(index))
            {
                script.isActive = false;
            }
            else if (!script.isHidden) // Don't run hidden script's activation test
            {
                script.isActive = script.activated(this);
            }
        });
    }

    async computeScripts() 
    {
        for(let script of this.data.scripts)
        {
            if (script.isActive)
            {
                this.tooltips.start(this);
                for(let i = 0; i < script.scriptCount; i++)
                {
                    await script.execute(this);
                }
                this.tooltips.finish(this, script.label);
            }
        }
    }
    
    // TODO: Adjust prefil modifiers. 
    async customPrefillModifiers() 
    {
        const obj = game.wfrp4e.config.customPrefillModifiers;
        const functions = Object.getOwnPropertyNames(obj).filter(function (p) { return typeof obj[p] === 'function' });
        for (let func of functions) 
        {
            this.tooltips.start(this);
            await game.wfrp4e.config.customPrefillModifiers[func].call(this);
            this.tooltips.finish(this, func.label);
        }
    }



    async computeFields() 
    {
        this._computeAdvantage();
        if (this.actor.attacker)
        {
            this._computeDefending(this.actor.attacker);
        }

        if (this.data.targets.length && !this.actor.attacker)
        {
            this._computeTargets(this.data.targets[0]);
        }
    }

    _computeAdvantage()
    {
        if (game.settings.get("wfrp4e", "autoFillAdvantage"))
        {
            this.tooltips.start(this);
            if (!game.settings.get("wfrp4e", "mooAdvantage"))
            {
                this.fields.modifier += (game.settings.get("wfrp4e", "advantageBonus") * this.fields.advantage);
            }
            else 
            {
                this.fields.successBonus += this.fields.advantage;
            }
            this.tooltips.finish(this, "Advantage");
        }
    }

    /**
     * Runs when the actor is being attacked
     * @abstract
     */
    _computeDefending(attacker)
    {

    }

    /** 
     * Runs if targeting an actor
     * @abstract
     */
    _computeTargets(target)
    {

    }

    
    /**
     * Allows subclasses to insert custom fields
     */
     async getSubTemplate()
     {
         if (this.subTemplate)
         {
             return await renderTemplate(this.subTemplate, {fields : this.fields, data: this.data, options : this.options});
         }
     }


    _onInputChanged(ev) 
    {
        let value = ev.currentTarget.value;
        if (Number.isNumeric(value))
        {
            value = Number(value);
        }

        if (ev.currentTarget.type == "checkbox")
        {
            value = ev.currentTarget.checked;
        }

        this.userEntry[ev.currentTarget.name] = value;

        this.render(true);
    }

    _onModifierClicked(ev)
    {
        let index = Number(ev.currentTarget.dataset.index);
        if (!ev.currentTarget.classList.contains("active"))
        {
            // If modifier was unselected by the user (originally activated via its script)
            // it can be assumed that the script will still be activated by its script
            if (this.unselectedScripts.includes(index))
            {
                this.unselectedScripts = this.unselectedScripts.filter(i => i != index);
            }
            else 
            {
                this.selectedScripts.push(index);
            }
        }
        else 
        {
            // If this modifier was NOT selected by the user, it was activated via its script
            // must be added to unselectedScripts instead
            if (!this.selectedScripts.includes(index))
            {
                this.unselectedScripts.push(index);
            }
            else // If unselecting manually selected modifier
            {
                this.selectedScripts = this.selectedScripts.filter(i => i != index);
            }
        }
        this.render(true);
    }

    _onAdvantageChanged(ev)
    {
        this.actor.update({"system.status.advantage.value" : Number(ev.currentTarget.value)});
        ui.notifications.notify(game.i18n.localize("DIALOG.AdvantageUpdate"));
    }

    /**
     * 
     * @param {object} data Dialog data, such as title and actor
     * @param {object} data.title.replace Custom dialog/test title
     * @param {object} data.title.append Append something to the test title
     * @param {object} fields Predefine dialog fields
     */
    static awaitSubmit({data={}, fields={}}={})
    {
        return new Promise(resolve => 
        {
            new this(data, fields, resolve).render(true);
        });
    }

    _onKeyPress(ev)
    {
        if (ev.key == "Enter")
        {
            this.submit(ev); 
        }
    }
    
    updateTargets()
    {
        this.data.targets = Array.from(game.user.targets);
        this.render(true);
    }


    _defaultDifficulty()
    {
        let difficulty = "challenging";

        // Overrides default difficulty to Average depending on module setting and combat state
        if (game.settings.get("wfrp4e", "testDefaultDifficulty") && (game.combat != null))
            difficulty = game.combat.started ? "challenging" : "average";
        else if (game.settings.get("wfrp4e", "testDefaultDifficulty"))
            difficulty = "average";

        return difficulty;
    }
    _defaultFields() 
    {
        return {
            advantage : 0,
            modifier : 0,
            successBonus : 0,
            slBonus : 0,
            difficulty : this._defaultDifficulty(),
            rollmode : game.settings.get("core", "rollMode") || "publicroll"
        };
    }

    
    static updateActiveDialogTargets() 
    {
        Object.values(ui.windows).forEach(i => 
        {
            if (i instanceof TestDialog)
            {
                i.updateTargets();
            }
        });
    }

 /**
   * Ghat card options.
   *
   * All tests use the same chatOptions, but use the template member defined in each dialog class
   */
    _setupChatOptions() {
        let chatOptions = {
            speaker: {
                alias: this.actor.token?.name || this.actor.prototypeToken.name,
                actor: this.actor.id,
            },
            title: this.options.title,
            template: this.chatTemplate,
            flags: { img: this.actor.prototypeToken.randomImg ? this.img : this.actor.prototypeToken.texture.src }
            // img to be displayed next to the name on the test card - if it's a wildcard img, use the actor image
        };

        // If the test is coming from a token sheet
        if (this.actor.token) {
        chatOptions.speaker.alias = this.actor.token.name; // Use the token name instead of the actor name
        chatOptions.speaker.token = this.actor.token.id;
        chatOptions.speaker.scene = canvas.scene.id;
        chatOptions.flags.img = this.actor.token.texture.src; // Use the token image instead of the actor image

        if (this.actor.token.hidden) {
            chatOptions.speaker.alias = "???";
            chatOptions.flags.img = "systems/wfrp4e/tokens/unknown.png";
        }
        }
        else // If a linked actor - use the currently selected token's data if the actor id matches
        {
        let speaker = ChatMessage.getSpeaker();
        if (speaker.actor == this.actor.id) 
        {
            let token = speaker.token ? canvas.tokens.get(speaker.token) : null;
            chatOptions.speaker.alias = speaker.alias;
            chatOptions.speaker.token = speaker.token;
            chatOptions.speaker.scene = speaker.scene;
            chatOptions.flags.img = token ? token.document.texture.src : chatOptions.flags.img;
            if (token?.document.hidden) {
            chatOptions.speaker.alias = "???";
            chatOptions.flags.img = "systems/wfrp4e/tokens/unknown.png";
            }
        }
        }

        if (this.isMounted && this.mount) {
            chatOptions.flags.mountedImg = this.mount.prototypeToken.texture.src;
            chatOptions.flags.mountedName = this.mount.prototypeToken.name;
        }

        if (VideoHelper.hasVideoExtension(chatOptions.flags.img))
        game.video.createThumbnail(chatOptions.flags.img, { width: 50, height: 50 }).then(img => chatOptions.flags.img = img);

        //Suppresses roll sound if the test has it's own sound associated
        mergeObject(chatOptions,
        {
            user: game.user.id,
            sound: CONFIG.sounds.dice
        }, {overwrite : false});

        return chatOptions
    }


    // Backwards compatibility for effects
    get prefillModifiers() 
    {
        return this.fields;
    }

    get type() 
    {

    }
}

class CharacteristicDialog extends RollDialog {

    testClass = CharacteristicTest
    chatTemplate = "systems/wfrp4e/templates/chat/roll/characteristic-card.hbs"

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["characteristic-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.characteristic
    }

    get characteristic() 
    {
      return this.data.characteristic;
    }


    static async setup(fields={}, data={}, options={})
    {
        options.title = options.title || game.i18n.format("CharTest", {char: game.wfrp4e.config.characteristics[data.characteristic]});
        options.title += options.appendTitle || "";

        return new Promise(resolve => {
            new this(fields, data, resolve, options).render(true);
        })
    }

    
    _constructTestData()
    {
        let data = super._constructTestData();
        data.item = this.data.characteristic;
        return data;
    }

    
    computeFields() {
        super.computeFields();

        if (this.options.dodge && this.actor.isMounted) {
            this.fields.modifier -= 20;
            this.tooltips.addModifier(-20, game.i18n.localize("EFFECT.DodgeMount"));
        }
    }


    _computeDefending(attacker)
    {
        if (attacker.test.item.properties?.flaws.slow) {
            if (!game.settings.get("wfrp4e", "mooQualities") && options.dodge) 
            {
                this.fields.slBonus += 1;
                this.tooltips.addSLBonus(1, game.i18n.localize('CHAT.TestModifiers.SlowDefend'));
            }
        }

    }
    
    _defaultDifficulty() 
    {
        let difficulty = super._defaultDifficulty();
        if (this.options.corruption || this.options.mutate)
        {
            difficulty = "challenging";
        }

        if (this.options.rest || this.options.income)
        {
            difficulty =  "average";
        }
        return difficulty;
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "characteristic";
    }
}

class SkillTest extends TestWFRP {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return
    this.data.preData.options.characteristicToUse = data.characteristicToUse;
    this.data.preData.skillName = data.skillName;
    this.computeTargetNumber();
  }

  computeTargetNumber() {

    // If unknown skill, defer until later, once skill is found
    if (this.preData.item == "unknown" && !this.context.unknownSkill)
      return 0

    try {
      // If skill is not owned by the actor, just use characteristic
      if (this.context.unknownSkill) {
        this.result.target = this.actor.characteristics[this.context.unknownSkill.system.characteristic.value].value;
      }
      else {


        // Use skill total if characteristics match, otherwise add the total up manually
        if (this.preData.options.characteristicToUse && this.preData.options.characteristicToUse != this.item.characteristic.key)
          this.result.target = this.actor.characteristics[this.preData.options.characteristicToUse].value + this.item.advances.value;
        else
          this.result.target = this.item.total.value;
      }
    }
    catch
    {
      this.result.target = this.item.total.value;
    }

    super.computeTargetNumber();
  }

  async roll() {

    // If skill id is unknown, meaning the actor doesn't have the skill, find the skill and use characteristic
    if (this.preData.item == "unknown") {
      let skill = await WFRP_Utility$1.findSkill(this.preData.skillName);
      if (skill) {
        this.context.unknownSkill = skill.toObject();
        this.computeTargetNumber();
      }
      else {
        throw new Error(game.i18n.localize("ERROR.Found", { name: this.skill }))
      }
    }


    await super.roll();
  }

  get skill() {
    return this.item
  }

  get item() {
    return this.unknownSkill ? this.unknownSkill : super.item || {}
  }

  get characteristicKey() {
    if (this.preData.options.characteristicToUse)
      return this.preData.options.characteristicToUse
    else
      return this.item.characteristic.key
  }
}

class SkillDialog extends CharacteristicDialog {

    subTemplate = "systems/wfrp4e/templates/dialog/skill-dialog.hbs";
    chatTemplate = "systems/wfrp4e/templates/chat/roll/skill-card.hbs"

    testClass = SkillTest

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["skill-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.skill
    }

    get skill() 
    {
      return this.data.skill;
    }

    static async setup(fields={}, data={}, options={})
    {
        let skill = data.skill;
        options.title = options.title || game.i18n.format("SkillTest", {skill: data.skill.name});
        options.title += options.appendTitle || "";

        if (data.skill.name == game.i18n.localize("NAME.Dodge"))    
        {
            options.dodge = true;
        }
        data.characteristic = skill.characteristic.key;
        data.hitLocationTable = game.wfrp4e.tables.getHitLocTable(data.targets[0]?.actor?.details?.hitLocationTable?.value || "hitloc");

        data.scripts = data.scripts.concat(data.skill?.getScripts("dialog"));

        return new Promise(resolve => {
            new this(fields, data, resolve, options).render(true);
        })
    }

    async getData() 
    {
        let context = await super.getData();
        context.data.hitLoc = ["ws", "bs"].includes(context.data.characteristic);
        return context;
    }

    _constructTestData()
    {
        let data = super._constructTestData();
        data.skillName = this.data.skill?.name;
        data.item = this.data.skill?.id;
        data.characteristicToUse = this.data.characteristic;
        return data;
    }

    computeFields()
    {
        super.computeFields();   
        this._computeArmour();
    }

    _computeArmour()
    {
        let stealthPenaltyValue = 0;

        // Armor type penalties do not stack, only apply if you wear any of that type
        let wearingMail = false;
        let wearingPlate = false;

        for (let a of this.actor.itemTypes["armour"].filter(i => i.isEquipped)) {
            // For each armor, apply its specific penalty value, as well as marking down whether
            // it qualifies for armor type penalties (wearingMail/Plate)

            // Skip practical
            if (a.properties.qualities.practical) {
                continue;
            }

            if (a.armorType.value == "mail") {
                wearingMail = true;
            }
            if (a.armorType.value == "plate") {
                wearingPlate = true;
            }
        }

        // Apply armor type penalties at the end
        if (wearingMail || wearingPlate) {
            if (wearingMail) {
                stealthPenaltyValue += -10;
            }
            if (wearingPlate) {
                stealthPenaltyValue += -10;
            }

            if (this.item.name.includes(game.i18n.localize("NAME.Stealth"))) {
                if (stealthPenaltyValue) {
                    this.fields.modifier += stealthPenaltyValue;
                    this.tooltips.addModifier(stealthPenaltyValue, game.i18n.localize("SHEET.ArmourPenalties"));
                }
            }
        }
    }

    activateListeners(html)
    {
        super.activateListeners(html);

        html.find(".change-characteristic").change(ev => {
            this.data.characteristic = ev.currentTarget.value;
            this.render(true);
        });
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "skill";
    }
}

class AttackTest extends TestWFRP {


  async computeResult() {
    await super.computeResult();

    this.computeProperties();

    await this.calculateDamage();

    return this.result;
  }

  computeProperties()
  {
    if (this.result.outcome == "failure") {
      // Dangerous weapons fumble on any failed tesst including a 9
      if (this.result.roll % 11 == 0 || this.result.roll == 100 || (this.item.properties.flaws.dangerous && this.result.roll.toString().includes("9"))) {
        this.result.fumble = game.i18n.localize("Fumble");
      }
      if (this.item.properties.flaws.unreliable)
        this.result.SL--;
      if (this.item.properties.qualities.practical)
        this.result.SL++;

      if (this.item.weaponGroup?.value == "throwing")
        this.result.scatter = game.i18n.localize("Scatter");

      if (this.item.properties.qualities.blast && !this.result.other.find(x=>x.indexOf(game.i18n.localize("Scatter")) > -1)) {
        this.result.other.push(`<a class='aoe-template' data-id="${this.item.id}" data-actor-id="${this.actor.id}" data-type="radius"><i class="fas fa-ruler-combined"></i>${this.item.properties.qualities.blast.value} metrw (${game.i18n.localize("Scatter")})</a>`);
      }
    }
    else // if success
    {
      if (this.item.properties.qualities.blast && !this.result.other.find(x=>x.indexOf(game.i18n.localize("Scatter")) > -1)) {
        this.result.other.push(`<a class='aoe-template' data-id="${this.item.id}" data-actor-id="${this.actor.id}" data-type="radius"><i class="fas fa-ruler-combined"></i>${this.item.properties.qualities.blast.value} metrw (${game.i18n.localize("Scatter")})</a>`);
      }

      if (this.result.roll % 11 == 0)
        this.result.critical = game.i18n.localize("Critical");

      // Impale weapons crit on 10s numbers
      if (this.item.properties.qualities.impale && this.result.roll % 10 == 0)
        this.result.critical = game.i18n.localize("Critical");

      if (this.result.critical && this.item.properties.qualities.slash)
      {
          this.result.other.push(`${game.i18n.format("PROPERTY.SlashAlert", {value : parseInt(this.item.properties.qualities.slash.value)})}`);
      }
    }
  }

  async calculateDamage(base)
  {
    this.result.additionalDamage = this.preData.additionalDamage || 0;

    let damageToUse = base; // Start out normally, with SL being the basis of damage
    if (this.useMount && this.actor.mount.characteristics.s.bonus > this.actor.characteristics.s.bonus)
      this.result.damage = (0, eval)(this.item.mountDamage + damageToUse);
    else
      this.result.damage = (0, eval)(this.item.Damage + damageToUse);

    if (this.result.charging && !this.result.other.includes(game.i18n.localize("Charging")))
      this.result.other.push(game.i18n.localize("Charging"));

    if ((this.item.properties.flaws.tiring && this.result.charging) || !this.item.properties.flaws.tiring) {
      let unitValue = Number(this.result.roll.toString().split("").pop());
      unitValue = unitValue == 0 ? 10 : unitValue; // If unit value == 0, use 10

      if (this.item.properties.qualities.damaging && unitValue > Number(this.result.SL))
        base = unitValue; // If damaging, instead use the unit value if it's higher

      if (this.useMount && this.actor.mount.characteristics.s.bonus > this.actor.characteristics.s.bonus)
        this.result.damage = (0, eval)(this.item.mountDamage + damageToUse);
      else
        this.result.damage = (0, eval)(this.item.Damage + damageToUse);

      // Add unit die value to damage if impact
      if (this.item.properties.qualities.impact)
        this.result.damage += unitValue;
    }

    if (this.item.properties.qualities.spread)
    {
      let value = (Number(this.item.properties.qualities.spread.value) || 0);
      if (this.preData.options.rangeBand == game.i18n.localize("Point Blank"))
      {
        this.result.additionalDamage += value;        
        this.result.damage += value;
        this.preData.other.push(game.i18n.format("CHAT.SpreadPointBlank", {damage : value}));
      }
      else if (this.preData.options.rangeBand == game.i18n.localize("Extreme"))
      {
        this.result.additionalDamage -= value;        
        this.result.damage -= value;
        this.preData.other.push(game.i18n.format("CHAT.SpreadExtreme", {damage : value}));
      }
    }
  }
}

class WeaponTest extends AttackTest {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return
    this.preData.ammoId = data.ammo?.id; // TODO vehicle shit
    this.preData.skillSelected = data.skillSelected || {};
    this.preData.charging = data.charging || false;
    this.preData.champion = data.champion || false;
    this.preData.riposte = data.riposte || false;
    this.preData.infighter = data.infighter || false;
    this.preData.resolute = data.resolute || 0;
    this.preData.dualWielding = data.dualWielding || false;

    this.computeTargetNumber();
    this.preData.skillSelected = data.skillSelected instanceof Item ? data.skillSelected.name : data.skillSelected;
  }

  computeTargetNumber() {
    let skill = this.item.skillToUse;
    if (!skill)
      this.result.target = this.actor.characteristics.ws.value;
    else
      this.result.target = skill.total.value;

    super.computeTargetNumber();
  }

  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preRollWeaponTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preRollWeaponTest", { test: this, chatOptions: this.context.chatOptions }));
  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollWeaponTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollWeaponTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollWeaponTest", this, this.context.chatOptions);
  }


  async roll() {

    if (this.options.offhand && this.options.offhandReverse)
      this.preData.roll = this.options.offhandReverse;

    await super.roll();
  }

  async computeResult()
  {
    await super.computeResult();
    this.computeMisfire();
  }


  async calculateDamage() {
    super.calculateDamage(this.result.SL);
    let weapon = this.weapon;

    if ((weapon.damage.dice || weapon.ammo?.damage.dice) && !this.result.additionalDamage) {
      let roll = await new Roll(weapon.damage.dice + `${weapon.ammo?.damage.dice ? "+" + weapon.ammo?.damage.dice : "" }`).roll();
      this.result.diceDamage = { value: roll.total, formula: roll.formula };
      this.preData.diceDamage = this.result.diceDamage;
      this.result.additionalDamage += roll.total;
      this.preData.additionalDamage  = this.result.additionalDamage;
    }

    //@HOUSE
    if (game.settings.get("wfrp4e", "mooRangedDamage"))
    {
      game.wfrp4e.utility.logHomebrew("mooRangedDamage");
      if (weapon.attackType == "ranged")
      {
        this.result.damage -= (Math.floor(this.targetModifiers / 10) || 0);
        if (this.result.damage < 0)
          this.result.damage = 0;
      }
    }
    //@/HOUSE
  }

  async postTest() {
    await super.postTest();

    let target = this.targets[0];
    if (target) {
      let impenetrable = false;
      let AP = target.status.armour[this.result.hitloc.result];
      for(let layer of AP.layers)
      {
        if (layer.impenetrable)
          impenetrable = true;
      }
      if (this.result.critical && impenetrable && this.result.roll % 2 != 0) {
        delete this.result.critical;
        this.result.nullcritical = `${game.i18n.localize("CHAT.CriticalsNullified")} (${game.i18n.localize("PROPERTY.Impenetrable")})`;
      }
    }

    await this.handleAmmo();
    await this.handleDualWielder();

  }

  async handleAmmo()
  {
    // Only subtract ammo on the first run, so not when edited, not when rerolled
    if (this.item.system.ammo && this.item.system.consumesAmmo.value && !this.context.edited && !this.context.reroll) {
      await this.item.system.ammo.update({ "system.quantity.value": this.item.system.ammo.quantity.value - 1 });
    }
    else if (this.preData.ammoId && this.item.system.consumesAmmo.value && !this.context.edited && !this.context.reroll) {
      let ammo = this.actor.items.get(this.preData.ammoId);
      await ammo.update({ "system.quantity.value": this.actor.items.get(this.preData.ammoId).quantity.value - 1 });
    }


    if (this.item.system.loading && !this.context.edited && !this.context.reroll) {
      this.item.system.loaded.amt--;
      if (this.item.system.loaded.amt <= 0) {
        this.item.system.loaded.amt = 0;
        this.item.system.loaded.value = false;

        let item = await this.item.system.update({ "system.loaded.amt": this.item.system.loaded.amt, "system.loaded.value": this.item.system.loaded.value });
        await this.actor.checkReloadExtendedTest(item);
      }
      else {
        await this.item.system.update({ "system.loaded.amt": this.item.system.loaded.amt });
      }
    }
  }

  async handleDualWielder() 
  {
    if (this.preData.dualWielding && !this.context.edited) {
      if (!this.actor.hasSystemEffect("dualwielder"))
        await this.actor.addSystemEffect("dualwielder");

      if (this.result.outcome == "success") {
        await this.actor.setFlag("wfrp4e", "offHandData", this);
      }
    }
  }

  computeMisfire() {
    let weapon = this.item.system;
    // Blackpowder/engineering/explosive weapons misfire on an even fumble
    if (this.result.fumble && 
      ["blackpowder", "engineering", "explosives"].includes(weapon.weaponGroup.value) && 
      this.result.roll % 2 == 0) 
    {
      this.result.misfire = game.i18n.localize("Misfire");
      this.result.misfireDamage = (0, eval)(parseInt(this.result.roll.toString().split('').pop()) + weapon.Damage);
    }
  }

  get weapon() {
    return this.item.system
  }

  get vehicle() {
    if (this.options.vehicle)
      return WFRP_Utility$1.getSpeaker(this.options.vehicle)
  }

  get characteristicKey() {
    if (this.preData.skillSelected.char)
      return this.preData.skillSelected.key

    else {
      let skill = this.actor.getItemTypes("skill").find(s => s.name == this.preData.skillSelected);
      if (skill)
        return skill.characteristic.key
    }
  }

  get item() {
    let actor = this.vehicle || this.actor;
    if (typeof this.preData.item == "string")
      return actor.items.get(this.preData.item)
    else
      return new CONFIG.Item.documentClass(this.preData.item, { parent: actor })
  }
}

class AttackDialog extends SkillDialog  
{
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["weapon-roll-dialog"]);
        return options;
    }

    get attackType() {
        return this.item.attackType;
    }


    computeFields()
    {
        super.computeFields();
        if (!["roll", "none"].includes(this.fields.hitLocation))
        {
            this.fields.modifier -= 20;
            this.tooltips.addModifier(-20, game.i18n.localize('ROLL.CalledShot'));
        }
    }

    _computeDefending(attacker) 
    {
        let properties = item.properties;

        if (this.actor.defensive) 
        {
            this.fields.slBonus += this.actor.defensive;
            this.tooltips.addSLBonus(this.actor.defensive, game.i18n.localize("PROPERTY.Defensive"));
        }

        //if attacker is fast, and the defender is either 1. using a melee trait to defend, or 2. using a weapon without fast
        if (attacker.test.item.properties?.qualities.fast && this.item.attackType == "melee" && !properties?.qualities.fast) 
        {
            this.fields.modifier += -10;
            this.tooltips.addModifier(-10, game.i18n.localize('CHAT.TestModifiers.FastWeapon'));
        }

        if (properties.flaws.unbalanced)
        {
            this.fields.slBonus -= 1;
            this.tooltips.addSLBonus(-1, game.i18n.localize("PROPERTY.Unbalanced"));
        }

        if(attacker.test.item.properties?.qualities?.wrap)
        {
            this.fields.slBonus -= 1;
            this.tooltips.addSLBonus(-1, game.i18n.localize('CHAT.TestModifiers.WrapDefend'));
        }

        //Size Differences
        let sizeDiff = game.wfrp4e.config.actorSizeNums[attacker.test.size] - this.sizeNum;
        //Positive means attacker is larger, negative means defender is larger
        if (sizeDiff >= 1) {
            //Defending against a larger target with a weapon
            if (this.item.attackType == "melee") {
                let slBonus = (-2 * sizeDiff);
                this.fields.slBonus += slBonus;
                this.tooltips.addSLBonus(slBonus, game.i18n.localize('CHAT.TestModifiers.DefendingLarger'));
            }
        }
    }

    _computeTargets(target)
    {
        let properties = item.properties;
        // Prefill dialog according to qualities/flaws
        if (properties.qualities.accurate) 
        {
            this.fields.modifier += 10;
            this.tooltips.addModifier(10, game.i18n.localize("PROPERTY.Accurate"));
        }

        if (properties.qualities.precise) 
        {
            this.fields.successBonus += 1;
            this.tooltips.addSuccessBonus(1, game.i18n.localize("PROPERTY.Precise"));

        }
        if (properties.flaws.imprecise) 
        {
            this.fields.slBonus -= 1;
            this.tooltips.addSLBonus(-1, game.i18n.localize("PROPERTY.Imprecise"));
        }

          
        if (this.item.attackType == "ranged" && target.actor.statuses.has("engaged"))
        {
            this.fields.modifier -= 20;
            this.tooltips.addModifier(-20, game.i18n.localize("EFFECT.ShootingAtEngagedTarget"));
            this.options.engagedModifier = -20;
        }


        let sizeDiff = this.actor.sizeNum - target.actor.sizeNum;
        let sizeModifier = 0;
        // Attacking a larger creature with melee
        if (sizeDiff < 0 && (this.item.attackType == "melee" || target.actor.sizeNum <= 3)) 
        {
          sizeModifier += 10;
          this.tooltips.addModifier(10, game.i18n.localize('CHAT.TestModifiers.AttackingLarger'));
        }
        // Attacking a larger creature with ranged
        else if (item.attackType == "ranged") 
        {
          if (target.actor.details.size.value == "tiny")
            sizeModifier -= 30;
          if (target.actor.details.size.value == "ltl")
            sizeModifier -= 20;
          if (target.actor.details.size.value == "sml")
            sizeModifier -= 10;
          if (target.actor.details.size.value == "lrg")
            sizeModifier += 20;
          if (target.actor.details.size.value == "enor")
            sizeModifier += 40;
          if (target.actor.details.size.value == "mnst")
            sizeModifier += 60;

          options.sizeModifier = sizeModifier;

          if (sizeModifier) 
          {
            const text = (game.i18n.format('CHAT.TestModifiers.ShootingSizeModifier', { size: game.wfrp4e.config.actorSizes[target.actor.details.size.value] }));
            this.tooltips.addModifier(sizeModifier, text);
          }
        }

        // Attacking a smaller creature from a mount
        if (this.actor.isMounted && this.item.attackType == "melee") 
        {
            let mountSizeDiff = this.actor.mount.sizeNum - target.actor.sizeNum;
            if (target.actor.isMounted) 
            {                               // TODO this seems wrong
                mountSizeDiff = this.actor.mount.sizeNum - target.actor.sizeNum;
            }

            if (mountSizeDiff >= 1) 
            {
                this.fields.modifier += 20;
                this.tooltips.addModifier(20, game.i18n.localize('CHAT.TestModifiers.AttackerMountLarger'));
            }
        }
        // Attacking a creature on a larger mount
        else if (this.item.attackType == "melee" && target.actor.isMounted) 
        {
            let mountSizeDiff = target.actor.mount.sizeNum - this.actor.sizeNum;
            if (this.actor.isMounted) 
            {
                mountSizeDiff = target.sizeNum - this.actor.mount.sizeNum;
            }
            if (mountSizeDiff >= 1) 
            {
                if ((this.item.reachNum || 0) >= 5) 
                {
                    // TODO this tooltip won't show up because 0 value
                    this.tooltips.addModifier(0, `${game.i18n.localize('CHAT.TestModifiers.IgnoreDefenderMountLarger')}`);
                }
                else 
                {
                    this.tooltips.addModifier(-10, game.i18n.localize('CHAT.TestModifiers.DefenderMountLarger'));
                    this.fields.modifier -= 10;
                }
            }
        }
    }
}

class WeaponDialog extends AttackDialog {


    subTemplate = "systems/wfrp4e/templates/dialog/weapon-dialog.hbs";
    chatTemplate = "systems/wfrp4e/templates/chat/roll/weapon-card.hbs"
    testClass = WeaponTest;


    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["weapon-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.data.weapon
    }

    get weapon() 
    {
      return this.item;
    }

    static async setup(fields={}, data={}, options={})
    {
        if (!data.weapon.id)
        {
            data.weapon = new CONFIG.Item.documentClass(data.weapon, { parent: data.actor });
        }
        let weapon = data.weapon;
        data.skill = weapon.skillToUse;
        data.characteristic = data.skill?.system.characteristic.key || (weapon.attackType == "ranged" ? "bs" : "ws");

        options.title = options.title || game.i18n.localize("WeaponTest") + " - " + weapon.name;
        options.title += options.appendTitle || "";

      if (weapon.attackType == "ranged") {
        // If Ranged, default to Ballistic Skill, but check to see if the actor has the specific skill for the weapon
        // skillCharList.push({ char: true, key: "bs", name: game.i18n.localize("CHAR.BS") })
        if (weapon.consumesAmmo.value && weapon.ammunitionGroup.value != "none" && weapon.ammunitionGroup.value) {
          // Check to see if they have ammo if appropriate
          if (options.ammo)
            data.ammo = options.ammo.find(a => a.id == weapon.currentAmmo.value);
          if (!data.ammo)
            data.ammo = data.actor.items.get(weapon.currentAmmo.value);
  
          if (!data.ammo || !weapon.currentAmmo.value || data.ammo.quantity.value == 0) {
            AudioHelper.play({ src: `${game.settings.get("wfrp4e", "soundPath")}no.wav` }, false);
            ui.notifications.error(game.i18n.localize("ErrorNoAmmo"));
            return
          }
  
        }
        else if (weapon.consumesAmmo.value && weapon.quantity.value == 0) {
          // If this executes, it means it uses its own quantity for ammo (e.g. throwing), which it has none of
          AudioPlayer.play({ src: `${game.settings.get("wfrp4e", "soundPath")}no.wav` }, false);
          ui.notifications.error(game.i18n.localize("ErrorNoAmmo"));
          return;
        }
        else {
          // If this executes, it means it uses its own quantity for ammo (e.g. throwing)
          data.ammo = weapon;
        }
  
  
        if (weapon.loading && !weapon.loaded.value) {
          await data.actor.rollReloadTest(weapon);
          ui.notifications.notify(game.i18n.localize("ErrorNotLoaded"));
          return ({ abort: true })
        }
      }

      if (weapon.attackType == "melee")
      {
        data.chargingOption = true;
      }

      data.dualWieldingOption = data.actor.showDualWielding(weapon);

      data.scripts = data.scripts.concat(data.weapon?.getScripts("dialog"), data.skill?.getScripts("dialog") || []);


      return new Promise(resolve => {
        new this(fields, data, resolve, options).render(true);
      })
  }

  _constructTestData()
  {
      let data = super._constructTestData();
      data.item = this.data.weapon.id || this.data.weapon.toObject();
      data.skillSelected = this.skill;
      return data;
  }

  computeFields() 
  {
    super.computeFields();

    if (this.item.offhand.value && !this.item.twohanded.value && !(this.item.weaponGroup.value == "parry" && this.item.properties.qualities.defensive)) 
    {
      this.fields.modifier += -20;
      this.tooltips.addModifier(-20, game.i18n.localize("SHEET.Offhand"));

      const ambiMod = Math.min(20, this.actor.flags.ambi * 10); // TODO could be handled by ambidextrous effect 
      this.fields.modifier += ambiMod;
      if (this.actor.flags.ambi) {
        tooltips.addModifier(ambiMod, game.i18n.localize("NAME.Ambi"));
      }
    }
  }

  _computeAdvantage()
  {
    if (this.fields.charging)
    {
      this.fields.advantage++;
    }
    super._computeAdvantage();
  }


  _computeTargets(target) 
  {
    this._computeRangeModifiers(target);
  }

  _computeRangeModifiers(target) 
  {
    let weapon = this.weapon;

    let token = this.actor.getActiveTokens()[0];

    if (!game.settings.get("wfrp4e", "rangeAutoCalculation") || !token || !weapon.range?.bands)
      return 0

    let distance = canvas.grid.measureDistances([{ ray: new Ray({ x: token.center.x, y: token.center.y }, { x: target.center.x, y: target.center.y }) }], { gridSpaces: true })[0];
    let currentBand;

    for (let band in weapon.range.bands) 
    {
      if (distance >= weapon.range.bands[band].range[0] && distance <= weapon.range.bands[band].range[1]) 
      {
        currentBand = band;
        this.options.rangeBand = band;
        break;
      }
    }

    let engagedEffect = this.actor.statuses.has("engaged");
    if (engagedEffect) 
    {
      let engagedMod = Math.min(0, weapon.range.bands[currentBand]?.modifier || 0);
      if (engagedMod)
      {
        this.fields.modifier += engagedMod;
        this.tooltips.addModifier(engagedMod, game.i18n.localize("EFFECT.ShooterEngaged"));
      }
    }
    else 
    {
      let rangeMod = weapon.range.bands[currentBand]?.modifier || 0;
      if (rangeMod) 
      {
        this.fields.modifier += rangeMod;
        this.tooltips.addModifier(rangeMod, `${game.i18n.localize("Range")} - ${currentBand}`);
      }
    }
  }

  // Backwards compatibility for effects
  get type() 
  {
    return "weapon";
  }
}

class CastDialog extends SkillDialog {

    subTemplate = "systems/wfrp4e/templates/dialog/spell-dialog.hbs";
    testClass = game.settings.get("wfrp4e", "useWoMOvercast") ? game.wfrp4e.rolls.WomCastTest : game.wfrp4e.rolls.CastTest
    chatTemplate = "systems/wfrp4e/templates/chat/roll/spell-card.hbs"

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["spell-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.data.spell
    }

    get spell() 
    {
      return this.item;
    }

    static async setup(fields={}, data={}, options={})
    {
        let spell = data.spell;
        options.title = options.title || game.i18n.localize("CastingTest") + " - " + spell.name;
        options.title += options.appendTitle || "";

        data.skill = spell.skillToUse;
        data.characteristic = data.skill?.system?.characteristic?.key || "int";

        data.scripts = data.scripts.concat(data.spell?.getScripts("dialog"), data.skill?.getScripts("dialog") || []);


        return new Promise(resolve => {
            new this(fields, data, resolve, options).render(true);
        })
    }

    _constructTestData()
    {
        let data = super._constructTestData();
        data.item = this.data.spell.id;
        data.skillSelected = this.skill;
        return data;
    }
    
    _computeAdvantage()
    {
        // @HOUSE
        if (game.settings.get("wfrp4e", "mooMagicAdvantage"))
        {
            return 0;
        }
        else 
        {
            return super._computeAdvantage();
        }
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "cast";
    }
}

class ChannelTest extends TestWFRP {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return

    this.preData.unofficialGrimoire = data.unofficialGrimoire;
    this.preData.skillSelected = data.skillSelected;
    this.data.preData.malignantInfluence = data.malignantInfluence;

    this.data.context.channelUntilSuccess = data.channelUntilSuccess;

    this.computeTargetNumber();
    this.preData.skillSelected = data.skillSelected instanceof Item ? data.skillSelected.name : data.skillSelected;
  }

  computeTargetNumber() {
    let skill = this.item.skillToUse;
    if (!skill)
      this.result.target = this.actor.characteristics.wp.value;
    else
      this.result.target = skill.total.value;

    super.computeTargetNumber();
  }

  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preChannellingTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preChannellingTest", { test: this, chatOptions: this.context.chatOptions }));

  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollChannellingTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollChannellingTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollChannelTest", this, this.context.chatOptions);
  }

  async computeResult() {
    await super.computeResult();
    let miscastCounter = 0;
    this.result.SL;
    this.result.tooltips.miscast = [];

    // Witchcraft automatically miscast
    if (this.item.lore.value == "witchcraft") {
      miscastCounter++;
      this.result.other.push(game.i18n.localize("CHAT.WitchcraftMiscast"));
      this.result.tooltips.miscast.push(game.i18n.localize("CHAT.AutoWitchcraftMiscast"));
    }

    // Test itself was failed
    if (this.result.outcome == "failure") 
    {
      this.result.description = game.i18n.localize("ROLL.ChannelFailed");
      // Major Miscast on fumble
      if (this.result.roll % 11 == 0 ||
         (this.result.roll % 10 == 0 && !game.settings.get("wfrp4e", "useWoMChannelling")) || // If WoM channelling, 10s don't cause miscasts
          this.result.roll == 100)
      {

        this.result.color_red = true;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.FumbleMiscast"));
        //@HOUSE
        if (this.preData.unofficialGrimoire) 
        {
          game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
          miscastCounter += 1;
          if(this.result.roll == 100 || this.result.roll == 99) 
          {
            this.item.cn.value * (-1);
            miscastCounter += 1;
          }
        //@HOUSE
        } 
        else 
        {
          if (game.settings.get("wfrp4e", "useWoMChannelling")) // Fumble is only minor when using WoM Channelling
          {
            miscastCounter += 1;
          }
          else 
          {
            miscastCounter += 2;
          }

          //@HOUSE
          if (this.result.roll == 100 && game.settings.get("wfrp4e", "mooCatastrophicMiscasts")) {
            game.wfrp4e.utility.logHomebrew("mooCatastrophicMiscasts");
            miscastCounter++;
          }
          //@/HOUSE
        }
      }
    }
    else // Successs - add SL to spell for further use
    {
      this.result.description = game.i18n.localize("ROLL.ChannelSuccess");

      // Critical Channel - miscast and set SL gained to CN
      if (this.result.roll % 11 == 0) {
        this.result.color_green = true;
        this.result.criticalchannell = game.i18n.localize("ROLL.CritChannel");
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.CritChannelMiscast"));
        miscastCounter++;
        this.spell.flags.criticalchannell = true; // Locally apply the critical channell flag
      }
    }

    miscastCounter += this._checkInfluences() || 0;
    this._handleMiscasts(miscastCounter);
    this.result.tooltips.miscast = this.result.tooltips.miscast.join("\n");
  }

  _checkInfluences()
  {
    if (!this.preData.malignantInfluence) 
    {
      return 0
    }

    // If malignant influence AND roll has an 8 in the ones digit, miscast
    if (
      (Number(this.result.roll.toString().split('').pop()) == 8 && !game.settings.get("wfrp4e", "useWoMInfluences")) || 
      (this.result.outcome == "failure" && game.settings.get("wfrp4e", "useWoMInfluences"))) 
    {
      this.result.tooltips.miscast.push(game.i18n.localize("CHAT.MalignantInfluence"));
      return 1;
    }
  }

  async postTest() {
    //@/HOUSE

    
      if (this.preData.unofficialGrimoire) {
        game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
        if (this.preData.unofficialGrimoire.ingredientMode != 'none' && this.hasIngredient && this.item.ingredient.quantity.value > 0 && !this.context.edited && !this.context.reroll) {
          await this.item.ingredient.update({ "system.quantity.value": this.item.ingredient.quantity.value - 1 });
          this.result.ingredientConsumed = true;
          ChatMessage.create({ speaker: this.data.context.speaker, content: game.i18n.localize("ConsumedIngredient") });
        }
        //@/HOUSE
      } 
      else if (game.settings.get("wfrp4e", "channellingIngredients"))
      {
        // Find ingredient being used, if any
        if (this.hasIngredient && this.item.ingredient.quantity.value > 0 && !this.context.edited && !this.context.reroll)
          await this.item.ingredient.update({ "system.quantity.value": this.item.ingredient.quantity.value - 1 });
      }

    let SL = Number(this.result.SL);

    if (this.result.outcome == "success")
    {
      // Optional Rule: If SL in extended test is -/+0, counts as -/+1
      if (Number(SL) == 0 && game.settings.get("wfrp4e", "extendedTests"))
        SL = 1;

      }
      else // If outcome == failure 
      {
        // Optional Rule: If SL in extended test is -/+0, counts as -/+1
        if (Number(SL) == 0 && game.settings.get("wfrp4e", "extendedTests"))
        SL = -1;
      }

    //@HOUSE
    if(this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.ingredientMode == 'power' && this.result.ingredientConsumed && this.result.outcome == "success") {
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
      SL = Number(SL) * 2;
    }
    //@HOUSE

    // Optional Rule: If SL in a channel attempt SL is negative, set SL to 0
    // This is tested after the previous rule so:
    // SL == 0 triggers previous rule and sets SL to -1, SL == -1 triggers this rule and sets SL 0
    // SL < 0 doesn't trigger previous rule, SL < 0 triggers this rule and sets SL 0 
    // In both cases SL resolves to 0 as expected by this rule.
    // "SL < 0" is used over "SL <= 0" since if previous rule isn't True SL 0 resolves no channel progress
    if (Number(SL) < 0 && game.settings.get("wfrp4e", "channelingNegativeSLTests"))
      SL = 0;

    // // If channelling test was edited, make sure to adjust the SL accordingly
    // if (this.context.previousResult?.previousChannellingSL > 0)
    // {
    //   channellDelta = SL - parseInt(this.context.previousResult.SL)
    // }

    

    //@HOUSE
    if(this.preData.unofficialGrimoire && (this.item.cn.SL + SL) > this.item.cn.value) {
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire-overchannelling");
      this.result.overchannelling = this.item.cn.SL + SL - this.item.cn.value;
    }
    //@HOUSE

    this.result.channelledSL = SL;

    if (game.settings.get("wfrp4e", "useWoMChannelling"))
    {
      if (this.result.criticalchannell)
      {
        this.result.channelledSL += this.actor.system.characteristics.wp.bonus;
      }
    }
    else 
    {

      if (this.result.criticalchannell)
      {
        this.result.channelledSL = this.item.cn.value;
      }
    }

    let SLdelta = this.result.channelledSL - (this.context.previousResult?.channelledSL || 0) + (this.context.previousResult?.pastSL || 0);

    if(SL > 0) {
      this.result.SL = "+" + SL;
    } else {
      this.result.SL = SL.toString();
    }

    let newSL = this.updateChannelledItems(SLdelta);   
    this.result.channelledDisplay = newSL.toString();
    if (!game.settings.get("wfrp4e", "useWoMChannelling"))
    {
      this.result.channelledDisplay += " / " + this.item.cn.value.toString();
    }

    if (this.result.miscastModifier) {
      if (this.result.minormis)
        this.result.minormis += ` (${this.result.miscastModifier})`;
      if (this.result.majormis)
        this.result.majormis += ` (${this.result.miscastModifier})`;
      if (this.result.catastrophicmis)
        this.result.catastrophicmis += ` (${this.result.miscastModifier})`;
    }
  }

  get hasIngredient() {

    // If channelling with ingredients isn't allowed, always return false 
    // HOWEVER: Witchcraft specifies: "channeling or casting spells from this Lore automatically require a roll on the Minor Miscast table unless cast with an ingredient"
    // This doesn't make any sense. So what I'm doing is if it's a witchcraft spell, and has a valid ingredient assigned, still count it, as it will have to be assumed it's used in the eventual cast?
    if (!game.settings.get("wfrp4e", "channellingIngredients") && this.item.lore.value != "witchcraft")
    {
      return false 
    }
    else 
    {
      return this.item.ingredient && this.item.ingredient.quantity.value > 0
    }
  }


  // Channelling should not show any effects to apply 
  get damageEffects() 
  {
      return [];
  }

  get targetEffects() 
  {
      return [];
  }

  get areaEffects() 
  {
      return [];
  }

  get spell() {
    return this.item
  }

  get characteristicKey() {
    if (this.preData.skillSelected.char)
      return this.preData.skillSelected.key

    else {
      let skill = this.actor.getItemTypes("skill").find(s => s.name == this.preData.skillSelected);
      if (skill)
        return skill.characteristic.key
    }
  }

  // WoM channelling updates all items of the lore channelled
  updateChannelledItems(slDelta)
  {
    let items = [this.item];
    if (game.settings.get("wfrp4e", "useWoMChannelling"))
    {
      items = this.actor.items.filter(s => s.type == "spell" && s.system.lore.value == this.spell.system.lore.value);
    }

    items = items.map(i => i.toObject());
    items.forEach(i => {
      i.system.cn.SL += slDelta;
      let computedCN = i.system.memorized.value ? i.system.cn.value : i.system.cn.value * 2;

      // THIS WHOLE PROCESS CAN GO TO HELL
      // Cap SL to CN if WoM channelling is disabled
      if (!game.settings.get("wfrp4e", "useWoMChannelling"))
      {
        this.result.pastSL = i.system.cn.SL - computedCN; // Needed to accurately account for edits and change in SL
        i.system.cn.SL = Math.min(computedCN, i.system.cn.SL);
      }
      if (i.system.cn.SL < 0)
      {
        this.result.pastSL = i.system.cn.SL;
      }
      i.system.cn.SL = Math.max(0, i.system.cn.SL); 
    });

    this.actor.updateEmbeddedDocuments("Item", items);
    return items[0].system.cn.SL
  }

}

class ChannellingDialog extends SkillDialog {

    subTemplate = "systems/wfrp4e/templates/dialog/channel-dialog.hbs";
    chatTemplate = "systems/wfrp4e/templates/chat/roll/channel-card.hbs"
    testClass = ChannelTest

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["channel-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.data.spell
    }

    get spell() 
    {
      return this.item;
    }

    static async setup(fields={}, data={}, options={})
    {
        let spell = data.spell;
        options.title = options.title || game.i18n.localize("ChannellingTest") + " - " + spell.name;
        options.title += options.appendTitle || "";

        if (spell.system.wind && spell.system.wind.value) 
        {
            data.skill = data.actor.itemTypes["skill"].find(i => i.name.toLowerCase() == spell.system.wind.value.toLowerCase());
        }
        else if (spell.system.lore.value == "witchcraft")
        {
            data.skill = data.actor.itemTypes["skill"].find(x => x.name.toLowerCase().includes(game.i18n.localize("NAME.Channelling").toLowerCase()));
        }
        else 
        {
            data.skill = data.actor.itemTypes["skill"].find(x => x.name.includes(game.wfrp4e.config.magicWind[spell.system.lore.value]));
        }
        data.characteristic = data.skill?.system.characteristic.key || "wp";

        data.scripts = data.scripts.concat(data.spell?.getScripts("dialog"), data.skill?.getScripts("dialog") || []);


        return new Promise(resolve => {
            new this(fields, data, resolve, options).render(true);
        })
    }

    _constructTestData()
    {
        let data = super._constructTestData();
        data.item = this.data.spell.id;
        data.skillSelected = this.skill;
        return data;
    }

    _computeAdvantage()
    {
        // @HOUSE
        if (game.settings.get("wfrp4e", "mooMagicAdvantage"))
        {
            return super._computeAdvantage();
        }
        else 
        {
            return 0;
        }
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "channelling";
    }
}

class TraitTest extends AttackTest {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return
    this.preData.charging = data.charging || false;
    this.preData.champion = data.champion || false;
    this.preData.options.characteristicToUse = data.characteristicToUse;
    this.computeTargetNumber();
  }

  computeTargetNumber() {

    try {
      // Use skill total if characteristics match, otherwise add the total up manually
      if (this.preData.options.characteristicToUse && this.preData.options.characteristicToUse != this.item.rollable.rollCharacteristic)
        this.result.target = this.actor.characteristics[this.preData.options.characteristicToUse].value;
      else
        this.result.target = this.actor.characteristics[this.item.rollable.rollCharacteristic].value;

      if (this.item.skillToUse)
        this.result.target += this.item.skillToUse.advances.value;
    }
    catch
    {
      this.result.target += this.item.skillToUse.advances.value;
    }

    super.computeTargetNumber();
  }
  
  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preRollTraitTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preRollTraitTest", { test: this, chatOptions: this.context.chatOptions }));
  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollTraitTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollTraitTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollTraitTest", this, this.context.chatOptions);
  }

  async calculateDamage() {
    try {
      // If the specification of a trait is a number, it's probably damage. (Animosity (Elves) - not a number specification: no damage)
      if (this.item.rollable.damage) {
        this.result.additionalDamage = this.preData.additionalDamage || 0;

        await super.calculateDamage(this.item.rollable.SL ? Number(this.result.SL) : 0);

        if (this.item.rollable.dice && !this.result.additionalDamage) {
          let roll = await new Roll(this.item.rollable.dice).roll();
          this.result.diceDamage = { value: roll.total, formula: roll.formula };
          this.preData.diceDamage = this.result.diceDamage;
          this.result.additionalDamage += roll.total;
          this.preData.additionalDamage  = this.result.additionalDamage;
        }

        //@HOUSE
        if (game.settings.get("wfrp4e", "mooRangedDamage"))
        {
          game.wfrp4e.utility.logHomebrew("mooRangedDamage");
          if (this.item.attackType == "ranged")
          {
            this.result.damage -= (Math.floor(this.targetModifiers / 10) || 0);
            if (this.result.damage < 0)
              this.result.damage = 0;
          }
        }
        //@/HOUSE

      }
    }
    catch (error) {
      ui.notifications.error(game.i18n.localize("CHAT.DamageError") + " " + error);
    } // If something went wrong calculating damage, do nothing and still render the card

  }

  get trait() {
    return this.item
  }

  async postTest() {
    await super.postTest();
  
    let target = this.targets[0];
    if (target) {
      let impenetrable = false;
      let AP = target.status.armour[this.result.hitloc.result];
      for (let layer of AP.layers) {
        if (layer.impenetrable) {
          impenetrable = true;
          break
        }
      }
      if (this.result.critical && impenetrable && this.result.roll % 2 != 0 && this.trait.system.rollable.damage) {
        delete this.result.critical;
        this.result.nullcritical = `${game.i18n.localize("CHAT.CriticalsNullified")} (${game.i18n.localize("PROPERTY.Impenetrable")})`;
      }
    }
  }

    get characteristicKey() {
    if (this.preData.options.characteristicToUse)
      return this.preData.options.characteristicToUse
    else
      return this.item.rollable.rollCharacteristic
  }
}

class TraitDialog extends AttackDialog {

    testClass = TraitTest
    chatTemplate = "systems/wfrp4e/templates/chat/roll/weapon-card.hbs"

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["trait-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.data.trait
    }

    get trait() 
    {
      return this.item;
    }

    static async setup(fields={}, data={}, options={})
    {
        if (!data.trait.id)
        {
            data.trait = new CONFIG.Item.documentClass(data.trait, { parent: this.actor});
        }
        let trait = data.trait;

        // TODO account for skill 
        options.title = options.title || game.wfrp4e.config.characteristics[trait.rollable.rollCharacteristic] + ` ${game.i18n.localize("Test")} - ` + trait.name;
        options.title += options.appendTitle || "";
  
      if (!trait.rollable.value)
      {
        return ui.notifications.notify("Non-rollable trait");
      }

      data.skill = data.actor.itemTypes["skill"].find(sk => sk.name == trait.rollable.skill);
      data.characteristic = data.skill?.system.characteristic.key || trait.rollable.rollCharacteristic;

      data.scripts = data.scripts.concat(data.trait?.getScripts("dialog"), data.skill?.getScripts("dialog") || []);


        return new Promise(resolve => {
            new this(fields, data, resolve, options).render(true);
        })
    }

    _constructTestData()
    {
        let data = super._constructTestData();
        data.item = this.data.trait.id;
        data.characteristicToUse = this.data.characteristic;
        return data;
    }
  
    

    _defaultDifficulty()
    {
        return this.item.rollable.defaultDifficulty || super._defaultDifficulty()
    }

    // Backwards compatibility for effects
    get type() 
    {
      return "trait";
    }
}

class PrayerTest extends TestWFRP {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return
    this.preData.skillSelected = data.skillSelected;
    this.computeTargetNumber();
    this.preData.skillSelected = data.skillSelected instanceof Item ? data.skillSelected.name : data.skillSelected;

  }

  computeTargetNumber() {
    let skill = this.item.skillToUse;
    if (!skill)
      this.result.target = this.actor.characteristics.fel.value;
    else
      this.result.target = skill.total.value;

    super.computeTargetNumber();
  }

  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preRollPrayerTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preRollPrayerTest", { test: this, chatOptions: this.context.chatOptions }));
  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollPrayerTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollPrayerTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollPrayerTest", this, this.context.chatOptions);
  }

  async computeResult() {
    await super.computeResult();
    let SL = this.result.SL;
    let currentSin = this.actor.status.sin.value;
    this.result.overcast = duplicate(this.item.overcast);

    // Test itself failed
    if (this.result.outcome == "failure") {
      this.result.description = game.i18n.localize("ROLL.PrayRefused");

      // Wrath of the gads activates if ones digit is equal or less than current sin
      let unitResult = Number(this.result.roll.toString().split('').pop());
      if (unitResult == 0)
        unitResult = 10;
      if (this.result.roll % 11 == 0 || unitResult <= currentSin) {
        if (this.result.roll % 11 == 0)
          this.result.color_red = true;

        this.result.wrath = game.i18n.localize("ROLL.Wrath");
        this.result.wrathModifier = Number(currentSin) * 10;
      }
    }
    // Test succeeded
    else {
      this.result.description = game.i18n.localize("ROLL.PrayGranted");

      // Wrath of the gads activates if ones digit is equal or less than current sin      
      let unitResult = Number(this.result.roll.toString().split('').pop());
      if (unitResult == 0)
        unitResult = 10;
      if (unitResult <= currentSin) {
        this.result.wrath = game.i18n.localize("ROLL.Wrath");
        this.result.wrathModifier = Number(currentSin) * 10;
      }
    }

    this.result.overcasts = Math.max(0, Math.floor(SL / 2)); // For allocatable buttons
    this.result.overcast.total = this.result.overcasts;
    this.result.overcast.available = this.result.overcast.total;

    await this.calculateDamage();
  }


  async calculateDamage() {
    this.result.additionalDamage = this.preData.additionalDamage || 0;
    // Calculate damage if prayer specifies
    try {
      if (this.item.DamageString && this.result.outcome == "success")
        this.result.damage = Number(this.item.Damage);
      if (this.item.damage.addSL)
        this.result.damage = Number(this.result.SL) + (this.result.damage || 0);

      if (this.item.damage.dice && !this.result.additionalDamage) {
        let roll = await new Roll(this.item.damage.dice).roll();
        this.result.diceDamage = { value: roll.total, formula: roll.formula };
        this.preData.diceDamage = this.result.diceDamage;
        this.result.additionalDamage += roll.total;
        this.preData.additionalDamage = this.result.additionalDamage;
      }
    }
    catch (error) {
      ui.notifications.error(game.i18n.localize("ErrorDamageCalc") + ": " + error);
    } // If something went wrong calculating damage, do nothing and still render the card
  }

  async postTest() {
    if (this.result.wrath) {
      let sin = this.actor.status.sin.value - 1;
      if (sin < 0) sin = 0;
      this.actor.update({ "system.status.sin.value": sin });
      ui.notifications.notify(game.i18n.localize("SinReduced"));
    }
  }

  
  // @@@@@@@ Overcast functions placed in root class because it is used by both spells and prayers @@@@@@@
  async _overcast(choice) {
    if (this.result.overcast.usage[choice].AoE) {
      ui.notifications.error(game.i18n.localize("ERROR.PrayerAoEOvercast"));
    } else {
      await super._overcast(choice);
    }
  }

  get prayer() {
    return this.item
  }

  get characteristicKey() {
    if (this.preData.skillSelected.char)
      return this.preData.skillSelected.key

    else {
      let skill = this.actor.getItemTypes("skill").find(s => s.name == this.preData.skillSelected);
      if (skill)
        return skill.characteristic.key
    }
  }
}

class PrayerDialog extends SkillDialog {

    testClass = PrayerTest
    subTemplate = ""
    chatTemplate = "systems/wfrp4e/templates/chat/roll/prayer-card.hbs"

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["prayer-roll-dialog"]);
        return options;
    }

    get item()
    {
      return this.data.prayer
    }

    get prayer() 
    {
      return this.item;
    }

    static async setup(fields={}, data={}, options={})
    {
        let prayer = data.prayer;
        options.title = options.title || game.i18n.localize("PrayerTest") + " - " + prayer.name;
        options.title += options.appendTitle || "";

        data.skill = data.actor.itemTypes["skill"].find(i => i.name.toLowerCase() == game.i18n.localize("NAME.Pray").toLowerCase());
        data.characteristic = data.skill?.system.characteristic.key || "fel";

        data.scripts = data.scripts.concat(data.prayer?.getScripts("dialog"), data.skill?.getScripts("dialog") || []);


        return new Promise(resolve => {
            new this(fields, data, resolve, options).render(true);
        })
    }

    _constructTestData()
    {
        let data = super._constructTestData();
        data.item = this.data.prayer.id;
        data.skillSelected = this.skill;
        return data;
    }

    // Backwards compatibility for effects
    get type() 
    {
        return "prayer";
    }
}

class ItemDialog extends Dialog {

    constructor(data)
    {
        super(data);
        this.chosen = 0;
    }

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.resizable = true;
        options.classes.push("item-dialog");
        return options;
    }

    static async create(items, count = 1, text)
    {

        if (typeof items == "object" && !Array.isArray(items) && !(items instanceof Collection))
        {
            items = this.objectToArray(items);
        }

        if (count == 0 || items.length == 0)
        {
            return [];
        }
        else if (items.length == 1)
        {
            return items;
        }

        let html = await renderTemplate("systems/wfrp4e/templates/apps/item-dialog.hbs", {items, count, text});
        return new Promise((resolve) => {
            new ItemDialog({
                title : "Item Dialog",
                content : html,
                system : {items, count, text},
                buttons : {
                    submit : {
                        label : "Submit",
                        callback: (html) => {
                            resolve(Array.from(html.find(".active")).map(element => items[element.dataset.index]));
                        }
                    }                
                }
            }).render(true);
        })
    }

    static async createFromFilters(filters, count, text, items)
    {
        items = await ItemDialog.filterItems(filters, items);
        return new Promise(async (resolve, reject) => {
            let choice = await ItemDialog.create(items, count, text);    
            if (choice.length == 0)
                reject(ui.notifications.error(game.i18n.localize("DIALOG.ErrorMustSelectItem")));
            else 
                resolve(choice);
        })
    }

    
    // simulate document structure with key as the ID and the value as the name
    static objectToArray(object)
    {
        return Object.keys(foundry.utils.deepClone(object)).map(key => 
        {
            return {
                id : key,
                name : object[key]
            };
        });

    }

    async getData() {
        let data = super.getData();
        return data;
    }

    static async filterItems(filters=[], items)
    {
        if (!items)
        {
            items = game.items.contents;
            
            for (let p of game.packs) {
                if (p.metadata.type == "Item") {
                    items = items.concat((await p.getDocuments()).filter(i => !items.find(existing => existing.id == i.id)));
                }
            }
        }

        for (let f of filters)
        {
            if (f.regex)
            {
                items = items.filter(i => Array.from(getProperty(i, f.property).matchAll(f.value)).length);
            }
            else 
            {
                let value = f.value;
                if (!Array.isArray(value))
                {
                    value = [value];
                }
                items = items.filter(i => value.includes(getProperty(i, f.property)));
            }
        }

        return items.sort((a, b) => a.name > b.name ? 1 : -1)
    }


    activateListeners(html) {
        super.activateListeners(html);
        html.find(".document-name").click(ev => {


            let document = $(ev.currentTarget).parents(".document")[0];
            if (document.classList.contains("active"))
            {
                document.classList.remove("active");
                this.chosen--;
            }
            else if (this.data.system.count == "unlimited" || (this.data.system.count - this.chosen > 0)) {
                document.classList.add("active");
                this.chosen++;
            } 

        });

        html.find(".document-name").contextmenu(ev => {
            let document = $(ev.currentTarget).parents(".document");
            let id = document.attr("data-id");

            game.items.get(id).sheet.render(true, {editable: false});
        });
    }
}

class WFRP4eScript
{
    constructor(data, context={})
    {
        this.script = data.script;
        this.label = data.label;
        this.trigger = data.trigger;
        this.options = data.options;
        this.async = this.trigger ? !game.wfrp4e.config.syncTriggers.includes(this.trigger) : false;
        this.context = context;
        this.context.script = this;
    }

    execute(args)
    {
        try 
        {
            let scriptFunction = this.async ? Object.getPrototypeOf(async function () { }).constructor : Function;
            game.wfrp4e.utility.log("Running Script > " + this.label);
            return (new scriptFunction("args",`${CONFIG.debug.scripts ? "debugger;" : ""}` + this.script)).bind(this.context)(args);
        }
        catch(e)
        {
            console.error(`Script ${this.label} threw error: ${e}.\n Context and Arguments:`, this.context, args);
        }
    }


    // Dialog modifiers only
    hidden(args)
    {
        if (!this.options.dialog?.hideScript)
        {
            return false; // Default to not hidden if no script
        }
        else 
        {
            try 
            {
                return this._runSubscript(args, this.options.dialog?.hideScript, "Hide");
            }
            catch(e)
            {
                return false; // Default to not hidden if error
            }
        }
    }

    // Dialog modifiers only
    activated(args)
    {
        if (!this.options.dialog?.activateScript)
        {
            return false; // Default to not activated if no script
        }
        else 
        {
            try 
            {
                return this._runSubscript(args, this.options.dialog?.activateScript, "Activate");
            }
            catch(e)
            {
                return false; // Default to not activated if error
            }
        }
    }

    // Dialog modifiers only
    submission(args)
    {
        if (this.options.dialog?.submissionScript)
        {
            return this._runSubscript(args, this.options.dialog?.submissionScript, "Submission");
        }
    }

    _runSubscript(args, script, name)
    {
        try 
        {
            game.wfrp4e.utility.log("Running Script > " + this.label);
            return new Function("args",`${CONFIG.debug.scripts ? "debugger;" : ""}` + script).bind(this.context)(args);
        }
        catch(e)
        {
            console.error(`${name} Subscript ${this.label} threw error: ${e}.\n Context and Arguments:`, this.context, args);
            throw e;
        }
    }

    scriptMessage(content, chatData={})
    {
        ChatMessage.create(mergeObject({
            content,
            speaker : {alias : this.context.actor?.name || this.context?.item.name},
            flavor : this.context.effect.name || this.context.item.name || ""
        }, chatData));
    }

    scriptNotification(content, type="info")
    {
        ui.notifications.notify(`<strong>${this.context.effect.name}: ${content}</strong>`, type);
    }

    get actor() 
    {
        return this.context.actor;
    }
    
    get item() 
    {
        return this.context.item;
    }

    get effect()
    {
        return this.context.effect;
    }

    static createContext(document)
    {
        let context = {};
        if (document.documentName == "ActiveEffect")
        {
            context.actor = document.actor;
            context.item = document.item;
            context.effect = document;
        }

        if (document.documentName == "Item")
        {
            context.actor = document.actor;
            context.item = document;
        }

        return context;
    }
}

class EffectWfrp4e extends ActiveEffect
{

    constructor(data, context)
    {
        _migrateEffect(data);
        super(data, context);

    }


    async _preCreate(data, options, user)
    {
        await super._preCreate(data, options, user);

        // Take a copy of the test result that this effect comes from, if any
        // We can't use simply take a reference to the message id and retrieve the test as
        // creating a Test object before actors are ready (scripts can execute before that) throws errors
        this.updateSource({"flags.wfrp4e.sourceTest" : game.messages.get(options.message)?.getTest()});

        let preventCreation = false;
        preventCreation = await this._handleEffectPrevention(data, options, user);
        if (preventCreation)
        {
            ui.notifications.notify(game.i18n.format("EFFECT.EffectPrevented", {name : this.name}));
            return false; // If avoided is true, return false to stop creation
        }
        preventCreation = await this._handleFilter(data, options, user);
        if (preventCreation)
        {
            game.wfrp4e.utility.log(game.i18n.format("EFFECT.EffectFiltered", {name : this.name}), true, this);
            return false;
        }
        preventCreation = await this._handleConditionCreation(data, options, user);
        if (preventCreation)
        {
            return false;
        }
        await this._handleItemApplication(data, options, user);

        return await this.handleImmediateScripts(data, options, user);
    }

    async _onDelete(options, user)
    {
        await super._onDelete(options, user);
        await this.deleteCreatedItems();
        for(let script of this.scripts.filter(i => i.trigger == "deleteEffect"))
        {
            await script.execute({options, user});
        }
    }

    async _onUpdate(data, options, user)
    {
        await super._onUpdate(data, options, user);

        // If an owned effect is updated, run parent update scripts
        if (this.parent)
        {
            await Promise.all(this.parent.runScripts("updateDocument", {data, options, user}));
        }
    }

    async _onCreate(data, options, user)
    {
        await super._onCreate(data, options, user);

        // If an owned effect is created, run parent update scripts
        if (this.parent)
        {
            await Promise.all(this.parent.runScripts("updateDocument", {data, options, user}));
        }
    }

    //#region Creation Handling

    async handleImmediateScripts(data, options, user)
    {

        let scripts = this.scripts.filter(i => i.trigger == "immediate");
        if (scripts.length == 0)
        {
            return true;
        }

        let run = false;
        // Effect is direct parent, it's always applied to an actor, so run scripts
        if (this.parent?.documentName == "Actor")
        {
            run = true;
        }
        // If effect is grandchild, only run scripts if the effect should apply to the actor
        else if (this.parent?.documentName == "Item" && this.parent?.parent?.documentName == "Actor" && this.transfer)
        {
            run = true;
        }
        // If effect is child of Item, and Item is what it's applying to
        else if (this.parent?.documentName == "Item" && this.applicationData.documentType == "Item")
        {
            run = true;
        }

        if (run)
        {
            if (scripts.length)
            {
                await Promise.all(scripts.map(s => s.execute({data, options, user})));
                return !this.scripts.every(s => s.options.immediate?.deleteEffect);
                // If all scripts agree to delete the effect, return false (to prevent creation);
            }
        }
    }

    async _handleEffectPrevention()
    {
        if (this.applicationData.avoidTest.prevention)
        {
            return this.resistEffect();
        }
    }
    
    /** 
     * This function handles creation of new conditions on an actor
     * If an Item adds a Condition, prevent that condition from being added, and instead call `addCondition` 
     * This prevents the Condition from being removed when the item is removed, but more importantly
     * `addCondition` handles Minor conditions turning into Major if a second Minor is added.
     */
    async _handleConditionCreation(data, options)
    {
        // options.condition tells us that it has already gone through addCondition, so this avoids a loop
        if (this.isCondition && !options.condition) 
        {
            // If adding a condition, prevent it and go through `addCondition`      // TODO handle these options
            this.parent?.addCondition(this.key, this.conditionValue, {origin: this.origin, flags : this.flags});
            return true;
        }
    }

    /**
     * There is a need to support applying effects TO items, but I don't like the idea of actually
     * adding the document to the item, as it would not work with duration handling modules and 
     * would need a workaround to show the icon on a Token. Instead, when an Item type Active Effect
     * is applied, keep it on the actor, but keep a reference to the item(s) being modified (if none, modify all)
     * 
     */
    async _handleItemApplication()
    {
        let applicationData = this.applicationData;
        if (applicationData.documentType == "Item" && this.parent?.documentName == "Actor")
        {
            let items = [];
            let filter = this.filterScript;

            // If this effect specifies a filter, narrow down the items according to it
            // TODO this filter only happens on creation, so it won't apply to items added later
            if (filter)
            {
                items = this.parent.items.contents.filter(i => filter.execute(i)); // Ids of items being affected. If empty, affect all
            }

            // If this effect specifies a prompt, create an item dialog prompt to select the items
            if (applicationData.prompt)
            {
                items = await ItemDialog.create(items, "unlimited");
            }


            this.updateSource({"flags.wfrp4e.itemTargets" : items.map(i => i.id)});
        }
    }

    async _handleFilter()
    {
        let applicationData = this.applicationData;
        let filter = this.filterScript;
        if (!filter)
        {
            return;
        }

        if (applicationData.documentType == "Item" && this.parent?.documentName == "Actor")
        {
            return; // See above, _handleItemApplication
        }


        if (this.parent)
        {
            return filter.execute(this.parent);
        }
    }

//TODO: CHECK WHAT WE CAN DO - THIS IS TEST TO AVOID SCRIPT TO RUN.
    async resistEffect()
    {
        let actor = this.actor;

        // If no owning actor, no test can be done
        if (!actor)
        {
            return false;
        }

        let applicationData = this.applicationData;

        // If no test, cannot be avoided
        if (applicationData.avoidTest.value == "none")
        {
            return false;
        }

        let test;
        let options = {appendTitle : " - " + this.name};
        if (applicationData.avoidTest.value == "script")
        {
            let script = new WFRP4eScript({label : this.effect + " Avoidance", string : applicationData.avoidTest.script}, WFRP4eScript.createContext(this));
            return await script.execute();
        }
        else if (applicationData.avoidTest.value == "custom")
        {
            options = {};
            if (applicationData.avoidTest.skill)
            {
                options.difficulty = applicationData.avoidTest.difficulty;
                options.characteristic = applicationData.avoidTest.characteristic;
                test = await this.actor.setupSkill(applicationData.avoidTest.skill, options);
            }
            else if (applicationData.avoidTest.characteristic)
            {
                options.difficulty = applicationData.avoidTest.difficulty;
                test = await this.actor.setupCharacteristic(applicationData.avoidTest.characteristic, options);
            }
        }

        await test.roll();

        if (!applicationData.avoidTest.reversed)
        {
            // If the avoid test is marked as opposed, it has to win, not just succeed
            if (applicationData.avoidTest.opposed && this.getFlag("wfrp4e", "sourceTest"))
            {
                return test.result.SL > this.getFlag("wfrp4e", "sourceTest").result?.SL;
            }
            else 
            {
                return test.succeeded;
            }
        }
        else  // Reversed - Failure removes the effect
        {
            // If the avoid test is marked as opposed, it has to win, not just succeed
            if (applicationData.avoidTest.opposed && this.getFlag("wfrp4e", "sourceTest"))
            {
                return test.result.SL < this.getFlag("wfrp4e", "sourceTest").result?.SL;
            }
            else 
            {
                return !test.succeeded;
            }
        }
    }

    /**
     * Delete all items created by scripts in this effect
     */
    deleteCreatedItems()
    {
        if (this.actor)
        {
            let createdItems = this.actor.items.filter(i => i.getFlag("wfrp4e", "fromEffect"), this.id);
            if (createdItems.length)
            {
                ui.notifications.notify(game.i18n.format("EFFECT.DeletingEffectItems", {items : createdItems.map(i => i.name).join(", ")}));
                return this.actor.deleteEmbeddedDocuments("Item", createdItems.map(i => i.id));
            }
        }
    }

    //#endregion

    prepareData() 
    {
        super.prepareData();

        if (this.applicationData.enableConditionScript && this.actor)
        {
            this.conditionScript = new WFRP4eScript({string : this.applicationData.enableConditionScript, label : `Enable Script for ${this.name}`}, WFRP4eScript.createContext(this));
            this.disabled = !this.conditionScript.execute();
        }

        // Refresh scripts
        this._scripts = undefined;

        if (this.parent?.documentName == "Item")
        {
            this.transfer = this.determineTransfer();
        }
    }

    determineTransfer()
    {
        let application = this.applicationData;

        let allowed = (application.type == "document" && application.documentType == "Actor");

        if (this.parent.documentName == "Item")
        {
            allowed = allowed && this.item.system.shouldTransferEffect(this);
        }
        
        return allowed;
    }

    // To be applied, some data needs to be changed
    // Convert type to document, as applying should always affect the document being applied
    // Set the origin as the actor's uuid
    // convert name to status so it shows up on the token
    convertToApplied(test)
    {
        let effect = this.toObject();

        // An applied targeted aura should stay as an aura type, but it is no longer targeted
        if (effect.flags.wfrp4e.applicationData.type == "aura" && effect.flags.wfrp4e.applicationData.targetedAura)
        {
            effect.flags.wfrp4e.applicationData.targetedAura = false;
        }
        else 
        {
            effect.flags.wfrp4e.applicationData.type = "document";
        }
        effect.origin = this.actor?.uuid;
        effect.statuses = [this.key || effect.name.slugify()];
    
        let item = test?.item;

        let duration;
        if (test && test.result.overcast && test.result.overcast.usage.duration) {
            duration = test.result.overcast.usage.duration.current;
        } else if(item?.Duration) {
            duration = parseInt(item.Duration);
        }
    
        if (duration) {
            if (item.duration.value.toLowerCase().includes(game.i18n.localize("Seconds")))
            effect.duration.seconds = duration;
    
            else if (item.duration.value.toLowerCase().includes(game.i18n.localize("Minutes")))
            effect.duration.seconds = duration * 60;
    
            else if (item.duration.value.toLowerCase().includes(game.i18n.localize("Hours")))
            effect.duration.seconds = duration * 60 * 60;
    
            else if (item.duration.value.toLowerCase().includes(game.i18n.localize("Days")))
            effect.duration.seconds = duration * 60 * 60 * 24;
    
            else if (item.duration.value.toLowerCase().includes(game.i18n.localize("Rounds")))
            effect.duration.rounds = duration;
        }

        // When transferred to another actor, effects lose their reference to the item it was in
        // So if a effect pulls its avoid test from the item data, it can't, so place it manually
        // TODO: Don't think this is needed
        // if (this.applicationData.avoidTest.value == "item")
        // {
        //     effect.flags.wfrp4e.applicationData.avoidTest.value = "custom";
        //     mergeObject(effect.flags.wfrp4e.applicationData.avoidTest, this.item?.getTestData() || {});
        // }

        return effect;
    }

    get scripts()
    {  
        if (!this._scripts)
        {
            this._scripts = this.scriptData.map(i => new WFRP4eScript(i, WFRP4eScript.createContext(this)));
        }
        return this._scripts;
    }

    get manualScripts()
    {
        return this.scripts.filter(i => i.trigger == "manual");
    }

    get filterScript()
    {
        if (this.applicationData.filter)
        {
            try 
            {
                return new WFRP4eScript({script : this.applicationData.filter, label : `${this.name} Filter`}, WFRP4eScript.createContext(this));
            }
            catch(e)
            {
                console.error("Error creating filter script: " + e);
                return null;
            }
        }
        else { return null; }
    }

    get item()
    {
        if (this.parent?.documentName == "Item")
        {
            return this.parent;
        }
        else
        {
            return undefined;
        }
    }

    get originDocument() 
    {
        return fromUuidSync(this.origin);
    }

    get actor()
    {
        if (this.parent?.documentName == "Item")
        {
            return this.parent.parent;
        }
        else if (this.parent?.documentName == "Actor")
        {
            return this.parent;
        }
        else 
        {
            return undefined;
        }
    }

    get source()
    {
        if (this.parent?.documentName == "Item")
        {
            return this.parent.name;
        }
        else
        {
            return super.sourceName; // TODO Handle diseases like v1 sourceName getter?
        }
    }

    get scriptData() 
    {
        return this.flags?.wfrp4e?.scriptData || [];

        /**
         * label
         * string
         * trigger
         */
    }

    get key () 
    {
        return Array.from(this.statuses)[0];
    }

    get show() {
        if (game.user.isGM || !this.getFlag("wfrp4e", "hide"))
          return true
        else 
          return false
      }

    get displayLabel() {
        if (this.count > 1)
            return this.name + ` (${this.count})`
        else return this.name
    }

    // TODO: this should be used more in scripts, search for replacements
    get specifier() {
        return this.name.substring(this.name.indexOf("(") + 1, this.name.indexOf(")"))
    }

    get isCondition() 
    {
        return !!game.wfrp4e.config.conditions[this.key];
    }

    get conditionId(){
        return this.key
    }

    get isNumberedCondition() {
        return Number.isNumeric(this.conditionValue)
    }

    get conditionValue() 
    {
        return this.getFlag("wfrp4e", "value");
    }

    // Computed effects mean flagged to know that they came from a calculation, notably encumbrance causing overburdened or restrained
    get isComputed()
    {
        return this.getFlag("wfrp4e", "computed");
    }

    get sourceTest() 
    {
        return this.getFlag("wfrp4e", "sourceTest");
    }

    get sourceActor() 
    {
        return ChatMessage.getSpeakerActor(this.sourceTest.context.speaker);
    }

    //TODO: AURA RADIUS - HOW TO MAKE THIS SHOWING AN AUTOMATED ANIMATION?
    async computeAuraRadius()
    {
        return (await new Roll(this.applicationData.radius, {effect : this, actor : this.actor, item : this.item}).roll()).total;
    }

    get applicationData() 
    {
        let applicationData = mergeObject(this.constructor._defaultApplicationData(), this.getFlag("wfrp4e", "applicationData"));

        // // Delete non-relevant properties based on application type
        // if (applicationData.type == "document")
        // {
        //     delete applicationData.avoidTest;
        //     delete applicationData.filters;
        //     delete applicationData.prompt;
        //     delete applicationData.consume;
        // }

        // if (applicationData.type == "damage")
        // {
        //     delete applicationData.avoidTest;

        //     if (applicationData.documentType == "Actor")
        //     {
        //         delete applicationData.filters;
        //         delete applicationData.prompt;
        //     }

        //     delete applicationData.consume;
        // }

        return applicationData;
    }

    static getCreateData(effectData, overlay=false)
    {
        const createData = foundry.utils.deepClone(effectData);
        if ( overlay ) 
        {
            createData.flags = {core : {overlay : true}};
        }
        if (!createData.duration)
        {
            createData.duration = {};
        }
        delete createData.id;
        return createData;
    }



    // I feel like "application" should be renamed to "transfer"
    static _defaultApplicationData() 
    {
        return {
            type : "document",
            documentType : "Actor",

            // Test Properties
            avoidTest : { 
                value : "none",
                opposed : false,
                prevention : true,
                reversed : false,
                manual : false,
                script : "",
                difficulty : "",
                characteristic : "",
                skill : ""
            },

            // Other

            keep : false, // Area/Aura - should they keep the effect when leaving
            radius : null, // Area/Aura radius, if null, inherit from item

            areaType : "instantaneous", // Area - "instantaneous" or "sustained"

            targetedAura : false, // Aura - if the aura should be applied to a target and not self


            equipTransfer : true,
            enableConditionScript : "",
            filter : "",
            prompt : false,
        };
    }

    static _defaultDialogOptions() 
    {
        return {
            targeter : false,
            hideScript : "",
            activateScript : "",
            submissionScript : ""
        };
    }

    static _defaultImmediateOptions() 
    {
        return {
            deleteEffect : false
        };
    }

    static _triggerMigrations(trigger)
    {
        let migrations = {
            "invoke" : "manual",
            "oneTime" : "immediate",
            "addItems" : "immediate",
            "dialogChoice" : "dialogChoice",
            "prefillDialog" : "dialog",
            "targetPrefillDialog" : "dialog"
        };
        return migrations[trigger] || trigger;
    }
}


function _migrateEffect(data, context)
{
    let flags = getProperty(data, "flags.wfrp4e");

    if (!flags || flags._legacyData || flags.scriptData)
    {
        return;
    }


    flags.applicationData = {};
    flags.scriptData = [];
    let newScript = {
        label : data.name,
        trigger : _triggerMigrations(flags.effectTrigger),
    };

    if (flags.effectTrigger == "targetPrefillDialog")
    {
        setProperty(newScript, "options.dialog.targeter", true);
    }

    if (flags.script)
    {
        // Previously scripts could reference the source test with a janky {{path}} statement
        // Now, all scripts have a `this.effect` reference, which has a `sourceTest` getter
        let script = flags.script;
        let regex = /{{(.+?)}}/g;
        let matches = [...script.matchAll(regex)];
        matches.forEach(match => {
            script = script.replace(match[0], `this.effect.sourceTest.data.result.${match[1]}`);
        });
        newScript.script = script;

        
        if (flags.effectTrigger == "prefillDialog")
        {
            // Old prefill triggers always ran for every dialog with conditional logic inside to add modifiers or not
            // To reflect that, migrated prefill tiggers need to always be active in the dialog
            setProperty(newScript, "options.dialog.activateScript", "return true");
        }

    }
    else if (flags.effectTrigger == "dialogChoice")
    {
        newScript.label = flags.effectData.description || newScript.label;
        newScript = `
        args.prefillModifiers.modifier += ${flags.effectData.modifier || 0};
        args.prefillModifiers.slBonus += ${flags.effectData.SLBonus || 0};
        args.prefillModifiers.successBonus += ${flags.effectData.successBonus || 0};
        `;
        // Missing difficultyBonus?
    }
    flags.scriptData.push(newScript);

    switch(flags.effectApplication)
    {
        case "actor":
            flags.applicationData.type = "document";                
            flags.applicationData.documentType = "Actor";                
            flags.applicationData.equipTransfer = false;
            break;
        case "item":
            flags.applicationData.type = "document";                
            flags.applicationData.documentType = "Item";                
            break;
        case "equipped":
            flags.applicationData.type = "document";                
            flags.applicationData.documentType = "Actor";  
            flags.applicationData.equipTransfer = true;
            break;
        case "apply" : 
            flags.applicationData.type = "target";                
            break;
        case "damage" : 
            flags.applicationData.type = "document"; // Not sure about this
            flags.applicationData.documentType = "Item";
            break;
    }

    if (flags.itemChoice)
    {
        flags.applicationData.filter = flags.itemChoice;
    }
    if (flags.promptChoice)
    {
        flags.applicationData.prompt = true;
    }

    
    flags._legacyData = {
        effectApplication : flags.effectApplication,
        effectTrigger : flags.effectTrigger,
        preventDuplicateEffects : flags.preventDuplicateEffects,
        script : flags.script
    };
    delete flags.effectApplication;
    delete flags.effectTrigger;
    delete flags.preventDuplicateEffects;
    delete flags.script;
}

function _triggerMigrations(trigger)
{
    let migrations = {
        "invoke" : "manual",
        "oneTime" : "immediate",
        "addItems" : "immediate",
        "dialogChoice" : "dialog",
        "prefillDialog" : "dialog",
        "targetPrefillDialog" : "dialog"
    };
    return migrations[trigger] || trigger;
}

/**
 * Provides the main Actor data computation and organization.
 *
 * ActorWfrp4e contains all the preparation data and methods used for preparing an actor:
 * going through each Owned Item, preparing them for display based on characteristics.
 * Additionally, it handles all the different types of roll requests, setting up the
 * test dialog, how each test is displayed, etc.
 *
 *
 * @see   ActorSheetWfrp4e - Base sheet class
 * @see   ActorSheetWfrp4eCharacter - Character sheet class
 * @see   ActorSheetWfrp4eNPC - NPC sheet class
 * @see   ActorSheetWfrp4eCreature - Creature sheet class
 * @see   ChatWFRP4e - Sends test data to roll tests.
 */
class ActorWfrp4e extends WFRP4eDocumentMixin$1(Actor)
{

  /**
   *
   * Set initial actor data based on type
   * 
   * @param {Object} data        Barebones actor data which this function adds onto.
   * @param {Object} options     (Unused) Additional options which customize the creation workflow.
   *
   */
  async _preCreate(data, options, user) {

    if (data._id)
      options.keepId = WFRP_Utility$1._keepID(data._id, this);


    let migration = game.wfrp4e.migration.migrateActorData(this);
    this.updateSource({ effects: game.wfrp4e.migration.removeLoreEffects(data) }, { recursive: false });

    if (!isEmpty(migration)) {
      this.updateSource(migration);
      WFRP_Utility$1.log("Migrating Actor: " + this.name, true, migration);
    }

    await super._preCreate(data, options, user);
    let preCreateData = {};

    if (!data.items?.length && !options.skipItems)
      preCreateData.items = await this._getNewActorItems();
    else
      preCreateData.items = this.items.map(i => mergeObject(i.toObject(), game.wfrp4e.migration.migrateItemData(i), { overwrite: true }));

    if (data.effects?.length)
      preCreateData.effects = this.effects.map(i => mergeObject(i.toObject(), game.wfrp4e.migration.migrateEffectData(i), { overwrite: true }));

    this.updateSource(preCreateData);
  }


  async _onUpdate(data, options, user) {
    if (game.user.id != user) {
      return
    }


    await super._onUpdate(data, options, user);
    await Promise.all(this.runScripts("update", {}));
    // this.system.checkSize();
  }

  async _onCreate(data, options, user) {
    if (game.user.id != user) {
      return
    }

    await super._onCreate(data, options, user);
    await Promise.all(this.runScripts("update", {}));
    // this.system.checkSize();
  }

  prepareBaseData() {
    this.propagateDataModels(this.system, "runScripts", this.runScripts.bind(this));
    this._itemTypes = null;
    this.system.computeBase();
  }

  prepareDerivedData() {
    this.system.computeDerived();

    //TODO Move prepare-updates to hooks?
    if (this.type != "vehicle") {
      if (game.actors && this.inCollection) // Only check system effects if past this: isn't an on-load prepareData and the actor is in the world (can be updated)
        this.checkSystemEffects();
    }
  }


















  get conditions() {
    return this.effects.filter(e => e.isCondition)
  }



































  /**
     * Shared setup data for all different dialogs
     * Each dialog also has its own "setup" function
     *
     * @param {Object} dialogOptions      Dialog template, buttons, everything associated with the dialog
     * @param {Object} dialogClass           Test info: target number, SL bonus, success bonus, etc
     */
  _setupTest(dialogData, dialogClass)
  {
    dialogData.data.targets = Array.from(game.user.targets);
    dialogData.data.actor = this;
    dialogData.data.scripts = foundry.utils.deepClone((dialogData.data.targets 
      .map(t => t.actor)
      .filter(actor => actor)
      .reduce((prev, current) => prev.concat(current.getScripts("dialog", (s) => s.options.dialog?.targeter)), []) // Retrieve targets' targeter dialog effects
      .concat(this?.getScripts("dialog", (s) => !s.options.dialog?.targeter) // Don't use our own targeter dialog effects
      ))) || [];




    dialogData.fields.advantage = this.system.status.advantage.value;

    dialogData.data.other = []; // Container for miscellaneous data that can be freely added onto

    if (dialogData.options.context) {
      if (typeof dialogData.options.context.general === "string")
        dialogData.options.context.general = [dialogData.options.context.general];
      if (typeof dialogData.options.context.success === "string")
        dialogData.options.context.success = [dialogData.options.context.success];
      if (typeof dialogData.options.context.failure === "string")
        dialogData.options.context.failure = [dialogData.options.context.failure];
    }
    if (canvas.scene) {
      game.user.updateTokenTargets([]);
      game.user.broadcastActivity({ targets: [] });
    }
    if (dialogData.data.hitLoc)
    {
      dialogData.fields.hitLocation = "roll", // Default a WS or BS test to have hit location;
      dialogData.data.hitLocationTable = game.wfrp4e.tables.getHitLocTable(dialogData.data.targets[0]?.actor?.details?.hitLocationTable?.value || "hitloc");
    }
    else 
    {
      dialogData.fields.hitLocation = "none";
    }
    const isSocketTest = game.wfrp4e.utility.IsSocketTest();
    let owner = game.wfrp4e.utility.getActiveDocumentOwner(this);
    if (owner.id != game.user.id && isSocketTest) {
      return this.setupSocket(dialogData, dialogClass);
    } else {
      return dialogClass.setup(dialogData.fields, dialogData.data, dialogData.options)
    }
  }

  setupSocket(dialogData, dialogClass) {
    let payload = { dialogData, dialogClass, userId: game.user.id, actorId: this.id };
      return game.wfrp4e.utility.setupSocket(owner, payload, content);
  }

  /**
   * Setup a Characteristic Test.
   *
   * Characteristics tests are the simplest test, all that needs considering is the target number of the
   * characteristic being tested, and any modifiers the user enters.
   *
   * @param {String} characteristicId     The characteristic id (e.g. "ws") - id's can be found in config.js
   *
   */
  async  setupCharacteristic(characteristic, options = {}) {
    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        characteristic,
        hitLoc : (characteristic == "ws" || characteristic == "bs") && !options.reload
      },    
      options : options || {}         // Application/optional properties
    };
    // TODO: handle abort
    return this._setupTest(dialogData, CharacteristicDialog)
  }

  /**
   * Setup a Skill Test.
   *
   * Skill tests are much like Characteristic Tests in their simplicity, just with another layer of modifiers (skill advances).
   * However, there is more complication if the skill is instead for an Income test, which adds computation after the roll is
   * completed.
   *
   * @param {Object} skill    The skill item being tested. Skill items contain the advancements and the base characteristic, see template.json for more information.
   * @param {bool}   income   Whether or not the skill is being tested to determine Income.
   */
  async setupSkill(skill, options = {}) {
    if (typeof (skill) === "string") {
      let skillName = skill;
      skill = this.itemTypes["skill"].find(sk => sk.name == skill);
      if (!skill)
      {
        // Skill not found, find later and use characteristic
        skill = {
          name : skillName,
          id : "unknown",
          characteristic : {
            key : ""
          }
        };
      }
    }

    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        skill,
        hitLoc : ((skill.characteristic.key == "ws" ||
                  skill.characteristic.key == "bs" ||
                  skill.name.includes(game.i18n.localize("NAME.Melee")) ||
                  skill.name.includes(game.i18n.localize("NAME.Ranged")))
                  && !options.reload)
      },    
      options : options || {}         // Application/optional properties
    };

    return this._setupTest(dialogData, SkillDialog)

    // if (options.corruption)
    //   cardOptions.rollMode = "gmroll"

  }

  /**
   * Setup a Weapon Test.
   *
   * Probably the most complicated type of Test, weapon tests' complexity comes from all the different
   * factors and variables of the different weapons available and how they might affect test results,
   * as well as ammo usage, the effects of using different skills etc.
   *
   * @param {Object} weapon   The weapon Item being used.
   * @param {bool}   event    The event that called this Test, used to determine if attack is melee or ranged.
   */
  async setupWeapon(weapon, options = {}) {

    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        weapon,
        hitLoc : true
      },    
      options : options || {}         // Application/optional properties
    };

    return this._setupTest(dialogData, WeaponDialog)
  }


  /**
   * Setup a Casting Test.
   *
   * Casting tests are more complicated due to the nature of spell miscasts, ingredients, etc. Whatever ingredient
   * is selected will automatically be used and negate one miscast. For the spell rolling logic, see ChatWFRP.rollCastTest
   * where all this data is passed to in order to calculate the roll result.
   *
   * @param {Object} spell    The spell Item being Casted. The spell item has information like CN, lore, and current ingredient ID
   *
   */
  async setupCast(spell, options = {}) {

    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        spell,
        hitLoc : !!spell.system.damage.value
      },    
      options : options || {}         // Application/optional properties
    };

    return this._setupTest(dialogData, CastDialog)
  }

  /**
   * Setup a Channelling Test.
   *
   * Channelling tests are more complicated due to the nature of spell miscasts, ingredients, etc. Whatever ingredient
   * is selected will automatically be used and mitigate miscasts. For the spell rolling logic, see ChatWFRP.rollChannellTest
   * where all this data is passed to in order to calculate the roll result.
   *
   * @param {Object} spell    The spell Item being Channelled. The spell item has information like CN, lore, and current ingredient ID
   * This spell SL will then be updated accordingly.
   *
   */
  async setupChannell(spell, options = {}) {

    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        spell,
        hitLoc : false
      },    
      options : options || {}         // Application/optional properties
    };

    return this._setupTest(dialogData, ChannellingDialog)
  }

  /**
   * Setup a Prayer Test.
   *
   * Prayer tests are fairly simple, with the main complexity coming from sin and wrath of the gods,
   * the logic of which can be found in ChatWFRP.rollPrayerTest, where all this data here is passed
   * to in order to calculate the roll result.
   *
   * @param {Object} prayer    The prayer Item being used, compared to spells, not much information
   * from the prayer itself is needed.
   */
  async setupPrayer(prayer, options = {}) {

    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        prayer,
        hitLoc : (prayer.damage.value || prayer.damage.dice || prayer.damage.addSL)
      },    
      options : options || {}         // Application/optional properties
    };

    return this._setupTest(dialogData, PrayerDialog)
  }

  /**
   * Setup a Trait Test.
   *
   * Some traits are rollable, and so are assigned a rollable characteristic, this is where
   * rolling those characteristics is setup. Additonally, sometimes these traits have a
   * "Bonus characteristic" which in most all cases means what characteristic bonus to add
   * to determine damage. See the logic in traitTest.
   *
   * @param {Object} trait   The trait Item being used, containing which characteristic/bonus characteristic to use
   */
  async setupTrait(trait, options = {}) {

    let dialogData = {
      fields : options.fields || {},  // Fields are data properties in the dialog template
      data : {                  // Data is internal dialog data
        trait,
        hitLoc : (trait.rollable.rollCharacteristic == "ws" || trait.rollable.rollCharacteristic == "bs")
      },    
      options : options || {}         // Application/optional properties
    };

    return this._setupTest(dialogData, TraitDialog)

   
    //   champion: !!this.has(game.i18n.localize("NAME.Champion")),
    //   deadeyeShot : this.has(game.i18n.localize("NAME.DeadeyeShot"), "talent") && weapon.attackType == "ranged"
  }


  async setupExtendedTest(item, options = {}) {

    let defaultRollMode = item.hide.test || item.hide.progress ? "gmroll" : "roll";

    if (item.SL.target <= 0)
      return ui.notifications.error(game.i18n.localize("ExtendedError1"))

    options.extended = item.id;
    options.rollMode = defaultRollMode;
    options.hitLocation = false;
    options.absolute = {difficulty : item.system.difficulty.value || "challenging"};

    let characteristic = WFRP_Utility$1.findKey(item.test.value, game.wfrp4e.config.characteristics);
    if (characteristic) {
      let test = await this.setupCharacteristic(characteristic, options);
      await test.roll();
    }
    else {
      let skill = this.itemTypes["skill"].find(i => i.name == item.test.value);
      if (skill) {
        let test = await this.setupSkill(skill, options);
        await test.roll();
      } 
      else {
        ui.notifications.error(`${game.i18n.format("ExtendedError2", { name: item.test.value })}`);
      }
    }
  }


  async rollReloadTest(weapon) {
    let testId = weapon.getFlag("wfrp4e", "reloading");
    let extendedTest = this.items.get(testId);
    if (!extendedTest) {

      //ui.notifications.error(game.i18n.localize("ITEM.ReloadError"))
      await this.checkReloadExtendedTest(weapon);
      return
    }
    await this.setupExtendedTest(extendedTest, { reload: true, weapon, appendTitle: " - " + game.i18n.localize("ITEM.Reloading") });
  }


  /**
   * Deprecated - only used for compatibility with existing effects
   * As shown in the functions, just call `roll()` on the test object to compute the tests
   */
  async basicTest(test, options = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll({ async: true });
    return test;
  }
  async weaponTest(test, options = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async castTest(test, options = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll({ async: true });
    return test;
  }
  async channelTest(test, options = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async prayerTest(test, options = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }
  async traitTest(test, options = {}) {
    if (test.testData)
      return ui.notifications.warn(game.i18n.localize("WARNING.ActorTest"))
    await test.roll();
    return test;
  }

  //#endregion



  /**
 * Adds all missing basic skills to the Actor.
 *
 * This function will add all mising basic skills, used when an Actor is created (see create())
 * as well as from the right click menu from the Actor directory.
 *
 */
  async addBasicSkills() {
    let ownedBasicSkills = this.itemTypes["skill"].filter(i => i.advanced.value == "bsc");
    let allBasicSkills = await WFRP_Utility$1.allBasicSkills();

    // Filter allBasicSkills with ownedBasicSkills, resulting in all the missing skills
    let skillsToAdd = allBasicSkills.filter(s => !ownedBasicSkills.find(ownedSkill => ownedSkill.name == s.name));

    // Add those missing basic skills
    this.createEmbeddedDocuments("Item", skillsToAdd);
  }

  /**
   * Apply damage to an actor, taking into account armor, size, and weapons.
   *
   * applyDamage() is typically called at the end of an oppposed tests, where you can
   * right click the chat message and apply damage. This function goes through the
   * process of calculating and reducing damage if needede based on armor, toughness,
   * size, armor qualities/flaws, and weapon qualities/flaws
   *
   * @param {Object} victim       id of actor taking damage
   * @param {Object} opposedData  Test results, all the information needed to calculate damage
   * @param {var}    damageType   enum for what the damage ignores, see config.js
   */
  async applyDamage(opposedTest, damageType = game.wfrp4e.config.DAMAGE_TYPE.NORMAL) {
    if (!opposedTest.result.damage)
      return `<b>Error</b>: ${game.i18n.localize("CHAT.DamageAppliedError")}`
    // If no damage value, don't attempt anything
    if (!opposedTest.result.damage.value)
      return game.i18n.localize("CHAT.DamageAppliedErrorTiring");
    // Get actor/tokens for those in the opposed test
    let actor = this;
    let attacker = opposedTest.attacker;
    let soundContext = { item: {}, action: "hit" };

    // Start wound loss at the damage value
    let totalWoundLoss = opposedTest.result.damage.value;
    let newWounds = actor.status.wounds.value;
    let applyAP = (damageType == game.wfrp4e.config.DAMAGE_TYPE.IGNORE_TB || damageType == game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
    let applyTB = (damageType == game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP || damageType == game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
    let AP = actor.status.armour[opposedTest.result.hitloc.value];

    // Start message update string
    let updateMsg = `<b>${game.i18n.localize("CHAT.DamageApplied")}</b><span class = 'hide-option'>: `;
    let messageElements = [];
    let extraMessages = [];
    // if (damageType !=  game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL)
    //   updateMsg += " ("

    let weaponProperties = opposedTest.attackerTest.item?.properties || {};
    // If weapon is undamaging
    let undamaging = false;
    // If weapon has Hack
    let hack = false;
    // If weapon has Impale
    let impale = false;
    // If weapon has Penetrating
    let penetrating = false;

    let zzap = false;

    let args = { actor, attacker, opposedTest, damageType, weaponProperties, applyAP, applyTB, totalWoundLoss, AP, extraMessages };
    await Promise.all(actor.runScripts("preTakeDamage", args));
    await Promise.all(attacker.runScripts("preApplyDamage", args));
    await Promise.all(opposedTest.attackerTest.item?.runScripts("preApplyDamage", args));
    damageType = args.damageType;
    applyAP = args.applyAP; 
    applyTB = args.applyTB;
    totalWoundLoss = args.totalWoundLoss;

    // Reduce damage by TB
    if (applyTB) {
      totalWoundLoss -= actor.characteristics.t.bonus;
      messageElements.push(`${actor.characteristics.t.bonus} ${game.i18n.localize("TBRed")}`);
    }

    if (applyAP) {
      AP.ignored = 0;

      // Determine its qualities/flaws to be used for damage calculation
      penetrating = weaponProperties?.qualities?.penetrating;
      undamaging = weaponProperties?.flaws?.undamaging;
      hack = weaponProperties?.qualities?.hack;
      impale = weaponProperties?.qualities?.impale;
      weaponProperties?.qualities?.pummel;
      zzap = weaponProperties?.qualities?.zzap;

      // see if armor flaws should be triggered
      let ignorePartial = opposedTest.attackerTest.result.roll % 2 == 0 || opposedTest.attackerTest.result.critical;
      let ignoreWeakpoints = opposedTest.attackerTest.result.critical && impale;

      // Mitigate damage with armor one layer at a time
      for (let layer of AP.layers) {
        if (ignoreWeakpoints && layer.weakpoints) {
          AP.ignored += layer.value;
        }
        else if (ignorePartial && layer.partial) {
          AP.ignored += layer.value;
        }
        else if (zzap && layer.metal) // ignore 1 AP (below) and all metal AP 
        {
            AP.ignored += layer.value;
        }
        else if (penetrating) // If penetrating - ignore 1 or all armor depending on material
        {
          if (!game.settings.get("wfrp4e", "mooPenetrating"))
            AP.ignored += layer.metal ? 1 : layer.value;
        }
        // if (opposedTest.attackerTest.result.roll % 2 != 0 && layer.impenetrable) {
        //   impenetrable = true;
        //   soundContext.outcome = "impenetrable"
        // }

        // Prioritize plate over chain over leather for sound
        if (layer.value) {
          if (layer.armourType == "plate")
            soundContext.item.armourType = layer.armourType;
          else if (!soundContext.item.armourType || (soundContext.item.armourType && (soundContext.item.armourType.includes("leather")) && layer.armourType == "mail")) // set to chain if there isn't an armour type set yet, or the current armor type is leather
            soundContext.item.armourType = layer.armourType;
          else if (!soundContext.item.armourType)
            soundContext.item.armourType = "leather";
        }
      }

      if (zzap) // ignore 1 AP and all metal AP (above)
      {
        AP.ignored += 1;
      }

      //@HOUSE
      if (penetrating && game.settings.get("wfrp4e", "mooPenetrating")) {
        game.wfrp4e.utility.logHomebrew("mooPenetrating");
        AP.ignored += penetrating.value || 2;
      }
      //@/HOUSE

      // AP.used is the actual amount of AP considered
      AP.used = AP.value - AP.ignored;
      AP.used = AP.used < 0 ? 0 : AP.used;           // AP minimum 0
      AP.used = undamaging ? AP.used * 2 : AP.used;  // Double AP if undamaging

      // show the AP usage in the updated message
      if (AP.ignored)
        messageElements.push(`${AP.used}/${AP.value} ${game.i18n.localize("AP")}`);
      else
        messageElements.push(`${AP.used} ${game.i18n.localize("AP")}`);

      // If using a shield, add that AP as well
      let shieldAP = 0;
      if (game.settings.get("wfrp4e", "uiaShields") && !opposedTest.defenderTest.context.unopposed) // UIA shields don't need to be used, just equipped
      {
        shieldAP = this.status.armour.shield;
      }
      else // RAW Shields required the shield to be used
      {
        if (opposedTest.defenderTest.weapon) {
          if (opposedTest.defenderTest.weapon.properties.qualities.shield)
            shieldAP = this.status.armour.shield;
        }
      }
        
      //@HOUSE
      if (game.settings.get("wfrp4e", "mooShieldAP") && opposedTest.defenderTest.result.outcome == "failure") {
        game.wfrp4e.utility.logHomebrew("mooShieldAP");
        shieldAP = 0;
      }
      //@/HOUSE

      if (shieldAP)
        messageElements.push(`${shieldAP} ${game.i18n.localize("CHAT.DamageShield")}`);

      // Reduce damage done by AP
      totalWoundLoss -= (AP.used + shieldAP);

      // Minimum 1 wound if not undamaging
      if (!undamaging)
        totalWoundLoss = totalWoundLoss <= 0 ? 1 : totalWoundLoss;
      else
        totalWoundLoss = totalWoundLoss <= 0 ? 0 : totalWoundLoss;

      try {
        if (opposedTest.attackerTest.weapon.attackType == "melee") {
          if ((opposedTest.attackerTest.weapon.Qualities.concat(opposedTest.attackerTest.weapon.Flaws)).every(p => [game.i18n.localize("PROPERTY.Pummel"), game.i18n.localize("PROPERTY.Slow"), game.i18n.localize("PROPERTY.Damaging")].includes(p)))
            soundContext.outcome = "warhammer"; // special sound for warhammer :^)
          else if (AP.used) {
            soundContext.item.type = "armour";
            if (applyAP && totalWoundLoss <= 1)
              soundContext.outcome = "blocked";
            else if (applyAP)
              soundContext.outcome = "normal";
            if (impenetrable)
              soundContext.outcome = "impenetrable";
            if (hack)
              soundContext.outcome = "hack";
          }
          else {
            soundContext.item.type = "hit";
            soundContext.outcome = "normal";
            if (impale || penetrating) {
              soundContext.outcome = "normal_slash";
            }
          }
        }
      }
      catch (e) { WFRP_Utility$1.log("Sound Context Error: " + e, true); } // Ignore sound errors
    }

    let scriptArgs = { actor, opposedTest, totalWoundLoss, AP, damageType, updateMsg, messageElements, attacker, extraMessages };
    await Promise.all(actor.runScripts("takeDamage", scriptArgs));
    await Promise.all(attacker.runScripts("applyDamage", scriptArgs));
    await Promise.all(opposedTest.attackerTest.item?.runScripts("applyDamage", scriptArgs));
    Hooks.call("wfrp4e:applyDamage", scriptArgs);

    totalWoundLoss = scriptArgs.totalWoundLoss;


    newWounds -= totalWoundLoss;
    updateMsg += "</span>";
    updateMsg += " " + totalWoundLoss;

    updateMsg += ` (${messageElements.join(" + ")})`;

    WFRP_Audio.PlayContextAudio(soundContext);

    // If damage taken reduces wounds to 0, show Critical
    if (newWounds <= 0) {
      //WFRP_Audio.PlayContextAudio(opposedTest.attackerTest.weapon, {"type": "hit", "equip": "crit"})
      let critAmnt = game.settings.get("wfrp4e", "uiaCritsMod");
      if (game.settings.get("wfrp4e", "uiaCrits") && critAmnt && (Math.abs(newWounds)) > 0) {
        let critModifier = (Math.abs(newWounds)) * critAmnt;
        updateMsg += `<br><a class ="table-click critical-roll" data-modifier=${critModifier} data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")} +${critModifier}</a>`;
      }
      //@HOUSE
      else if (game.settings.get("wfrp4e", "mooCritModifiers")) {
        game.wfrp4e.utility.logHomebrew("mooCritModifiers");
        let critModifier = (Math.abs(newWounds) - actor.characteristics.t.bonus) * critAmnt;
        if (critModifier)
          updateMsg += `<br><a class ="table-click critical-roll" data-modifier=${critModifier} data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")} ${critModifier > 0 ? "+" + critModifier : critModifier}</a>`;
        else
          updateMsg += `<br><a class ="table-click critical-roll" data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")}</a>`;
      }
      //@/HOUSE
      else if (Math.abs(newWounds) < actor.characteristics.t.bonus && !game.settings.get("wfrp4e", "uiaCrits"))
        updateMsg += `<br><a class ="table-click critical-roll" data-modifier="-20" data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")} (-20)</a>`;
      else
        updateMsg += `<br><a class ="table-click critical-roll" data-table = "crit${opposedTest.result.hitloc.value}" ><i class='fas fa-list'></i> ${game.i18n.localize("Critical")}</a>`;
    }
    if (hack)
      updateMsg += `<br>${game.i18n.localize("CHAT.DamageAP")} ${game.wfrp4e.config.locations[opposedTest.result.hitloc.value]}`;

    if (newWounds <= 0)
      newWounds = 0; // Do not go below 0 wounds


    let item = opposedTest.attackerTest.item;
    if (item?.properties && item?.properties.qualities.slash && updateMsg.includes("critical-roll"))
    {
      updateMsg += `<br>${game.i18n.format("PROPERTY.SlashAlert", {value : parseInt(item?.properties.qualities.slash.value)})}`;
    }


    let daemonicTrait = actor.has(game.i18n.localize("NAME.Daemonic"));
    let wardTrait = actor.has(game.i18n.localize("NAME.Ward"));
    if (daemonicTrait) {
      let daemonicRoll = Math.ceil(CONFIG.Dice.randomUniform() * 10);
      let target = daemonicTrait.specification.value;
      // Remove any non numbers
      if (isNaN(target))
        target = target.split("").filter(char => /[0-9]/.test(char)).join("");

      if (Number.isNumeric(target) && daemonicRoll >= parseInt(daemonicTrait.specification.value)) {
        updateMsg = `<span style = "text-decoration: line-through">${updateMsg}</span><br>${game.i18n.format("OPPOSED.Daemonic", { roll: daemonicRoll })}`;
        return updateMsg;
      }
      else if (Number.isNumeric(target)) {
        updateMsg += `<br>${game.i18n.format("OPPOSED.DaemonicRoll", { roll: daemonicRoll })}`;
      }

    }

    if (wardTrait) {
      let wardRoll = Math.ceil(CONFIG.Dice.randomUniform() * 10);
      let target = wardTrait.specification.value;
      // Remove any non numbers
      if (isNaN(target))
        target = target.split("").filter(char => /[0-9]/.test(char)).join("");

      if (Number.isNumeric(target) && wardRoll >= parseInt(wardTrait.specification.value)) {
        updateMsg = `<span style = "text-decoration: line-through">${updateMsg}</span><br>${game.i18n.format("OPPOSED.Ward", { roll: wardRoll })}`;
        return updateMsg;
      }
      else if (Number.isNumeric(target)) {
        updateMsg += `<br>${game.i18n.format("OPPOSED.WardRoll", { roll: wardRoll })}`;
      }

    }

    if (extraMessages.length > 0)
    {
      updateMsg += `<p>${extraMessages.join(`</p><p>`)}</p>`;
    }

    if (totalWoundLoss > 0)
    {
      let damageEffects = opposedTest.attackerTest.item?.damageEffects;
      await actor.applyEffect({effectUuids: damageEffects.map(i => i.uuid), messageId : opposedTest.attackerTest.message.id});
    }

    // Update actor wound value
    actor.update({ "system.status.wounds.value": newWounds });

    return updateMsg;
  }



  /**
   * Unlike applyDamage(), which is for opposed damage calculation, this function just takes a number and damage type and applies the damage.
   * 
   * @param {Number} damage Amount of damage
   * @param {Object} options Type of damage, minimum 1
   */
  async applyBasicDamage(damage, { damageType = game.wfrp4e.config.DAMAGE_TYPE.NORMAL, minimumOne = true, loc = "body", suppressMsg = false } = {}) {
    let newWounds = this.status.wounds.value;
    let modifiedDamage = damage;
    let applyAP = (damageType == game.wfrp4e.config.DAMAGE_TYPE.IGNORE_TB || damageType == game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
    let applyTB = (damageType == game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP || damageType == game.wfrp4e.config.DAMAGE_TYPE.NORMAL);
    let msg = game.i18n.format("CHAT.ApplyDamageBasic", { name: this.prototypeToken.name });


    if (loc == "roll")
    {
      loc = (await game.wfrp4e.tables.rollTable("hitloc")).result;
    }

    if (applyAP) {
      modifiedDamage -= this.status.armour[loc].value;
      msg += ` (${this.status.armour[loc].value} ${game.i18n.localize("AP")}`;
      if (!applyTB)
        msg += ")";
      else
        msg += " + ";
    }

    if (applyTB) {
      modifiedDamage -= this.characteristics.t.bonus;
      if (!applyAP)
        msg += " (";
      msg += `${this.characteristics.t.bonus} ${game.i18n.localize("TBRed")})`;
    }

    if (minimumOne && modifiedDamage <= 0)
      modifiedDamage = 1;
    else if (modifiedDamage < 0)
      modifiedDamage = 0;

    msg = msg.replace("@DAMAGE", modifiedDamage);

    newWounds -= modifiedDamage;
    if (newWounds < 0)
      newWounds = 0;
    await this.update({ "system.status.wounds.value": newWounds });

    if (!suppressMsg)
      await ChatMessage.create({ content: msg });
    return msg;
  }


  /**
   * Called by data model update checks
   */
  _displayScrollingChange(change, options = {}) {
    if (!change) return;
    change = Number(change);
    const tokens = this.isToken ? [this.token?.object] : this.getActiveTokens(true);
    for (let t of tokens) {
      canvas.interface?.createScrollingText(t.center, change.signedString(), {
        anchor: (change<0) ? CONST.TEXT_ANCHOR_POINTS.BOTTOM: CONST.TEXT_ANCHOR_POINTS.TOP,
        direction: (change<0) ? 1: 2,
        fontSize: 30,
        fill: options.advantage ? "0x6666FF" : change < 0 ? "0xFF0000" : "0x00FF00", // I regret nothing
        stroke: 0x000000,
        strokeThickness: 4,
        jitter: 0.25
      });
     }
  }


      // Handles applying effects to this actor, ensuring that the owner is the one to do so
    // This allows the owner of the document to roll tests and execute scripts, instead of the applying user
    // e.g. the players can actually test to avoid an effect, instead of the GM doing it
    async applyEffect({effectUuids=[], effectData=[], messageId}={})
    {
        let owningUser = game.wfrp4e.utility.getActiveDocumentOwner(this);

        if (typeof effectUuids == "string")
        {
            effectUuids = [effectUuids];
        }

        if (owningUser?.id == game.user.id)
        {
            for (let uuid of effectUuids)
            {
                let effect = fromUuidSync(uuid);
                let message = game.messages.get(messageId);
                await ActiveEffect.implementation.create(effect.convertToApplied(message?.getTest()), {parent: this, message : message?.id});
            }
            for(let data of effectData)
            {
                await ActiveEffect.implementation.create(data, {parent: this, message : messageId});
            }
        }   
        else 
        {
            SocketHandlers.executeOnOwner(this, "applyEffect", {effectUuids, effectData, actorUuid : this.uuid, messageId});
        }
    }


  /* --------------------------------------------------------------------------------------------------------- */
  /* -------------------------------------- Auto-Advancement Functions --------------------------------------- */
  /* --------------------------------------------------------------------------------------------------------- */
  /**
   * These functions are primarily for NPCs and Creatures and their automatic advancement capabilities. 
   *
  /* --------------------------------------------------------------------------------------------------------- */


  /**
   * Advances an actor's skills based on their species and character creation rules
   * 
    * Per character creation, 3 skills from your species list are advanced by 5, and 3 more are advanced by 3.
    * This functions uses the Foundry Roll class to randomly select skills from the list (defined in config.js)
    * and advance the first 3 selected by 5, and the second 3 selected by 3. This function uses the advanceSkill()
    * helper defined below.
   */
  async _advanceSpeciesSkills() {
    let skillList;

    // A species may not be entered in the actor, so use some error handling.
    try {
      let { skills } = game.wfrp4e.utility.speciesSkillsTalents(this.details.species.value, this.details.species.subspecies);
      skillList = skills;
      if (!skillList) {
        throw game.i18n.localize("ErrorSpeciesSkills") + " " + this.details.species.value;
      }
    }
    catch (error) {
      ui.notifications.info(`${game.i18n.format("ERROR.Species", { name: this.details.species.value })}`);
      WFRP_Utility$1.log("Could not find species " + this.details.species.value + ": " + error, true);
      throw error
    }
    // The Roll class used to randomly select skills
    let skillSelector = new Roll(`1d${skillList.length}- 1`);
    await skillSelector.roll();

    // Store selected skills
    let skillsSelected = [];
    while (skillsSelected.length < 6) {
      skillSelector = await skillSelector.reroll();
      if (!skillsSelected.includes(skillSelector.total)) // Do not push duplicates
        skillsSelected.push(skillSelector.total);
    }

    // Advance the first 3 by 5, advance the second 3 by 3.
    for (let skillIndex = 0; skillIndex < skillsSelected.length; skillIndex++) {
      if (skillIndex <= 2)
        await this._advanceSkill(skillList[skillsSelected[skillIndex]], 5);
      else
        await this._advanceSkill(skillList[skillsSelected[skillIndex]], 3);
    }
  }


  /**
   * Advances an actor's talents based on their species and character creation rules
   * 
   * Character creation rules for talents state that you get all talents in your species, but there
   * are a few where you must choose between two instead. See config.js for how the species talent 
   * object is set up for support in this. Basically species talents are an array of strings, however
   * ones that offer a choice is formatted as "<talent1>, <talent2>", each talent being a choice. Finally,
   * the last element of the talent list is a number denoting the number of random talents. This function uses
   * the advanceTalent() helper defined below.
   */
  async _advanceSpeciesTalents() {
    // A species may not be entered in the actor, so use some error handling.
    let talentList;
    try {
      let { talents } = game.wfrp4e.utility.speciesSkillsTalents(this.details.species.value, this.details.species.subspecies);
      talentList = talents;
      if (!talentList) {
      }
    }
    catch (error) {
      ui.notifications.info(`${game.i18n.format("ERROR.Species", { name: this.details.species.value })}`);
      WFRP_Utility$1.log("Could not find species " + this.details.species.value + ": " + error, true);
      throw error
    }
    let talentSelector;
    for (let talent of talentList) {
      if (!isNaN(talent)) // If is a number, roll on random talents
      {
        for (let i = 0; i < talent; i++) {
          let result = await game.wfrp4e.tables.rollTable("talents");
          await this._advanceTalent(result.object.text);
        }
        continue
      }
      // If there is a comma, talent.split() will yield an array of length > 1
      let talentOptions = talent.split(',').map(function (item) {
        return item.trim();
      });

      // Randomly choose a talent option and advance it.
      if (talentOptions.length > 1) {
        talentSelector = await new Roll(`1d${talentOptions.length} - 1`).roll();
        await this._advanceTalent(talentOptions[talentSelector.total]);
      }
      else // If no option, simply advance the talent.
      {
        await this._advanceTalent(talent);
      }
    }

  }


  /**
   * Adds (if needed) and advances a skill by the specified amount.
   * 
   * As the name suggests, this function advances any given skill, if 
   * the actor does not currently have that skill, it will be added 
   * from the compendium and advanced. Note that this function is neither
   * used by manually advancing skills nor when clicking on advancement 
   * indicators. This will simply add the advancement value with no
   * other processing.
   * 
   * @param {String} skillName    Name of the skill to advance/add
   * @param {Number} advances     Advances to add to the skill
   */
  async _advanceSkill(skillName, advances) {
    // Look through items and determine if the actor has the skill
    let existingSkill = this.has(skillName, "skill");
    // If so, simply update the skill with the new advancement value. 
    if (existingSkill) {
      existingSkill = existingSkill.toObject();
      existingSkill.system.advances.value = (existingSkill.system.advances.value < advances) ? advances : existingSkill.system.advances.value;
      await this.updateEmbeddedDocuments("Item", [existingSkill]);
      return;
    }

    // If the actor does not already own skill, search through compendium and add it
    try {
      // See findSkill() for a detailed explanation of how it works
      // Advanced find function, returns the skill the user expects it to return, even with skills not included in the compendium (Lore (whatever))
      let skillToAdd = (await WFRP_Utility$1.findSkill(skillName)).toObject();
      skillToAdd.system.advances.value = advances;
      await this.createEmbeddedDocuments("Item", [skillToAdd]);
    }
    catch (error) {
      console.error("Something went wrong when adding skill " + skillName + ": " + error);
      ui.notifications.error(game.i18n.format("CAREER.AddSkillError", { skill: skillName, error: error }));
    }
  }

  /**
   * Adds the given talent to the actor
   * 
   * In my implementation, adding a talent is the same as advancing a talent. See
   * prepareTalent() and you'll see that the total number of any given talent is the
   * advencement value.
   * 
   * @param {String} talentName     Name of the talent to add/advance.
   */
  async _advanceTalent(talentName) {
    try {
      // See findTalent() for a detailed explanation of how it works
      // Advanced find function, returns the Talent the user expects it to return, even with Talents not included in the compendium (Etiquette (whatever))
      let talent = await WFRP_Utility$1.findTalent(talentName);
      await this.createEmbeddedDocuments("Item", [talent.toObject()]);
    }
    catch (error) {
      console.error("Something went wrong when adding talent " + talentName + ": " + error);
      ui.notifications.error(game.i18n.format("CAREER.AddTalentError", { talent: talentName, error: error }));
    }
  }

  /**
   * Advance NPC based on given career
   * 
   * A specialized function used by NPC type Actors that triggers when you click on a 
   * career to be "complete". This takes all the career data and uses it (and the helpers
   * defined above) to advance the actor accordingly. It adds all skills (advanced to the 
   * correct amount to be considered complete), advances all characteristics similarly, and 
   * adds all talents.
   * 
   * Note: This adds *all* skills and talents, which is not necessary to be considered complete.
   * However, I find deleting the ones you don't want to be much easier than trying to pick and 
   * choose the ones you do want.
   *
   * @param {Object} careerData     Career type Item to be used for advancement.
   * 
   */
  async advanceNPC(careerData) {
    let updateObj = {};
    let advancesNeeded = careerData.level.value * 5; // Tier 1 needs 5, 2 needs 10, 3 needs 15, 4 needs 20 in all characteristics and skills

    // Update all necessary characteristics to the advancesNeeded
    for (let advChar of careerData.characteristics)
      if (this.characteristics[advChar].advances < 5 * careerData.level.value)
        updateObj[`data.characteristics.${advChar}.advances`] = 5 * careerData.level.value;

    // Advance all skills in the career
    for (let skill of careerData.skills)
      await this._advanceSkill(skill, advancesNeeded);

    // Add all talents in the career
    for (let talent of careerData.talents)
      await this._advanceTalent(talent);

    this.update(updateObj);
  }


  _replaceData(formula) {
    let dataRgx = new RegExp(/@([a-z.0-9]+)/gi);
    return formula.replace(dataRgx, (match, term) => {
      let value = getProperty(this, term);
      return value ? String(value).trim() : "0";
    });
  }

  /**
   * Use a fortune point from the actor to reroll or add sl to a roll
   * @param {Object} message 
   * @param {String} type (reroll, addSL)
   */
  useFortuneOnRoll(message, type) {
    if (this.status.fortune.value > 0) {
      let test = message.getTest();
      let html = `<h3 class="center"><b>${game.i18n.localize("FORTUNE.Use")}</b></h3>`;
      //First we send a message to the chat
      if (type == "reroll")
        html += `${game.i18n.format("FORTUNE.UsageRerollText", { character: '<b>' + this.name + '</b>' })}<br>`;
      else
        html += `${game.i18n.format("FORTUNE.UsageAddSLText", { character: '<b>' + this.name + '</b>' })}<br>`;

      html += `<b>${game.i18n.localize("FORTUNE.PointsRemaining")} </b>${this.status.fortune.value - 1}`;
      ChatMessage.create(WFRP_Utility$1.chatDataSetup(html));

      // let cardOptions = this.preparePostRollAction(message);
      //Then we do the actual fortune action



      if (type == "reroll") {
        test.context.fortuneUsedReroll = true;
        test.context.fortuneUsedAddSL = true;
        test.reroll();

      }
      else //add SL
      {
        test.context.fortuneUsedAddSL = true;
        test.addSL(1);
      }
      this.update({ "system.status.fortune.value": this.status.fortune.value - 1 });
    }
  }

  /**
   * Take a Dark Deal to reroll for +1 Corruption
   * @param {Object} message 
   */
  useDarkDeal(message) {
    let html = `<h3 class="center"><b>${game.i18n.localize("DARKDEAL.Use")}</b></h3>`;
    html += `${game.i18n.format("DARKDEAL.UsageText", { character: '<b>' + this.name + '</b>' })}<br>`;
    let corruption = Math.trunc(this.status.corruption.value) + 1;
    html += `<b>${game.i18n.localize("Corruption")}: </b>${corruption}/${this.status.corruption.max}`;
    ChatMessage.create(WFRP_Utility$1.chatDataSetup(html));
    this.update({ "system.status.corruption.value": corruption }).then(() => {
      this.checkCorruption();
    });

    let test = message.getTest();
    test.reroll();
  }

  /**
   * This helper can be used to prepare chatOptions to reroll/edit a test card
   * It uses the informations of the roll located in the message entry
   * from game.messages
   * @param {Object} message 
   * @returns {Object} chatOptions
   */
  preparePostRollAction(message) {
    //recreate the initial (virgin) chatOptions object
    //add a flag for reroll limit
    let data = message.flags.data;
    let chatOptions = {
      flags: { img: message.flags.img },
      rollMode: data.rollMode,
      sound: message.sound,
      speaker: message.speaker,
      template: data.template,
      title: data.title.replace(` - ${game.i18n.localize("Opposed")}`, ""),
      user: message.user
    };
    if (data.attackerMessage)
      chatOptions.attackerMessage = data.attackerMessage;
    if (data.defenderMessage)
      chatOptions.defenderMessage = data.defenderMessage;
    if (data.unopposedStartMessage)
      chatOptions.unopposedStartMessage = data.unopposedStartMessage;
    return chatOptions;
  }


  async corruptionDialog(strength) {
    new Dialog({
      title: game.i18n.localize("DIALOG.CorruptionTitle"),
      content: `<p>${game.i18n.format("DIALOG.CorruptionContent", { name: this.name })}</p>`,
      buttons: {
        endurance: {
          label: game.i18n.localize("NAME.Endurance"),
          callback: () => {
            let skill = this.itemTypes["skill"].find(i => i.name == game.i18n.localize("NAME.Endurance"));
            if (skill) {
              this.setupSkill(skill, { title: game.i18n.format("DIALOG.CorruptionTestTitle", { test: skill.name }), corruption: strength }).then(setupData => this.basicTest(setupData));
            }
            else {
              this.setupCharacteristic("t", { title: game.i18n.format("DIALOG.CorruptionTestTitle", { test: game.wfrp4e.config.characteristics["t"] }), corruption: strength }).then(setupData => this.basicTest(setupData));
            }
          }
        },
        cool: {
          label: game.i18n.localize("NAME.Cool"),
          callback: () => {
            let skill = this.itemTypes["skill"].find(i => i.name == game.i18n.localize("NAME.Cool"));
            if (skill) {
              this.setupSkill(skill, { title: game.i18n.format("DIALOG.CorruptionTestTitle", { test: skill.name }), corruption: strength }).then(setupData => this.basicTest(setupData));
            }
            else {
              this.setupCharacteristic("wp", { title: game.i18n.format("DIALOG.CorruptionTestTitle", { test: game.wfrp4e.config.characteristics["wp"] }), corruption: strength }).then(setupData => this.basicTest(setupData));
            }
          }
        }

      }
    }).render(true);
  }


  has(traitName, type = "trait") {
    return this.itemTypes[type].find(i => i.name == traitName && i.included)
  }


  /**
 * Some effects applied to an actor are actually intended for items, but to make other things convenient
 * (like duration handling modules, or showing the effect icon on the token), they are given to an actor
 * 
 * Also as an unintended benefit it can be used to circumvent items being prepared twice (and thus their effects being applied twice)
 * 
 * @param {Item} item 
 */
  getEffectsApplyingToItem(item) {
    // Get effects that should be applied to item argument
    return this.effects.contents.filter(e => {
      if (e.disabled) {
        return false;
      }

      // An actor effects intended to apply to an item must have the itemTargets flag
      // Empty array => all items
      // No flag => Should not apply to items
      // Array with IDs => Apply only to those IDs
      let targeted = e.getFlag("wfrp4e", "itemTargets");
      if (targeted) {
        if (targeted.length) {
          return targeted.includes(item.id);
        }
        // If no items specified, apply to all items
        else {
          return true;
        }
      }
      else // If no itemTargets flag, it should not apply to items at all
      {
        return false;
      }

      // Create temporary effects that have the item as the parent, so the script context is correct
    }).map(i => new EffectWfrp4e(i.toObject(), { parent: item }));

  }

  /**
   * Same logic as getEffectsApplyingToItem, but reduce the effects to their scripts
   * 
   * @param {Item} item 
   */
  getScriptsApplyingToItem(item) {
    return this.getEffectsApplyingToItem(item).reduce((prev, current) => prev.concat(current.scripts), []);
  }


  /**
 * 
 * @param {Boolean} includeItemEffects Include Effects that are intended to be applied to Items, see getScriptsApplyingToItem, this does NOT mean effects that come from items
 */
  *allApplicableEffects(includeItemEffects = false) {

    for (const effect of this.effects) {
      if (effect.applicationData.documentType == "Item" && includeItemEffects) // Some effects are intended to modify items, but are placed on the actor for ease of tracking
      {
        yield effect;
      }
      else if (effect.applicationData.documentType == "Actor") // Normal effects (default documentType is actor)
      {
        yield effect;
      }
    }
    for (const item of this.items) {
      for (const effect of item.effects.contents.concat(item.system.getOtherEffects())) {
        // So I was relying on effect.transfer, which is computed in the effect's prepareData
        // However, apparently when you first load the world, that is computed after the actor
        // On subsequent data updates, it's computed before. I don't know if this is intentional
        // Regardless, we need to doublecheck whether this effect should transfer to the actor
        if (effect.determineTransfer()) {
          yield effect;
        }
      }
    }
  }

  async decrementInjuries() {
    this.injuries.forEach(i => this.decrementInjury(i));
  }

  async decrementInjury(injury) {
    if (isNaN(injury.system.duration.value))
      return ui.notifications.notify(game.i18n.format("CHAT.InjuryError", { injury: injury.name }))

    injury = duplicate(injury);
    injury.system.duration.value--;

    if (injury.system.duration.value < 0)
      injury.system.duration.value = 0;

    if (injury.system.duration.value == 0) {
      let chatData = game.wfrp4e.utility.chatDataSetup(game.i18n.format("CHAT.InjuryFinish", { injury: injury.name }), "gmroll");
      chatData.speaker = { alias: this.name };
      ChatMessage.create(chatData);
    }
    this.updateEmbeddedDocuments("Item", [injury]);
  }


  async decrementDiseases() {
    this.diseases.forEach(d => this.decrementDisease(d));
  }

  async decrementDisease(disease) {
    let d = duplicate(disease);
    if (!d.system.duration.active) {
      if (Number.isNumeric(d.system.incubation.value)) {

        d.system.incubation.value--;
        if (d.system.incubation.value <= 0) {
          this.activateDisease(d);
          d.system.incubation.value = 0;
        }
      }
      else {
        let chatData = game.wfrp4e.utility.chatDataSetup(`Attempted to decrement ${d.name} incubation but value is non-numeric`, "gmroll", false);
        chatData.speaker = { alias: this.name };
        ChatMessage.create(chatData);
      }
    }
    else {
      if (Number.isNumeric(d.system.duration.value)) {

        d.system.duration.value--;
        if (d.system.duration.value == 0)
          this.finishDisease(d);
      }
      else {
        let chatData = game.wfrp4e.utility.chatDataSetup(`Attempted to decrement ${d.name} duration but value is non-numeric`, "gmroll", false);
        chatData.speaker = { alias: this.name };
        ChatMessage.create(chatData);
      }
    }
    this.updateEmbeddedDocuments("Item", [d]);
  }

  async activateDisease(disease) {
    disease.system.duration.active = true;
    disease.system.incubation.value = 0;
    let msg = game.i18n.format("CHAT.DiseaseIncubation", { disease: disease.name });
    try {
      let durationRoll = (await new Roll(disease.system.duration.value).roll()).total;
      msg += game.i18n.format("CHAT.DiseaseDuration", { duration: durationRoll, unit: disease.system.duration.unit });
      disease.system.duration.value = durationRoll;
    }
    catch (e) {
      msg += game.i18n.localize("CHAT.DiseaseDurationError");
    }

    let chatData = game.wfrp4e.utility.chatDataSetup(msg, "gmroll", false);
    chatData.speaker = { alias: this.name };
    ChatMessage.create(chatData);
  }

  async finishDisease(disease) {

    let msg = game.i18n.format("CHAT.DiseaseFinish", { disease: disease.name });

    if (disease.system.symptoms.includes("lingering")) {
      let lingering = disease.effects.find(e => e.name.includes("Lingering"));
      if (lingering) {
        let difficulty = lingering.name.substring(lingering.name.indexOf("(") + 1, lingering.name.indexOf(")")).toLowerCase();

        this.setupSkill(game.i18n.localize("NAME.Endurance"), { difficulty }).then(setupData => this.basicTest(setupData).then(async test => {
          if (test.result.outcome == "failure") {
            let negSL = Math.abs(test.result.SL);
            if (negSL <= 1) {
              let roll = (await new Roll("1d10").roll()).total;
              msg += game.i18n.format("CHAT.LingeringExtended", { duration: roll });
            }
            else if (negSL <= 5) {
              msg += game.i18n.localize("CHAT.LingeringFestering");
              fromUuid("Compendium.wfrp4e-core.diseases.kKccDTGzWzSXCBOb").then(disease => {
                this.createEmbeddedDocuments("Item", [disease.toObject()]);
              });
            }
            else if (negSL >= 6) {
              msg += game.i18n.localize("CHAT.LingeringRot");
              fromUuid("Compendium.wfrp4e-core.diseases.M8XyRs9DN12XsFTQ").then(disease => {
                this.createEmbeddedDocuments("Item", [disease.toObject()]);
              });
            }
          }
        }));
      }
    }
    else {
      await this.deleteEmbeddedDocuments("ActiveEffect", [removeEffects]);
      await this.deleteEffectsFromItem(disease._id);
    }
    let chatData = game.wfrp4e.utility.chatDataSetup(msg, "gmroll", false);
    chatData.speaker = { alias: this.name };
    ChatMessage.create(chatData);

  }
  async handleIncomeTest(roll) {
    let { standing, tier } = roll.options.income;
    let result = roll.result;

    let dieAmount = game.wfrp4e.config.earningValues[tier]; // b, s, or g maps to 2d10, 1d10, or 1 respectively (takes the first letter)
    dieAmount = parseInt(dieAmount) * standing;     // Multilpy that first letter by your standing (Brass 4 = 8d10 pennies)
    let moneyEarned;
    if (tier != "g") // Don't roll for gold, just use standing value
    {
      dieAmount = dieAmount + "d10";
      moneyEarned = (await new Roll(dieAmount).roll()).total;
    }
    else
      moneyEarned = dieAmount;

    // After rolling, determined how much, if any, was actually earned
    if (result.outcome == "success") {
      roll.result.incomeResult = game.i18n.localize("INCOME.YouEarn") + " " + moneyEarned;
      switch (tier) {
        case "b":
          result.incomeResult += ` ${game.i18n.localize("NAME.BPPlural").toLowerCase()}.`;
          break;
        case "s":
          result.incomeResult += ` ${game.i18n.localize("NAME.SSPlural").toLowerCase()}.`;
          break;
        case "g":
          if (moneyEarned > 1)
            result.incomeResult += ` ${game.i18n.localize("NAME.GC").toLowerCase()}.`;
          else
            result.incomeResult += ` ${game.i18n.localize("NAME.GCPlural").toLowerCase()}.`;
          break;
      }
    }
    else if (Number(result.SL) > -6) {
      moneyEarned /= 2;
      result.incomeResult = game.i18n.localize("INCOME.YouEarn") + " " + moneyEarned;
      switch (tier) {
        case "b":
          result.incomeResult += ` ${game.i18n.localize("NAME.BPPlural").toLowerCase()}.`;
          break;
        case "s":
          result.incomeResult += ` ${game.i18n.localize("NAME.SSPlural").toLowerCase()}.`;
          break;
        case "g":
          if (moneyEarned > 1)
            result.incomeResult += ` ${game.i18n.localize("NAME.GC").toLowerCase()}.`;
          else
            result.incomeResult += ` ${game.i18n.localize("NAME.GCPlural").toLowerCase()}.`;
          break;
      }
    }
    else {
      result.incomeResult = game.i18n.localize("INCOME.Failure");
      moneyEarned = 0;
    }
    // let contextAudio = await WFRP_Audio.MatchContextAudio(WFRP_Audio.FindContext(test))
    // cardOptions.sound = contextAudio.file || cardOptions.sound
    result.moneyEarned = moneyEarned + tier;

    return result
  }


  async handleCorruptionResult(test) {
    let strength = test.options.corruption;
    let failed = test.result.outcome == "failure";
    let corruption = 0; // Corruption GAINED
    switch (strength) {
      case "minor":
        if (failed)
          corruption++;
        break;

      case "moderate":
        if (failed)
          corruption += 2;
        else if (test.result.SL < 2)
          corruption += 1;
        break;

      case "major":
        if (failed)
          corruption += 3;
        else if (test.result.SL < 2)
          corruption += 2;
        else if (test.result.SL < 4)
          corruption += 1;
        break;
    }

    // Revert previous test if rerolled
    if (test.context.reroll || test.context.fortuneUsedAddSL) {
      let previousFailed = test.context.previousResult.outcome == "failure";
      switch (strength) {
        case "minor":
          if (previousFailed)
            corruption--;
          break;

        case "moderate":
          if (previousFailed)
            corruption -= 2;
          else if (test.context.previousResult.SL < 2)
            corruption -= 1;
          break;

        case "major":
          if (previousFailed)
            corruption -= 3;
          else if (test.context.previousResult.SL < 2)
            corruption -= 2;
          else if (test.context.previousResult.SL < 4)
            corruption -= 1;
          break;
      }
    }
    let newCorruption = Number(this.status.corruption.value) + corruption;
    if (newCorruption < 0) newCorruption = 0;

    if (!test.context.reroll && !test.context.fortuneUsedAddSL)
      ChatMessage.create(WFRP_Utility$1.chatDataSetup(game.i18n.format("CHAT.CorruptionFail", { name: this.name, number: corruption }), "gmroll", false));
    else
      ChatMessage.create(WFRP_Utility$1.chatDataSetup(game.i18n.format("CHAT.CorruptionReroll", { name: this.name, number: corruption }), "gmroll", false));

    await this.update({ "system.status.corruption.value": newCorruption });
    if (corruption > 0)
      this.checkCorruption();

  }

  async checkCorruption() {

    if (this.status.corruption.value > this.status.corruption.max) {
      let skill = this.has(game.i18n.localize("NAME.Endurance"), "skill");
      if (skill) {
        this.setupSkill(skill, { title: game.i18n.format("DIALOG.MutateTitle", { test: skill.name }), mutate: true }).then(setupData => {
          this.basicTest(setupData);
        });
      }
      else {
        this.setupCharacteristic("t", { title: game.i18n.format("DIALOG.MutateTitle", { test: game.wfrp4e.config.characteristics["t"] }), mutate: true }).then(setupData => {
          this.basicTest(setupData);
        });
      }
    }
  }

  async handleMutationResult(test) {
    let failed = test.result.outcome == "failure";

    if (failed) {
      let wpb = this.characteristics.wp.bonus;
      let tableText = game.i18n.localize("CHAT.MutateTable") + "<br>" + game.wfrp4e.config.corruptionTables.map(t => `@Table[${t}]<br>`).join("");
      ChatMessage.create(WFRP_Utility$1.chatDataSetup(`
      <h3>${game.i18n.localize("CHAT.DissolutionTitle")}</h3> 
      <p>${game.i18n.localize("CHAT.Dissolution")}</p>
      <p>${game.i18n.format("CHAT.CorruptionLoses", { name: this.name, number: wpb })}
      <p>${tableText}</p>`,
        "gmroll", false));
      this.update({ "system.status.corruption.value": Number(this.status.corruption.value) - wpb });
    }
    else
      ChatMessage.create(WFRP_Utility$1.chatDataSetup(game.i18n.localize("CHAT.MutateSuccess"), "gmroll", false));

  }

  // /** @override */
  // async deleteEmbeddedEntity(embeddedName, data, options = {}) {
  //   if (embeddedName === "OwnedItem")
  //     await this._deleteItemActiveEffects(data);
  //   const deleted = await super.deleteEmbeddedEntity(embeddedName, data, options);
  //   return deleted;
  // }

  async handleExtendedTest(test) {
    let item = this.items.get(test.options.extended).toObject();

    if (game.settings.get("wfrp4e", "extendedTests") && test.result.SL == 0)
      test.result.SL = test.result.roll <= test.result.target ? 1 : -1;

    if (item.system.failingDecreases.value) {
      item.system.SL.current += Number(test.result.SL);
      if (!item.system.negativePossible.value && item.system.SL.current < 0)
        item.system.SL.current = 0;
    }
    else if (test.result.SL > 0)
      item.system.SL.current += Number(test.result.SL);

    let displayString = `${item.name} ${item.system.SL.current} / ${item.system.SL.target} ${game.i18n.localize("SuccessLevels")}`;

    if (item.system.SL.current >= item.system.SL.target) {

      if (getProperty(item, "flags.wfrp4e.reloading")) {
        let actor;
        if (getProperty(item, "flags.wfrp4e.vehicle"))
          actor = WFRP_Utility$1.getSpeaker(getProperty(item, "flags.wfrp4e.vehicle"));

        actor = actor ? actor : this;
        let weapon = actor.items.get(getProperty(item, "flags.wfrp4e.reloading"));
        await weapon.update({ "flags.wfrp4e.-=reloading": null, "system.loaded.amt": weapon.loaded.max, "system.loaded.value": true });
      }

      if (item.system.completion.value == "reset")
        item.system.SL.current = 0;
      else if (item.system.completion.value == "remove") {
        await this.deleteEmbeddedDocuments("Item", [item._id]);
        await this.deleteEffectsFromItem(item._id);
        item = undefined;
      }
      displayString = displayString.concat(`<br><b>${game.i18n.localize("Completed")}</b>`);
    }

    test.result.other.push(displayString);

    if (item)
      await this.updateEmbeddedDocuments("Item", [item]);
  }

  async checkReloadExtendedTest(weapon) {

    if (!weapon.loading)
      return

    let reloadingTest = this.items.get(weapon.getFlag("wfrp4e", "reloading"));

    if (weapon.loaded.amt > 0) {
      if (reloadingTest) {
        await reloadingTest.delete();
        await weapon.update({ "flags.wfrp4e.-=reloading": null });
        ui.notifications.notify(game.i18n.localize("ITEM.ReloadFinish"));
        return;
      }
    }
    else {
      let reloadExtendedTest = duplicate(game.wfrp4e.config.systemItems.reload);

      reloadExtendedTest.name = game.i18n.format("ITEM.ReloadingWeapon", { weapon: weapon.name });
      if (weapon.skillToUse)
        reloadExtendedTest.system.test.value = weapon.skillToUse.name;
      else
        reloadExtendedTest.system.test.value = game.i18n.localize("CHAR.BS");
      reloadExtendedTest.flags.wfrp4e.reloading = weapon.id;

      reloadExtendedTest.system.SL.target = weapon.properties.flaws.reload?.value || 1;

      if (weapon.actor.type == "vehicle") {
        let vehicleSpeaker;
        if (weapon.actor.isToken)
          vehicleSpeaker = {
            token: weapon.actor.token.id,
            scene: weapon.actor.token.parent.id
          };
        else
          vehicleSpeaker = {
            actor: weapon.actor.id
          };
        reloadExtendedTest.flags.wfrp4e.vehicle = vehicleSpeaker;
      }

      if (reloadingTest)
        await reloadingTest.delete();

      let item = await this.createEmbeddedDocuments("Item", [reloadExtendedTest]);
      ui.notifications.notify(game.i18n.format("ITEM.CreateReloadTest", { weapon: weapon.name }));
      await weapon.update({ "flags.wfrp4e.reloading": item[0].id });
    }
  }


  setAdvantage(val) {
    this.update({ "system.status.advantage.value": val });
  }
  modifyAdvantage(val) {
    this.setAdvantage(this.status.advantage.value + val);
  }

  setWounds(val) {
    return this.update({ "system.status.wounds.value": val })
  }
  modifyWounds(val) {
    return this.setWounds(this.status.wounds.value + val)
  }


  showCharging(item) {
    if (item.attackType == "melee")
      return true
  }

  get isMounted() {
    return this.system.isMounted
  }

  get mount() {
    return this.system.mount;

  }

  showDualWielding(weapon) {
    if (!weapon.offhand.value && this.has(game.i18n.localize("NAME.DualWielder"), "talent")) {
      return !this.noOffhand
    }
    return false;
  }


  async addCondition(effect, value = 1) {
    if (typeof (effect) === "string")
      effect = duplicate(game.wfrp4e.config.statusEffects.find(e => e.id == effect));
    if (!effect)
      return "No Effect Found"

    if (!effect.id)
      return "Conditions require an id field"


    let existing = this.hasCondition(effect.id);

    if (existing && !existing.isNumberedCondition)
      return existing
    else if (existing) {
      existing._displayScrollingStatus(true);
      return existing.setFlag("wfrp4e", "value", existing.conditionValue + value)
    }
    else if (!existing) {
      if (game.combat && (effect.id == "blinded" || effect.id == "deafened"))
        effect.flags.wfrp4e.roundReceived = game.combat.round;
      effect.name = game.i18n.localize(effect.name);

      if (Number.isNumeric(effect.flags.wfrp4e.value))
        effect.flags.wfrp4e.value = value;
        
      effect["statuses"] = [effect.id];
      if (effect.id == "dead")
        effect["flags.core.overlay"] = true;
      if (effect.id == "unconscious")
        await this.addCondition("prone");

      delete effect.id;
      return this.createEmbeddedDocuments("ActiveEffect", [effect], {condition: true})
    }
  }

  async removeCondition(effect, value = 1) {
    if (typeof (effect) === "string")
      effect = duplicate(game.wfrp4e.config.statusEffects.find(e => e.id == effect));
    if (!effect)
      return "No Effect Found"

    if (!effect.id)
      return "Conditions require an id field"

    let existing = this.hasCondition(effect.id);

    if (existing && !existing.isNumberedCondition) {
      if (effect.id == "unconscious")
        await this.addCondition("fatigued");
      return existing.delete();
    }
    else if (existing) {
      await existing.setFlag("wfrp4e", "value", existing.conditionValue - value);
      if (existing.conditionValue) // Only display if there's still a condition value (if it's 0, already handled by effect deletion)
        existing._displayScrollingStatus(false);
      //                                                                                                                   Only add fatigued after stunned if not already fatigued
      if (existing.conditionValue == 0 && (effect.id == "bleeding" || effect.id == "poisoned" || effect.id == "broken" || (effect.id == "stunned" && !this.hasCondition("fatigued")))) {
        if (!game.settings.get("wfrp4e", "mooConditions") || !effect.id == "broken") // Homebrew rule prevents broken from causing fatigue
          await this.addCondition("fatigued");
      }

      if (existing.conditionValue <= 0)
        return existing.delete();
    }
  }

  applyFear(value, name = undefined) {
    value = value || 0;
    let fear = duplicate(game.wfrp4e.config.systemItems.fear);
    fear.system.SL.target = value;

    if (name)
      fear.effects[0].flags.wfrp4e.fearName = name;

    return this.createEmbeddedDocuments("Item", [fear]).then(items => {
      this.setupExtendedTest(items[0], {appendTitle : ` - ${items[0].name}`});
    });
  }


  applyTerror(value, name = undefined) {
    value = value || 1;
    let terror = duplicate(game.wfrp4e.config.systemItems.terror);
    terror.flags.wfrp4e.terrorValue = value;
    return game.wfrp4e.utility.applyOneTimeEffect(terror, this)
  }

  awardExp(amount, reason) {
    let experience = duplicate(this.details.experience);
    experience.total += amount;
    experience.log.push({ reason, amount, spent: experience.spent, total: experience.total, type: "total" });
    this.update({ "system.details.experience": experience });
    ChatMessage.create({ content: game.i18n.format("CHAT.ExpReceived", { amount, reason }), speaker: { alias: this.name } });
  }

  _addToExpLog(amount, reason, newSpent, newTotal) {
    if (!newSpent)
      newSpent = this.details.experience.spent;
    if (!newTotal)
      newTotal = this.details.experience.total;

    let expLog = duplicate(this.details.experience.log || []);
    expLog.push({ amount, reason, spent: newSpent, total: newTotal, type: newSpent ? "spent" : "total" });
    return expLog
  }


  async checkSystemEffects() {
    if (game.user.id != WFRP_Utility$1.getActiveDocumentOwner(this)?.id)
    {
      return
    }
    let encumbrance = this.status.encumbrance.state;
    let state;

    if (encumbrance > 3) {
      state = "enc3";
      if (!this.hasSystemEffect(state)) {
        await this.addSystemEffect(state);
        return
      }
      await this.removeSystemEffect("enc2");
      await this.removeSystemEffect("enc1");
    }
    else if (encumbrance > 2) {
      state = "enc2";
      if (!this.hasSystemEffect(state)) {
        await this.addSystemEffect(state);
        return
      }
      await this.removeSystemEffect("enc1");
      await this.removeSystemEffect("enc3");
    }
    else if (encumbrance > 1) {
      state = "enc1";
      if (!this.hasSystemEffect(state)) {
        await this.addSystemEffect(state);
        return
      }
      await this.removeSystemEffect("enc2");
      await this.removeSystemEffect("enc3");
    }
    else {
      await this.removeSystemEffect("enc1");
      await this.removeSystemEffect("enc2");
      await this.removeSystemEffect("enc3");
    }

  }


  async addSystemEffect(key) {
    let systemEffects = game.wfrp4e.utility.getSystemEffects();
    let effect = systemEffects[key];
    if (effect) {
      await this.createEmbeddedDocuments("ActiveEffect", [effect]);
    }
  }

  async removeSystemEffect(key) {
    let effects = this.effects.filter(e => e.statuses.has(key));
    if (effects.length)
      await this.deleteEmbeddedDocuments("ActiveEffect", effects.map(i => i.id));
  }

  hasSystemEffect(key) {
    return this.hasCondition(key) // Same function so just reuse
  }


  /**
   * Creates a chat message with current conditions and penalties to an actor.
   * 
   * @param {String} tokenId  Token id to retrieve token from canvas
   * @param {Object} round    Round object to display round number
   */
  displayStatus(round = undefined, nameOverride) {
    if (round)
      round = game.i18n.format("CondRound", { round: round });

    let displayConditions = this.effects.map(e => {
      if (e.conditionKey && ! e.disabled) {
        return e.name + " " + (e.conditionValue || "")
      }
    }).filter(i => !!i);

    // Aggregate conditions to be easily displayed (bleeding4 and bleeding1 turns into Bleeding 5)

    let chatOptions = {
      rollMode: game.settings.get("core", "rollMode")
    };
    if (["gmroll", "blindroll"].includes(chatOptions.rollMode)) chatOptions["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (chatOptions.rollMode === "blindroll") chatOptions["blind"] = true;
    chatOptions["template"] = "systems/wfrp4e/templates/chat/combat-status.hbs";

    let chatData = {
      name: nameOverride || (this.token ? this.token.name : this.prototypeToken.name),
      conditions: displayConditions,
      modifiers: this.flags.modifier,
      round: round
    };


    return renderTemplate(chatOptions.template, chatData).then(html => {
      chatOptions["user"] = game.user.id;

      // Emit the HTML as a chat message
      chatOptions["content"] = html;
      chatOptions["type"] = 0;
      ChatMessage.create(chatOptions, false);
      return html;
    });
  }

  /**
   * Returns items for new actors: money and skills
   */
  async _getNewActorItems() {

    let basicSkills = await WFRP_Utility$1.allBasicSkills() || [];
    let moneyItems = ((await WFRP_Utility$1.allMoneyItems()) || [])
      .map(m => { // Set money items to descending in value and set quantity to 0
        m.system.quantity.value= 0;
        return m;
      })
      .sort((a, b) => (a.system.coinValue.value >= b.system.coinValue.value) ? -1 : 1)
      || [];

    // If character, automatically add basic skills and money items
    if (this.type == "character")
      return basicSkills.concat(moneyItems)

    // If not a character, ask the user whether they want to add basic skills / money
    else if (this.type == "npc" || this.type == "creature") {
      return new Promise(resolve => {
        new Dialog({
          title: game.i18n.localize("ACTOR.BasicSkillsTitle"),
          content: `<p>${game.i18n.localize("ACTOR.BasicSkillsPrompt")}</p>`,
          buttons: {
            yes: {
              label: game.i18n.localize("Yes"),
              callback: async dlg => {
                resolve(basicSkills.concat(moneyItems));
              }
            },
            no: {
              label: game.i18n.localize("No"),
              callback: async dlg => {
                resolve([]);
              }
            },
          },
          default: 'yes'
        }).render(true);
      })
    }
    else return []
  }

  /**@deprecated in favor of just calling itemTypes */
  getItemTypes(type) {
    return this.itemTypes[type]
  }

  _itemTypes = null;

  get itemTypes()
  {
    if (!this._itemTypes)
    {
      this._itemTypes = super.itemTypes;
    }
    return this._itemTypes
  }

  async clearOpposed() {
    return (await this.update({ "flags.-=oppose": null }));
  }

  /**
   * This function stores temporary active effects on an actor
   * Generally used by effect scripts to add conditional effects
   * that are removed when the source effect is removed
   * 
   * @param {Object} data Active Effect Data
   */
  createConditionalEffect(data)
  {
    let conditionalEffects = foundry.utils.deepClone(this.flags.wfrp4e?.conditionalEffects || []);

    if (!data.id)
    {
      data.id == randomID();
    }

    conditionalEffects.push(data);
    setProperty(this, "flags.wfrp4e.conditionalEffects", conditionalEffects);
  }

  // @@@@@@@@ BOOLEAN GETTERS
  get isUniqueOwner() {
    return game.user.id == game.users.find(u => u.active && (this.ownership[u.id] >= 3 || u.isGM))?.id
  }

  get inCollection() {
    return game.actors && game.actors.get(this.id)
  }

  get hasSpells() {
    return !!this.itemTypes["spell"].length > 0
  }

  get hasPrayers() {
    return !!this.itemTypes["prayer"].length > 0
  }

  get noOffhand() {
    return !this.itemTypes["weapon"].find(i => i.offhand.value)
  }

  get isOpposing() {
    return !!this.flags.oppose
  }

  get currentAreaEffects() 
  {
      return this.effects.contents.filter(e => e.getFlag("wfrp4e", "fromArea"));
  }

  get currentAreas()
  {
      let token = this.getActiveTokens()[0];
      return canvas.templates.placeables.filter(t => AreaHelpers.isInTemplate(token.center, t));
  }

  get auras() 
  {
    return this.items.reduce((acc, item) => acc.concat(item.effects.contents), []).concat(this.effects.contents).filter(e => e.applicationData.type == "aura" && !e.applicationData.targetedAura)
  }

  /**
   * Overriden from foundry to pass true to allApplicableEffects
   */
  get temporaryEffects() 
  {
      const effects = [];
      for ( const effect of this.allApplicableEffects(true) ) 
      {
          if ( effect.active && effect.isTemporary ) {effects.push(effect);}
      }
      return effects;
  }


  speakerData(token) {
    if (this.isToken || token) {
      return {
        token: token?.id || this.token.id,
        scene: token?.parent.id || this.token.parent.id
      }
    }
    else {
      return {
        actor: this.id,
        token: token?.id,
        scene: token?.parent.id
      }
    }
  }

  // @@@@@@@@@@@ COMPUTED GETTERS @@@@@@@@@
  get Species() {
    let species = game.wfrp4e.config.species[this.details.species.value] || this.details.species.value;
    if (this.details.species.subspecies && game.wfrp4e.config.subspecies[this.details.species.value] && game.wfrp4e.config.subspecies[this.details.species.value][this.details.species.subspecies])
      species += ` (${game.wfrp4e.config.subspecies[this.details.species.value][this.details.species.subspecies].name})`;
    else if (this.details.species.subspecies)
      species += ` (${this.details.species.subspecies})`;

    return species
  }

  get sizeNum() {
    return game.wfrp4e.config.actorSizeNums[this.details.size.value]
  }

  get equipPointsUsed() {
    return this.itemTypes["weapon"].reduce((prev, current) => {
      if (current.isEquipped)
        prev += current.twohanded.value ? 2 : 1;
      return prev
    }, 0)
  }

  get equipPointsAvailable() {
    return Number.isNumeric(this.flags.equipPoints) ? this.flags.equipPoints : 2
  }

  get defensive() {

    // Add defensive traits and weapons together
    return this.itemTypes["weapon"].reduce((prev, current) => {
      if (current.isEquipped)
        prev += current.properties.qualities.defensive ? 1 : 0;
      return prev
    }, 0) + this.itemTypes["trait"].reduce((prev, current) => {
      if (current.included)
        prev += current.properties?.qualities?.defensive ? 1 : 0;
      return prev
    }, 0)
  }

  get currentCareer() {
    return this.system.currentCareer
  }

  get passengers() {
    return this.system.passengers.map(p => {
      let actor = game.actors.get(p?.id);
      if (actor)
        return {
          actor: actor,
          linked: actor.prototypeToken.actorLink,
          count: p.count,
          img : WFRP_Utility$1.replacePopoutPath(actor.prototypeToken.texture.src),
          enc: game.wfrp4e.config.actorSizeEncumbrance[actor.details.size.value] * p.count
        }
    })
  }

  get attacker() {
    try {
      if (this.flags.oppose) {
        let opposeMessage = game.messages.get(this.flags.oppose.opposeMessageId); // Retrieve attacker's test result message
        let oppose = opposeMessage.getOppose();
        let attackerMessage = oppose.attackerMessage;
        // Organize attacker/defender data
        if (opposeMessage)
          return {
            speaker: attackerMessage.speaker,
            test: attackerMessage.getTest(),
            messageId: attackerMessage.id,
            img: WFRP_Utility$1.getSpeaker(attackerMessage.speaker).img
          };
        else
          this.update({ "flags.-=oppose": null });
      }
    }
    catch (e) {
      this.update({ "flags.-=oppose": null });
    }

  }


  // Used with Group Advantage
  // Actor is considered in the "Players" group if it is owned by a player or has a Friendly token disposition
  // Otherwise, it is considered in the "Enemies" group
  get advantageGroup() {
    if (this.hasPlayerOwner)
      return "players"
    else if (this.token)
      return this.token.disposition == CONST.TOKEN_DISPOSITIONS.FRIENDLY ? "players" : "enemies"
    else 
      return this.prototypeToken.disposition == CONST.TOKEN_DISPOSITIONS.FRIENDLY ? "players" : "enemies"
  }

  // @@@@@@@@@@@ DATA GETTERS @@@@@@@@@@@@@
  get characteristics() { return this.system.characteristics }
  get status() { return this.system.status }
  get details() { return this.system.details }
  get excludedTraits() { return this.system.excludedTraits }
  get roles() { return this.system.roles }

  // @@@@@@@@@@ DERIVED DATA GETTERS
  get armour() { return this.status.armour }
}

class SocketHandlers  {

    static call(type, payload, userId)
    {
        game.socket.emit("system.wfrp4e", {type, payload, userId});
    }

    static register()
    {
        game.socket.on("system.wfrp4e", async data => 
        {
            if (data.userId == "GM" && game.user.id != game.users.contents.filter(u => u.active).find(u => u.isGM).id) return;
            if (data.userId != game.user.id && data.userId != "ALL") return;

            let result = await this[data.type]({...data.payload}, data.userId);
            if (!data.payload.socketMessageId) return;

            if (!result) {
                result = "success";
            }
            data.payload.socketResult = result;
            SocketHandlers.executeOnGM("updateSocketMessageResult", data.payload);
        });
    }
    
    static executeOnGM(type, payload) {
        if (game.user.isGM) {
            this[type](payload);
        } else {
            SocketHandlers.call(type, payload, "GM");
        }
    }

    static updateSocketMessageResult(payload) {
        let message = game.messages.get(payload.socketMessageId);
        if (message && payload.socketResult) {
            message.setFlag("wfrp4e", "socketResult", payload.socketResult);
        }
    }

    static morrslieb(payload){
        canvas.draw();
    }

    static async target(payload){
        let scene = game.scenes.get(payload.scene);
        let token = scene.tokens.get(payload.target);
        await token.actor.update({ "flags.oppose": payload.opposeFlag });
    }

    static async updateMsg(payload){
        const msg = game.messages.get(payload.id);
        await msg.update(payload.updateData);
        return "success"
    }

    static async deleteMsg(payload) {
        const msg = game.messages.get(payload.id);
        if (msg) {
            await msg.delete();
        }
    }

    static async applyEffect({effectUuids, effectData, actorUuid, messageId})
{
        let result = await fromUuidSync(actorUuid)?.applyEffect({effectUuids, effectData, messageId});
        return result;
    }

    static async changeGroupAdvantage(payload) {
        let advantage = game.settings.get("wfrp4e", "groupAdvantageValues");
        advantage.players = payload.players;        
        await game.settings.set("wfrp4e", "groupAdvantageValues", advantage);
    }

    static async createActor(payload) {
        let id = payload.id;
        let actorData = payload.data;

        // Give ownership to requesting actor
        actorData.ownership = {
            default: 0,
            [id] : 3
        };
        let actor = await Actor.implementation.create(actorData);
        let items = payload.items;
        await actor.createEmbeddedDocuments("Item", items);
        return actor.id;        
    }

    static async setupSocket(payload) {
        let actorId = payload.actorId; 
        let type = payload.type;
        let options = payload.options || {};
        let messageId = payload.messageId;
        let actor = game.actors.get(actorId);
        let owner = game.wfrp4e.utility.getActiveDocumentOwner(actor);

        let test;
        if (owner.id == game.user.id) {
            if (canvas.scene) { 
                if (options.gmTargets) {
                    game.user.updateTokenTargets(options.gmTargets);
                    game.user.broadcastActivity({targets: options.gmTargets});
                } else {
                    game.user.updateTokenTargets([]);
                    game.user.broadcastActivity({targets: []});
                }
            }
            if (type == "setupCharacteristic") {
                let characteristicId = payload.characteristicId;
                test = await actor.setupCharacteristic(characteristicId, options);
            } else if (type == "setupSkill") {
                let skillName = payload.skillName;
                test = await actor.setupSkill(skillName, options);
            } else if (type == "setupWeapon") {
                let weapon = payload.weapon;
                test = await actor.setupWeapon(weapon, options);
            } else if (type == "setupCast") {
                let spell = payload.spell;
                test = await actor.setupCast(spell, options);
            } else if (type == "setupChannell") {
                let spell = payload.spell;
                test = await actor.setupChannell(spell, options);
            } else if (type == "setupPrayer") {
                let prayer = payload.prayer;
                test = await actor.setupPrayer(prayer, options);
            } else if (type == "setupTrait") {
                let trait = payload.trait;
                test = await actor.setupTrait(trait, options);
            }
            if (owner.isGM && test) {
                await test.roll();
            }
            let message = game.messages.get(messageId);
            if (test) {
                await message.update({"flags.data.test": test});
            } else {
                await message.delete();
            }
        }
    }

    /**
     * Not used by sockets directly, but is called when a socket handler should be executed by
     * the specific user which owns a document. Usually used to invoke tests from other users
     * for their assigned Actor. 
     * 
     * @param {Document} document Document on which to test if the user is owner or not
     * @param {String} type Type of socket handler
     * @param {Object} payload Data for socket handler, should generally include document UUID 
     * @returns 
     */
    static executeOnOwner(document, type, payload) {
        let ownerUser = game.wfrp4e.utility.getActiveDocumentOwner(document);
        if (game.user.id == ownerUser.id) {
            this[type](payload);
        }
        ui.notifications.notify(game.i18n.format("SOCKET.SendingSocketRequest", { name: ownerUser.name }));
        SocketHandlers.call(type, payload, ownerUser.id);
    }

    static async executeOnUserAndWait(userId, type, payload) {
        let result;
        if (game.user.id == userId || (userId == "GM" && game.user.isGM)) {
            result = await this[type](payload);
        } else {
            ui.notifications.notify(game.i18n.format("SOCKET.SendingSocketRequest", { name: userId }));
            let msg = await SocketHandlers.createSocketRequestMessage(owner, content);
            payload.socketMessageId = msg.id;
            SocketHandlers.call(type, payload, userId);
            do {
                await WFRP_Utility.sleep(250);
                msg = game.messages.get(msg.id);
                result = msg?.getFlag("wfrp4e", "socketResult");
            } while (msg && !result);
            if (msg && game.user.isGM) {
                message.delete();
            } else {
                SocketHandlers.executeOnGM("deleteMsg", { "id": message.id });
            }
        }
        return result;
    }

    static async executeOnOwnerAndWait(document, type, payload) {
        let ownerUser = game.wfrp4e.utility.getActiveDocumentOwner(document);
        return await SocketHandlers.executeOnUserAndWait(ownerUser.id, type, payload);
    }


    static async createSocketRequestMessage(owner, content) {
        let chatData = {
          content: `<p class='requestmessage'><b><u>${owner.name}</u></b>: ${content}</p?`,
          whisper: ChatMessage.getWhisperRecipients("GM")
        };
        if (game.user.isGM) {
          chatData.user = owner;
        }
        let msg = await ChatMessage.create(chatData);
        return msg;
    }
}

class TestWFRP {
  constructor(data, actor) {
    if (!data)
      data = {};
    this.data = {
      preData: {
        title: data.title,
        SL: data.SL,
        roll: data.roll,
        target: data.target,
        rollClass: this.constructor.name,
        testModifier: data.modifier || 0,
        testDifficulty: (typeof data.difficulty == "string" ? game.wfrp4e.config.difficultyModifiers[data.difficulty] : data.difficulty) || 0,
        testDifficultyLabel: (typeof data.testDifficultyLabel == "string" ? data.testDifficultyLabel : ""),
        successBonus: data.successBonus || 0,
        slBonus: data.slBonus || 0,
        hitLocation: data.hitLocation != "none" && data.hitLocation || false,
        item: data.item,
        diceDamage: data.diceDamage,
        options: data.options || {},
        other: data.other || [],
        canReverse: data.canReverse || false,
        postOpposedModifiers: data.postOpposedModifiers || { modifiers: 0, SL: 0 },
        additionalDamage: data.additionalDamage || 0,
        selectedHitLocation : typeof data.hitLocation == "string" ? data.hitLocation : "", // hitLocation could be boolean
        hitLocationTable : data.hitLocationTable,
        prefillTooltip : data.prefillTooltip,
        prefillTooltipCount : data.prefillTooltipCount
      },
      result: {
        roll: data.roll,
        description: "",
        tooltips: {}
      },
      context: {
        rollMode: data.rollMode,
        reroll: false,
        edited: false,
        speaker: data.speaker,
        targets: data.targets,
        chatOptions: data.chatOptions,
        unopposed : data.unopposed,
        defending : data.defending,

        messageId: data.messageId,
        opposedMessageIds : data.opposedMessageIds || [],
        fortuneUsedReroll: data.fortuneUsedReroll,
        fortuneUsedAddSL: data.fortuneUsedAddSL,
      }
    };

    if (this.context.speaker && this.actor.isOpposing && this.context.targets.length)
    {
      ui.notifications.notify(game.i18n.localize("TargetingCancelled"));
      this.context.targets = [];
    }

    if (!this.context.speaker && actor)
      this.context.speaker = actor.speakerData();
  }

  computeTargetNumber() {
    if (this.preData.target)
      this.data.result.target = this.preData.target;
    else
      this.data.result.target += this.targetModifiers;
  }

  async runPreEffects() {
    if (!this.context.unopposed)
    {
      await Promise.all(this.actor.runScripts("preRollTest", { test: this, chatOptions: this.context.chatOptions }));
      if (this.item instanceof Item)
      {
        await Promise.all(this.item.runScripts("preRollTest", { test: this, chatOptions: this.context.chatOptions }));
      }

    }
  }

  async runPostEffects() {
    if (!this.context.unopposed)
    {
      await Promise.all(this.actor.runScripts("rollTest", { test: this, chatOptions: this.context.chatOptions }));
      if (this.item instanceof Item)
      {
        await Promise.all(this.item.runScripts("rollTest", { test: this, chatOptions: this.context.chatOptions }));
      }
      Hooks.call("wfrp4e:rollTest", this, this.context.chatOptions);
    }
  }

  async roll() {
    await this.runPreEffects();

    this.reset();
    if (!this.preData.item)
      throw new Error(game.i18n.localize("ERROR.Property"))
    if (!this.context.speaker)
      throw new Error(game.i18n.localize("ERROR.Speaker"))

    await this.rollDices();
    await this.computeResult();

    await this.runPostEffects();
    await this.postTest();

    // Do not render chat card or compute oppose if this is a dummy unopposed test
    if (!this.context.unopposed)
    {
      await this.renderRollCard();
      await this.handleOpposed();
    }

    WFRP_Utility$1.log("Rolled Test: ", undefined, this);
    return this
  }

  async reroll() {
    this.context.previousResult = this.result;
    this.context.reroll = true;
    delete this.result.roll;
    delete this.result.hitloc;
    delete this.preData.hitloc;
    delete this.preData.roll;
    delete this.preData.SL;
    this.context.messageId = "";

    await this.roll();
  }

  addSL(SL) {
    this.context.previousResult = duplicate(this.result);
    this.preData.SL = Math.trunc(this.result.SL) + SL;
    this.preData.slBonus = 0;
    this.preData.successBonus = 0;
    this.preData.roll = Math.trunc(this.result.roll);
    if (this.preData.hitLocation)
      this.preData.hitloc = this.result.hitloc.roll;

    this.roll();
  }

  /**
     * Provides the basic evaluation of a test.
     * 
     * This function, when given the necessary data (target number, SL bonus, etc.) provides the
     * basic test evaluation - rolling the test (if not already given), determining SL, success, description, critical/fumble if needed.
     * 
     * @param {Object} this.data  Test info: target number, SL bonus, success bonus, (opt) roll, etc
     */
  async computeResult() {
    let automaticSuccess = game.settings.get("wfrp4e", "automaticSuccess");
    let automaticFailure = game.settings.get("wfrp4e", "automaticFailure");
    this.computeTargetNumber();
    let successBonus = this.preData.successBonus;
    let slBonus = this.preData.slBonus + this.preData.postOpposedModifiers.SL;
    let target = this.result.target;
    let outcome;

    let description = "";

    if (this.preData.canReverse) {
      let reverseRoll = this.result.roll.toString();
      if (this.result.roll >= automaticFailure || (this.result.roll > target && this.result.roll > automaticSuccess)) {
        if (reverseRoll.length == 1)
          reverseRoll = reverseRoll[0] + "0";
        else {
          reverseRoll = reverseRoll[1] + reverseRoll[0];
        }
        reverseRoll = Number(reverseRoll);
        if (reverseRoll <= automaticSuccess || reverseRoll <= target) {
          this.result.roll = reverseRoll;
          this.result.other.push(game.i18n.localize("ROLL.Reverse"));
        }
      }
    }


    let SL;
    if (this.preData.SL == 0)
      SL = this.preData.SL;
    else
      SL = this.preData.SL || ((Math.floor(target / 10) - Math.floor(this.result.roll / 10)) + slBonus); // Use input SL if exists, otherwise, calculate from roll (used for editing a test result)


    // Test determination logic can be complicated due to SLBonus
    // SLBonus is always applied, but doesn't change a failure to a success or vice versa
    // Therefore, in this case, a positive SL can be a failure and a negative SL can be a success
    // Additionally, the auto-success/failure range can complicate things even more.
    // ********** Failure **********
    if (this.result.roll >= automaticFailure || (this.result.roll > target && this.result.roll > automaticSuccess)) {
      description = game.i18n.localize("ROLL.Failure");
      outcome = "failure";
      if (this.result.roll >= 96 && SL > -1)
        SL = -1;

      switch (Math.abs(Number(SL))) {
        case 6:
          description = game.i18n.localize("ROLL.AstoundingFailure");
          break;

        case 5:
        case 4:
          description = game.i18n.localize("ROLL.ImpressiveFailure");
          break;

        case 3:
        case 2:
          break;

        case 1:
        case 0:
          description = game.i18n.localize("ROLL.MarginalFailure");
          break;

        default:
          if (Math.abs(Number(SL)) > 6)
            description = game.i18n.localize("ROLL.AstoundingFailure");
      }
      if (SL > 0) {
        description = game.i18n.localize("ROLL.MarginalFailure");
        SL = "+" + SL.toString();
      }
      if (SL == 0)
        SL = "-" + SL.toString();


      if (this.options.engagedModifier) {
        let unmodifiedTarget = target - this.options.engagedModifier;
        if (this.result.roll <= unmodifiedTarget) {
          this.result.other.push(game.i18n.localize("ROLL.HitAnotherEngagedTarget"));
        }
      }
  
    }

    // ********** Success **********
    else if (this.result.roll <= automaticSuccess || this.result.roll <= target) {
      description = game.i18n.localize("ROLL.Success");
      outcome = "success";
      if (game.settings.get("wfrp4e", "fastSL")) {
        let rollString = this.result.roll.toString();
        if (rollString.length == 2)
          SL = Number(rollString.split('')[0]);
        else
          SL = 0;
        SL += slBonus;

        if (Number.isNumeric(this.preData.SL))
        {
          SL = this.preData.SL;
        }
      }
      SL += successBonus;
      if (this.result.roll <= automaticSuccess && SL < 1 && !this.context.unopposed)
        SL = 1;



      if (!game.settings.get("wfrp4e", "mooRangedDamage")) {
        // If size modifiers caused a success, SL becomes 0
        if (this.options.sizeModifier) {
          let unmodifiedTarget = target - this.options.sizeModifier;
          if (this.result.roll > unmodifiedTarget) {
            SL = 0;
            this.result.other.push(game.i18n.localize("ROLL.SizeCausedSuccess"));
          }
        }
      }

      switch (Math.abs(Number(SL))) {
        case 6:
          description = game.i18n.localize("ROLL.AstoundingSuccess");
          break;

        case 5:
        case 4:
          description = game.i18n.localize("ROLL.ImpressiveSuccess");
          break;

        case 3:
        case 2:
          break;

        case 1:
        case 0:
          description = game.i18n.localize("ROLL.MarginalSuccess");
          break;

        default:
          if (Math.abs(Number(SL)) > 6)
            description = game.i18n.localize("ROLL.AstoundingSuccess");
      }
      if (SL < 0)
        description = game.i18n.localize("ROLL.MarginalSuccess");

      // Add 1 SL for each whole 10 the target number is above 100 (120 target: +2 SL) if the option is selected
      if (game.settings.get("wfrp4e", "testAbove100")) {
        if (target > 100) {
          let addSL = Math.floor((target - 100) / 10);
          SL += addSL;
        }
      }

      // Add a + sign if succeeded
      if (SL >= 0)
        SL = "+" + SL.toString();

    }

    this.result.target = target;
    this.result.SL = SL;
    this.result.description = description;
    this.result.outcome = outcome;


    if (this.options.context) {
      if (this.options.context.general)
        this.result.other = this.result.other.concat(this.options.context.general);
      if (this.result.outcome == "failure" && this.options.context.failure)
        this.result.other = this.result.other.concat(this.options.context.failure);
      if (this.result.outcome == "success" && this.options.context.success)
        this.result.other = this.result.other.concat(this.options.context.success);
    }


    if (this.preData.hitLocation) {

      // Called Shots
      if (this.preData.selectedHitLocation != "roll") // selectedHitLocation is possibly "none" but if so, preData.hitLocation would be false (see constructor) so this won't execute
      {
        this.result.hitloc = game.wfrp4e.tables.hitLocKeyToResult(this.preData.selectedHitLocation);
      }

      // Pre-set hitloc (e.g. editing a test)
      if (this.preData.hitloc)
      {
        if (Number.isNumeric(this.preData.hitloc))
          this.result.hitloc = await game.wfrp4e.tables.rollTable("hitloc", { lookup: this.preData.hitloc, hideDSN: true });
      }

      // No defined hit loc, roll for one
      if (!this.result.hitloc)
        this.result.hitloc = await game.wfrp4e.tables.rollTable("hitloc", { hideDSN: true });

      this.result.hitloc.roll = (0, eval)(this.result.hitloc.roll); // Cleaner number when editing chat card
      this.result.hitloc.description = game.i18n.localize(this.result.hitloc.description);

      if (this.preData.selectedHitLocation && this.preData.selectedHitLocation != "roll")
      {
        this.result.hitloc.description = this.preData.hitLocationTable[this.preData.selectedHitLocation] + ` (${game.i18n.localize("ROLL.CalledShot")})`;
      }
      
    }

    let roll = this.result.roll;
    // If hit location is being ussed, we can assume we should lookup critical hits
    if (this.preData.hitLocation) {
      if ((roll > target && roll % 11 == 0) || roll == 100 || roll == 99) {
        this.result.color_red = true;
        this.result.fumble = game.i18n.localize("Fumble");
      }
      else if (roll <= target && roll % 11 == 0) {
        this.result.color_green = true;
        this.result.critical = game.i18n.localize("Critical");
      }
    }

    // If optional rule of criticals/fumbles on all tessts - assign Astounding Success/Failure accordingly
    if (game.settings.get("wfrp4e", "criticalsFumblesOnAllTests") && !this.preData.hitLocation) {
      if ((roll > target && roll % 11 == 0) || roll == 100 || roll == 99) {
        this.result.color_red = true;
        this.result.description = game.i18n.localize("ROLL.AstoundingFailure");
      }
      else if (roll <= target && roll % 11 == 0) {
        this.result.color_green = true;
        this.result.description = game.i18n.localize("ROLL.AstoundingSuccess");
      }
    }
    return this.result
  }


  // Function that all tests should go through after the main roll
  async postTest() {

    if (this.result.critical && this.item.properties?.qualities.warpstone) {
      this.result.other.push(`@Corruption[minor]{Minor Exposure to Corruption}`);
    }
    
    //@HOUSE
    if (game.settings.get("wfrp4e", "mooCriticalMitigation") && this.result.critical) {
      game.wfrp4e.utility.logHomebrew("mooCriticalMitigation");
      try {
        let target = this.targets[0];
        if (target) {
          let AP = target.status.armour[this.result.hitloc.result].value;
          if (AP) {
            this.result.critModifier = -10 * AP;
            this.result.critical += ` (${this.result.critModifier})`;
            this.result.other.push(`Critical Mitigation: Damage AP on target's ${this.result.hitloc.description}`);
          }
        }
      }
      catch (e) {
        game.wfrp4e.utility.log("Error appyling homebrew mooCriticalMitigation: " + e);
      }
    }
    //@/HOUSE

    if (this.options.corruption) {
      await this.actor.handleCorruptionResult(this);
    }
    if (this.options.mutate) {
      await this.actor.handleMutationResult(this);
    }

    if (this.options.extended) {
      await this.actor.handleExtendedTest(this);
    }

    if (this.options.income) {
      await this.actor.handleIncomeTest(this);
    }

    if (this.options.rest) {
      this.result.woundsHealed = Math.max(Math.trunc(this.result.SL) + this.options.tb, 0);
      this.result.other.push(`${this.result.woundsHealed} ${game.i18n.localize("Wounds Healed")}`);
    }
  }

  async handleSoundContext(chatOptions) 
  {
    
    try {
      let contextAudio = await WFRP_Audio.MatchContextAudio(WFRP_Audio.FindContext(this));
      chatOptions.sound = contextAudio.file || chatOptions.sound;
    }
    catch
    { }
  }

  /**
   * Handles opposed context - if actor has been targeted, roll defense. If this test has targets, roll attack
   * Test objects may have one or more opposed test message IDs. If these IDs exist, that means this test is
   * either rerolled, edited, etc. and the opposed result needs to know of the new test (via updating message ID). 
   * The opposed test may also need to be recalculated if the defender test exists
   */
  async handleOpposed() {

    // If the actor has been targeted - roll defense
    if (this.actor.isOpposing || this.context.defending)
    {
      let opposeMessage;
      if (this.context.defending) // Rehandling a previous defense roll
      {
        opposeMessage = this.opposedMessages[0];
      }
      else
      {
        this.context.defending = true; // If the test is handled again after the initial roll, the actor flag doesn't exist anymore, need a way to know we're still defending
        opposeMessage = game.messages.get(this.actor.flags.oppose.opposeMessageId);
        this.context.opposedMessageIds.push(opposeMessage.id); // Maintain a link to the opposed message
      }
      
      // Get oppose message, set this test's message as defender, compute result
      let oppose = opposeMessage.getOppose();
      await oppose.setDefender(this.message);
      await oppose.computeOpposeResult();
      await this.actor.clearOpposed();
      await this.updateMessageFlags();

      let test = oppose.attacker.getFlag("wfrp4e", "offHandData");
      if (test) {
        await oppose.attacker.update({ "flags.wfrp4e.-=offHandData": null });
        test = game.wfrp4e.rolls.TestWFRP.recreate(test.data);
        if (oppose.opposeResult.winner == "attacker") {
          let offhandWeapon = oppose.attacker.getItemTypes("weapon").find(w => w.offhand.value);

          let userOwner = WFRP_Utility$1.getActiveDocumentOwner(oppose.attacker);
          let targetId = game.canvas.tokens.placeables.find(x => x.actor.id == oppose.defender.id).id;
          userOwner.updateTokenTargets([targetId]);
          userOwner.broadcastActivity({targets: [targetId]});
         
          await WFRP_Utility$1.sleep(1000);
          let offHandReverseRoll;
          if (test.result.roll % 11 == 0 || test.result.roll == 100) {
            offHandReverseRoll = undefined;
          } else {
            let offhandRoll = test.result.roll.toString();
            if (offhandRoll.length == 1)
              offhandRoll = offhandRoll[0] + "0";
            else
              offhandRoll = offhandRoll[1] + offhandRoll[0];
              offHandReverseRoll = Number(offhandRoll);
          }
          test = await oppose.attacker.setupWeapon(offhandWeapon, {gmTargets: [targetId], appendTitle: ` (${game.i18n.localize("SHEET.Offhand")})`, offhand: true, offhandReverse: offHandReverseRoll });
          await test.roll();
        }
      }
    }
    else // if actor is attacking - rerolling old test. 
    {
      if (this.opposedMessages.length)
      {
        for (let message of this.opposedMessages) {
          let oppose = message.getOppose();
          await oppose.setAttacker(this.message); // Make sure the opposed test is using the most recent message from this test
          if (oppose.defenderTest) // If defender has rolled (such as if this test was rerolled or edited after the defender rolled) - recompute opposed test
            await oppose.computeOpposeResult();
        }
      }
      else { // actor is attacking - new test
        // For each target, create opposed test messages, save those message IDs in this test.
        for (let token of this.context.targets.map(t => WFRP_Utility$1.getToken(t))) {
          await this.createOpposedMessage(token);
        }
      }
    }
  }

  // Create a test from already formed data
  static recreate(data) {
    let test = new game.wfrp4e.rolls[data.preData.rollClass]();
    test.data = data;
    test.computeTargetNumber();
    return test
  }

  /**
   * Start a dice roll
   * Used by the rollTest method and its overrides
   * @param {Object} testData
   */
  async rollDices() {
    if (isNaN(this.preData.roll)) {
      let roll = await new Roll("1d100").roll({ async: true });
      await this._showDiceSoNice(roll, this.context.rollMode || "roll", this.context.speaker);
      this.result.roll = roll.total;
    }
    else
      this.result.roll = this.preData.roll;
  }

  reset() {
    this.data.result = mergeObject({
      roll: undefined,
      description: "",
      tooltips: {},
      other: []
    }, this.preData);
  }

  /** Take roll data and display it in a chat card template.
 * @param {Object} chatOptions - Object concerning display of the card like the template or which actor is testing
 * @param {Object} testData - Test results, values to display, etc.
 * @param {Object} rerenderMessage - Message object to be updated, instead of rendering a new message
 */
  async renderRollCard({ newMessage = false } = {}) {

    let chatOptions = this.context.chatOptions;

    await this.handleSoundContext(chatOptions);

    // Blank if manual chat cards
    if (game.settings.get("wfrp4e", "manualChatCards") && !this.message)
      this.result.roll = this.result.SL = null;

    if (game.modules.get("dice-so-nice") && game.modules.get("dice-so-nice").active && chatOptions.sound?.includes("dice"))
      chatOptions.sound = undefined;

    let chatData = {
      title: chatOptions.title,
      test: this,
      hideData: game.user.isGM
    };


    if (this.context.targets.length) {
      chatData.title += ` - ${game.i18n.localize("Opposed")}`;
    }

    ChatMessage.applyRollMode(chatOptions, chatOptions.rollMode);

    let html = await renderTemplate(chatOptions.template, chatData);

    if (newMessage || !this.message) {
      // If manual chat cards, convert elements to blank inputs
      if (game.settings.get("wfrp4e", "manualChatCards")) {
        let blank = $(html);
        let elementsToToggle = blank.find(".display-toggle");

        for (let elem of elementsToToggle) {
          if (elem.style.display == "none")
            elem.style.display = "";
          else
            elem.style.display = "none";
        }
        html = blank.html();
      }

      chatOptions["content"] = html;
      if (chatOptions.sound)
        WFRP_Utility$1.log(`Playing Sound: ${chatOptions.sound}`);
      let message = await ChatMessage.create(duplicate(chatOptions));
      this.context.messageId = message.id;
      await this.updateMessageFlags();
    }
    else // Update message 
    {
      // Emit the HTML as a chat message
      chatOptions["content"] = html;
      // if (chatOptions.sound) {
      //   console.log(`wfrp4e | Playing Sound: ${chatOptions.sound}`)
      //   AudioHelper.play({ src: chatOptions.sound }, true) // Play sound manually as updating doesn't trigger it
      // }

      // Update Message if allowed, otherwise send a request to GM to update
      if (game.user.isGM || this.message.isAuthor) {
        await this.message.update(chatOptions);
      }
      else {
        await SocketHandlers.executeOnUserAndWait("GM", "updateMsg", { id: this.message.id, updateData : chatOptions });
      }
      await this.updateMessageFlags();
    }
  }



  // Update message data without rerendering the message content
  async updateMessageFlags(updateData = {}) {
    let data = mergeObject(this.data, updateData, { overwrite: true });
    //TODO: CZY TO POTRZEBNE?
    //if (data.result?.options?.weapon?.effects) {
    //  data.result.options.weapon = data.result.options.weapon.toObject();
    //  delete data.result.options.weapon.effects;
    //}
    //if (data.preData?.options?.weapon?.effects) {
    //  data.preData.options.weapon = data.preData.options.weapon.toObject();
    //  delete data.preData.options.weapon.effects;
    //}
    //END OF TODO
    let update = { "flags.testData": data };
    
    if (this.message && game.user.isGM)
      await this.message.update(update);

    else if (this.message) {
      await SocketHandlers.executeOnUserAndWait("GM", "updateMsg", { id: this.message.id, updateData : update });
    }
  }


  async createOpposedMessage(token) {
    let oppose = new OpposedWFRP();
    await oppose.setAttacker(this.message);
    let opposeMessageId = await oppose.startOppose(token);
    if (opposeMessageId) {
      this.context.opposedMessageIds.push(opposeMessageId);
    }
    await this.updateMessageFlags();
  }



  /**
   * Add support for the Dice So Nice module
   * @param {Object} roll 
   * @param {String} rollMode 
   */
  async _showDiceSoNice(roll, rollMode, speaker) {
    if (game.modules.get("dice-so-nice") && game.modules.get("dice-so-nice").active) {

      if (game.settings.get("dice-so-nice", "hideNpcRolls")) {
        let actorType = null;
        if (speaker.actor)
          actorType = game.actors.get(speaker.actor).type;
        else if (speaker.token && speaker.scene)
          actorType = game.scenes.get(speaker.scene).tokens.get(speaker.token).actor.type;
        if (actorType != "character")
          return;
      }

      let whisper = null;
      let blind = false;
      let sync = true;
      switch (rollMode) {
        case "blindroll": //GM only
          blind = true;
        case "gmroll": //GM + rolling player
          let gmList = game.users.filter(user => user.isGM);
          let gmIDList = [];
          gmList.forEach(gm => gmIDList.push(gm.id));
          whisper = gmIDList;
          break;
        case "selfroll":
          sync = false;
          break;
        case "roll": //everybody
          let userList = game.users.filter(user => user.active);
          let userIDList = [];
          userList.forEach(user => userIDList.push(user.id));
          whisper = userIDList;
          break;
      }
      await game.dice3d.showForRoll(roll, game.user, sync, whisper, blind);
    }
  }

  // @@@@@@@ Overcast functions placed in root class because it is used by both spells and prayers @@@@@@@
  async _overcast(choice) {
    let overcastData = this.result.overcast;

    if (!overcastData.available)
      return overcastData

    if (typeof overcastData.usage[choice].initial != "number")
      return overcastData

    switch (choice) {
      case "range":
        overcastData.usage[choice].current += overcastData.usage[choice].initial;
        break
      case "target":
        overcastData.usage[choice].current += overcastData.usage[choice].initial;
        break
      case "duration":
        overcastData.usage[choice].current += overcastData.usage[choice].initial;
        break
      case "other":
        if (overcastData.valuePerOvercast.type == "value")
          overcastData.usage[choice].current += overcastData.valuePerOvercast.value;
        else if (overcastData.valuePerOvercast.type == "SL")
          overcastData.usage[choice].current += (parseInt(this.result.SL) + (parseInt(this.item.computeSpellPrayerFormula(undefined, false, overcastData.valuePerOvercast.additional)) || 0));
        else if (overcastData.valuePerOvercast.type == "characteristic")
          overcastData.usage[choice].current += (overcastData.usage[choice].increment || 0); // Increment is specialized storage for characteristic data so we don't have to look it up
        break
    }
    overcastData.usage[choice].count++;
    let sum = 0;
    for (let overcastType in overcastData.usage)
      if (overcastData.usage[overcastType].count)
        sum += overcastData.usage[overcastType].count;

    overcastData.available = overcastData.total - sum;

    //@HOUSE 
    if (game.settings.get("wfrp4e", "mooOvercasting") && this.spell) {
      game.wfrp4e.utility.logHomebrew("mooOvercasting");

      let spent = (game.settings.get("wfrp4e-eis", "dharRules") && game.wfrp4e.config.magicWind[this.spell.lore.value] == "Dhar") ? 1 : 2;
      this.result.SL = `+${this.result.SL - spent}`;
      await this.calculateDamage();
    }
    //@/HOUSE
    
    await this.updateMessageFlags();
    await this.renderRollCard();
  }

  async _overcastReset() {
    let overcastData = this.result.overcast;
    for (let overcastType in overcastData.usage) {
      if (overcastData.usage[overcastType].count) {
        overcastData.usage[overcastType].count = 0;
        overcastData.usage[overcastType].current = overcastData.usage[overcastType].initial;
      }
    }
    //@HOUSE 
    if (game.settings.get("wfrp4e", "mooOvercasting")) {
      game.wfrp4e.utility.logHomebrew("mooOvercasting");
      let multiplier = (game.settings.get("wfrp4e-eis", "dharRules") && game.wfrp4e.config.magicWind[this.spell.lore.value] == "Dhar") ? 1 : 2;
      this.result.SL = `+${Number(this.result.SL) + (multiplier * (overcastData.total - overcastData.available))}`;
      await this.calculateDamage();
    }
    //@/HOUSE
    overcastData.available = overcastData.total;
    await this.updateMessageFlags();
    await this.renderRollCard();
  }

  _handleMiscasts(miscastCounter) {

    if(this.preData.unofficialGrimoire) {
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
      let controlIngredient = this.preData.unofficialGrimoire.ingredientMode == 'control'; 
      if (miscastCounter == 1) {
          if (this.hasIngredient && controlIngredient)
            this.result.nullminormis = game.i18n.localize("ROLL.MinorMis");
          else {
            this.result.minormis = game.i18n.localize("ROLL.MinorMis");
          }
        }
        else if (miscastCounter == 2) {
          if (this.hasIngredient && controlIngredient) {
            this.result.nullmajormis = game.i18n.localize("ROLL.MajorMis");
            this.result.minormis = game.i18n.localize("ROLL.MinorMis");
          }
          else {
            this.result.majormis = game.i18n.localize("ROLL.MajorMis");
          }
        }
        else if (miscastCounter == 3) {
          if (this.hasIngredient && controlIngredient) {
            this.result.nullcatastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
            this.result.majormis = game.i18n.localize("ROLL.MajorMis");
          }
          else
            this.result.catastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
         }
         else if (miscastCounter > 3) {
          this.result.catastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
         }
      } else {
      if (miscastCounter == 1) {
        if (this.hasIngredient)
          this.result.nullminormis = game.i18n.localize("ROLL.MinorMis");
        else {
          this.result.minormis = game.i18n.localize("ROLL.MinorMis");
        }
      }
      else if (miscastCounter == 2) {
        if (this.hasIngredient) {
          this.result.nullmajormis = game.i18n.localize("ROLL.MajorMis");
          this.result.minormis = game.i18n.localize("ROLL.MinorMis");
        }
        else {
          this.result.majormis = game.i18n.localize("ROLL.MajorMis");
        }
      }
      else if (!game.settings.get("wfrp4e", "mooCatastrophicMiscasts") && miscastCounter >= 3)
        this.result.majormis = game.i18n.localize("ROLL.MajorMis");
  
      //@HOUSE
      else if (game.settings.get("wfrp4e", "mooCatastrophicMiscasts") && miscastCounter >= 3) {
        game.wfrp4e.utility.logHomebrew("mooCatastrophicMiscasts");
        if (this.hasIngredient) {
          this.result.nullcatastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
          this.result.majormis = game.i18n.localize("ROLL.MajorMis");
        }
        else {
          this.result.catastrophicmis = game.i18n.localize("ROLL.CatastrophicMis");
        }
      }
      //@/HOUSE
    }
  }

  get message() {
    return game.messages.get(this.context.messageId)
  }
  get isOpposed() {
    return this.context.opposedMessageIds.length > 0
  }
  get opposedMessages() {
    return this.context.opposedMessageIds.map(id => game.messages.get(id))
  }


  get fortuneUsed() {
    return { reroll: this.context.fortuneUsedReroll, SL: this.context.fortuneUsedAddSL }
  }


  get damageEffects() 
  {
      return this.item.damageEffects;
  }

  get targetEffects() 
  {
      return this.item.targetEffects;
  }

  get areaEffects() 
  {
      return this.item.areaEffects;
  }
  

  get targetModifiers() {
    return this.preData.testModifier + this.preData.testDifficulty + (this.preData.postOpposedModifiers.target || 0)
  }

  get succeeded() {
    return this.result.outcome == "success"
  }

  get isCritical() {
    return this.result.critical
  }

  get isFumble() {
    return this.result.fumble
  }

  get useMount() {
    return this.item.attackType == "melee" && this.actor.isMounted && this.actor.mount && this.result.charging
  }
  
  get target() { return this.data.result.target }
  get successBonus() { return this.data.preData.successBonus }
  get slBonus() { return this.data.preData.slBonus }
  get damage() { return this.data.result.damage }
  get hitloc() { return this.data.result.hitloc }
  get type() { return this.data.type }
  get size() { return this.useMount ? this.actor.mount.details.size.value : this.actor.details.size.value }
  get options() { return this.data.preData.options }
  get outcome() { return this.data.result.outcome }
  get result() { return this.data.result }
  get preData() { return this.data.preData }
  get context() { return this.data.context }
  get actor() { return WFRP_Utility$1.getSpeaker(this.context.speaker) }
  get token() { return WFRP_Utility$1.getToken(this.context.speaker) }

  get item() {
    if (typeof this.data.preData.item == "string")
      return this.actor.items.get(this.data.preData.item)
    else
      return new CONFIG.Item.documentClass(this.data.preData.item, { parent: this.actor })
  }

  get targets() {
    return this.context.targets.map(i => WFRP_Utility$1.getSpeaker(i))
  }

  get doesDamage() {
    return !!this.result.damage || !!this.result.diceDamage || !!this.result.additionalDamage
  }

  get DamageString() {
    let damageElements = [];
    if (this.result.damage) damageElements.push(this.result.damage);
    if (this.result.diceDamage) damageElements.push(`<span title=${this.result.diceDamage.formula}>${this.result.diceDamage.value}</span>`);

    return `(${damageElements.join(" + ")} ${game.i18n.localize("Damage")})`
  }

  get characteristicKey() { return this.item.characteristic.key }

  get otherText() { return this.result.other?.length ? this.result.other.join("<br>") : null; }
}

class CastTest extends TestWFRP {

  constructor(data, actor) {
    super(data, actor);
    if (!data)
      return

    this.preData.itemData = data.itemData || this.item.toObject(); // Store item data to avoid rerolls being affected by changed channeled SL
    this.preData.skillSelected = data.skillSelected;
    this.preData.unofficialGrimoire = data.unofficialGrimoire;
    this.data.preData.malignantInfluence = data.malignantInfluence;

    this.data.context.templates = data.templates || [];

    this.computeTargetNumber();
    this.preData.skillSelected = data.skillSelected instanceof Item ? data.skillSelected.name : data.skillSelected;
  }

  computeTargetNumber() {

      let skill = this.item.skillToUse;
      if (!skill)
        this.result.target = this.actor.characteristics.int.value;
      else
        this.result.target = skill.total.value;

    super.computeTargetNumber();
  }

  async runPreEffects() {
    await super.runPreEffects();
    await Promise.all(this.actor.runScripts("preRollCastTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("preRollCastTest", { test: this, chatOptions: this.context.chatOptions }));

    //@HOUSE
    if (this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.ingredientMode == 'power' && this.hasIngredient) { 
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
      this.preData.canReverse = true;
    }
    //@HOUSE
  }

  async runPostEffects() {
    await super.runPostEffects();
    await Promise.all(this.actor.runScripts("rollCastTest", { test: this, chatOptions: this.context.chatOptions }));
    await Promise.all(this.item.runScripts("rollCastTest", { test: this, chatOptions: this.context.chatOptions }));
    Hooks.call("wfrp4e:rollCastTest", this, this.context.chatOptions);
  }

  async computeResult() {
    await super.computeResult();

    let miscastCounter = 0;
    let CNtoUse = this.item.cn.value;
    this.result.overcast = duplicate(this.item.overcast);
    this.result.tooltips.miscast = [];
    
    //@HOUSE
    if (this.preData.unofficialGrimoire && this.result.other.indexOf(game.i18n.localize("ROLL.Reverse")) != -1) {
      if (this.data.result.roll.toString()[this.data.result.roll.toString().length -1] == '8') {
        game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
        miscastCounter++;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.PowerIngredientMiscast"));
      }
    }
    //@HOUSE

    // Partial channelling - reduce CN by SL so far
    if (game.settings.get("wfrp4e", "partialChannelling") || game.settings.get("wfrp4e", "useWoMChannelling")) {
      CNtoUse -= this.preData.itemData.system.cn.SL;
      if (CNtoUse < 0)
      {
        CNtoUse = 0;
      }
    }
    // Normal Channelling - if SL has reached CN, CN is considered 0
    else if (this.preData.itemData.system.cn.SL >= this.item.cn.value) {
      CNtoUse = 0;
    }



    // Witchcraft automatically miscast
    if (this.item.lore.value == "witchcraft") {
      miscastCounter++;
      this.result.other.push(game.i18n.localize("CHAT.WitchcraftMiscast"));
      this.result.tooltips.miscast.push(game.i18n.localize("CHAT.AutoWitchcraftMiscast"));
    }

    // slOver is the amount of SL over the CN achieved
    let slOver = (Number(this.result.SL) - CNtoUse);

    // Test itself was failed
    if (this.result.outcome == "failure") 
    {
      this.result.castOutcome = "failure";
      this.result.description = game.i18n.localize("ROLL.CastingFailed");
      if (this.preData.itemData.system.cn.SL) {
        miscastCounter++;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.ChannellingMiscast"));
      }
      // Miscast on fumble
      if (this.result.roll % 11 == 0 || this.result.roll == 100) {
        this.result.color_red = true;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.FumbleMiscast"));
        if (!this.item.system.memorized.value && game.wfrp4e.tables.findTable("grimoire-miscast"))
        {
          this.result.grimoiremiscast = game.i18n.localize("CHAT.GrimoireMiscast");
        }
        miscastCounter++;
        //@HOUSE
        if (this.result.roll == 100 && game.settings.get("wfrp4e", "mooCatastrophicMiscasts")) {
          game.wfrp4e.utility.logHomebrew("mooCatastrophicMiscasts");
          miscastCounter++;
        }
        //@/HOUSE
      }
      //@/HOUSE
      if (this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.overchannelling > 0) { 
        game.wfrp4e.utility.logHomebrew("overchannelling");
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.OverchannellingMiscast"));
        miscastCounter++;
      }
      //@/HOUSE
    }
    else if (slOver < 0) // Successful test, but unable to cast due to not enough SL
    {
      this.result.castOutcome = "failure";
      this.result.description = game.i18n.localize("ROLL.CastingFailed");
      //@/HOUSE
      if (this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.overchannelling > 0) { 
        game.wfrp4e.utility.logHomebrew("overchannelling");
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.OverchannellingMiscast"));
        miscastCounter++;
      }
      //@/HOUSE
      // Critical Casting - succeeds only if the user chooses Total Power option (which is assumed)
      if (this.result.roll % 11 == 0) {
        this.result.color_green = true;
        this.result.castOutcome = "success";
        this.result.description = game.i18n.localize("ROLL.CastingSuccess");
        this.result.critical = game.i18n.localize("ROLL.TotalPower");
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.TotalPowerMiscast"));
        miscastCounter++;
      }
    }

    else // Successful test, casted - determine overcast
    {
      this.result.castOutcome = "success";
      this.result.description = game.i18n.localize("ROLL.CastingSuccess");
      //@/HOUSE
      if (this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.overchannelling > 0) {
        game.wfrp4e.utility.logHomebrew("overchannelling");
        slOver += this.preData.unofficialGrimoire.overchannelling;
      }
      //@/HOUSE

      if (this.result.roll % 11 == 0) {
        this.result.critical = game.i18n.localize("ROLL.CritCast");
        this.result.color_green = true;
        this.result.tooltips.miscast.push(game.i18n.localize("CHAT.CritCastMiscast"));
        miscastCounter++;
      }

      //@HOUSE
      if (game.settings.get("wfrp4e", "mooCriticalChannelling")) {
        game.wfrp4e.utility.logHomebrew("mooCriticalChannelling");
        if (this.spell.flags.criticalchannell && CNtoUse == 0) {
          this.result.SL = "+" + Number(this.result.SL) + this.item._source.cn.value;
          this.result.other.push(game.i18n.localize("MOO.CriticalChanelling"));
        }
      }
      //@/HOUSE
    }
    //@HOUSE
    if (this.preData.unofficialGrimoire && this.preData.unofficialGrimoire.quickcasting && miscastCounter > 0) { 
      game.wfrp4e.utility.logHomebrew("quickcasting");
      this.result.other.push(game.i18n.localize("CHAT.Quickcasting"));
      miscastCounter++;
    }
    //@/HOUSE
    
    miscastCounter += this._checkInfluences() || 0;
    this._calculateOverCast(slOver);
    this._handleMiscasts(miscastCounter);
    await this.calculateDamage();

    // TODO handle all tooltips (when they are added) in one place
    // TODO Fix weird formatting in tooltips (indenting)
    this.result.tooltips.miscast = this.result.tooltips.miscast.join("\n");

    return this.result;
  }

  _checkInfluences()
  {
    if (!this.preData.malignantInfluence) 
    {
      return 0
    }

    // If malignant influence AND roll has an 8 in the ones digit, miscast
    if (
      (Number(this.result.roll.toString().split('').pop()) == 8 && !game.settings.get("wfrp4e", "useWoMInfluences")) || 
      (this.result.outcome == "failure" && game.settings.get("wfrp4e", "useWoMInfluences"))) 
    {
      this.result.tooltips.miscast.push(game.i18n.localize("CHAT.MalignantInfluence"));
      return 1;
    }
  }

  _calculateOverCast(slOver) {
    this.result.overcasts = Math.max(0, Math.floor(slOver / 2));
    this.result.overcast.total = this.result.overcasts;
    this.result.overcast.available = this.result.overcasts;
  }

  async calculateDamage() {
    this.result.additionalDamage = this.preData.additionalDamage || 0;
    // Calculate Damage if the this.item has it specified and succeeded in casting
    try {
      if (this.item.Damage && this.result.castOutcome == "success")
        this.result.damage = Number(this.result.SL) + Number(this.item.Damage);

      if (this.item.damage.dice && !this.result.additionalDamage) {
        let roll = await new Roll(this.item.damage.dice).roll();
        this.result.diceDamage = { value: roll.total, formula: roll.formula };
        this.preData.diceDamage = this.result.diceDamage;
        this.result.additionalDamage += roll.total;
        this.preData.additionalDamage = this.result.additionalDamage;
      }
    }
    catch (error) {
      ui.notifications.error(game.i18n.localize("ErrorDamageCalc") + ": " + error);
    } // If something went wrong calculating damage, do nothing and continue

  }

  
  async moveVortex() 
  {
    for (let id of this.context.templates) {
      let template = canvas.scene.templates.get(id);
      if (template) {

        let tableRoll = (await game.wfrp4e.tables.rollTable("vortex", {}, "map"));
        let dist = (await new Roll("2d10").roll({ async: true })).total;
        let pixelsPerYard = canvas.scene.grid.size / canvas.scene.grid.distance;
        let straightDelta = dist * pixelsPerYard;
        let diagonalDelta = straightDelta / Math.sqrt(2);
        tableRoll.result = tableRoll.result.replace("[[2d10]]", dist);

        if (tableRoll) {
          let { x, y } = template || {};
          ChatMessage.create({ content: tableRoll.result, speaker: { alias: this.item.name } });
          if (tableRoll.roll == 1) {
            await template?.delete();
            this.context.templates = this.context.templates.filter(i => i != id);
            await this.updateMessageFlags();
            continue;
          }
          else if (tableRoll.roll == 2) {
            y -= straightDelta;
          }
          else if (tableRoll.roll == 3) {
            y -= diagonalDelta;
            x += diagonalDelta;
          }
          else if (tableRoll.roll == 4) {
            x += straightDelta;
          }
          else if (tableRoll.roll == 5) ;
          else if (tableRoll.roll == 6) {
            y += diagonalDelta;
            x += diagonalDelta;
          }
          else if (tableRoll.roll == 7) {
            y += straightDelta;
          }
          else if (tableRoll.roll == 8) {
            y += diagonalDelta;
            x -= diagonalDelta;
          }
          else if (tableRoll.roll == 9) {
            x -= straightDelta;
          }
          else if (tableRoll.roll == 10) {
            y -= diagonalDelta;
            x -= diagonalDelta;
          }
          template.update({ x, y }).then(template => {
            // AbilityTemplate.updateAOETargets(template);
          });
        }
      }
    }
  }


  async postTest() {
    //@/HOUSE
    if (this.preData.unofficialGrimoire) {
      game.wfrp4e.utility.logHomebrew("unofficialgrimoire");
      if (this.preData.unofficialGrimoire.ingredientMode != 'none' && this.hasIngredient && this.item.ingredient.quantity.value > 0 && !this.context.edited && !this.context.reroll) {
        await this.item.ingredient.update({ "system.quantity.value": this.item.ingredient.quantity.value - 1 });
        await ChatMessage.create({ speaker: this.context.speaker, content: game.i18n.localize("ConsumedIngredient") });
      }
    //@/HOUSE
    } else {
      // Find ingredient being used, if any
      if (this.hasIngredient && this.item.ingredient.quantity.value > 0 && !this.context.edited && !this.context.reroll)
        await this.item.ingredient.update({ "system.quantity.value": this.item.ingredient.quantity.value - 1 });
    }

    // Set initial extra overcasting options to SL if checked
    if (this.result.overcast.enabled) {
      if (this.item.overcast.initial.type == "SL") {
        setProperty(this.result, "overcast.usage.other.initial", parseInt(this.result.SL) + (parseInt(this.item.computeSpellPrayerFormula("", false, this.spell.overcast.initial.additional)) || 0));
        setProperty(this.result, "overcast.usage.other.current", parseInt(this.result.SL) + (parseInt(this.item.computeSpellPrayerFormula("", false, this.spell.overcast.initial.additional)) || 0));
      }
    }

    if (this.result.miscastModifier) {
      if (this.result.minormis)
        this.result.minormis += ` (${this.result.miscastModifier})`;
      if (this.result.majormis)
        this.result.majormis += ` (${this.result.miscastModifier})`;
      if (this.result.catastrophicmis)
        this.result.catastrophicmis += ` (${this.result.miscastModifier})`;
    }

    //@HOUSE
    if (this.item.cn.SL > 0) {

      if (this.result.castOutcome == "success" || !game.settings.get("wfrp4e", "mooCastAfterChannelling"))
      {
        let items = [this.item];

        // If WoM Channelling, SL of spells are shared, so remove all channelled SL of spells with the same lore
        if (game.settings.get("wfrp4e", "useWoMChannelling"))
        {
          items = this.actor.items.filter(s => s.type == "spell" && s.system.lore.value == this.spell.system.lore.value).map(i => i.toObject());
          items.forEach(i => i.system.cn.SL = 0);
          await this.actor.updateEmbeddedDocuments("Item", items);
        }
        else 
        {
          await this.item.update({ "system.cn.SL": 0 });
        }
      }

      else if (game.settings.get("wfrp4e", "mooCastAfterChannelling")) {
        game.wfrp4e.utility.logHomebrew("mooCastAfterChannelling");
        if (this.item.cn.SL > 0 && this.result.castOutcome == "failure")
          this.result.other.push(game.i18n.localize("MOO.FailedCast"));
      }
    }
    //@/HOUSE
  }

  get hasIngredient() {
    return this.item.ingredient && this.item.ingredient.quantity.value > 0
  }

  get effects() {
    let effects = super.effects;
    if (this.item.system.lore.effect?.application == "apply")
      effects.push(this.item.system.lore.effect);
    return effects
  }


  get spell() {
    return this.item
  }

  get characteristicKey() {
    if (this.preData.skillSelected.char)
      return this.preData.skillSelected.key

    else {
      let skill = this.actor.getItemTypes("skill").find(s => s.name == this.preData.skillSelected);
      if (skill)
        return skill.characteristic.key
    }
  }
}

class WomCastTest extends CastTest {

  // WoM overcasts need to check availability per usage option
  // Look at each usage's first option and see if the cost can be paid
  // If not, it is not available
  _calculateOverCast(slOver) {

    this.result.overcasts = Math.max(0, slOver);    
    this.result.overcast.total = this.result.overcasts;
    this.result.overcast.available = this.result.overcasts;
    let overCastTable = game.wfrp4e.config.overCastTable;
    if (game.wfrp4e.config.magicWind[this.spell.lore.value] == "Dhar") {
      overCastTable = game.wfrp4e.config.dharOverCastTable;
    }

    // Since SL is spent by overcasts, need to keep track of original
    this.result.overcast.originalSL = Number(this.result.SL); 

    if (this.result.overcast.usage.range) {
      this.result.overcast.usage.range.available = this.result.overcast.available >= overCastTable.range[0].cost;
    }
    if (this.result.overcast.usage.target) {
      if(this.result.overcast.usage.target.AoE) {
        this.result.overcast.usage.target.available = this.result.overcast.available >= overCastTable.AoE[0].cost;
      } else {
        this.result.overcast.usage.target.available = this.result.overcast.available >= overCastTable.target[0].cost;
      }
    }
    if (this.result.overcast.usage.duration) {
      this.result.overcast.usage.duration.available = this.result.overcast.available >= overCastTable.duration[0].cost;
    }
    if (this.result.overcast.usage.damage) {
      this.result.overcast.usage.damage.available = this.result.overcast.available >= overCastTable.damage[0].cost;
    }
    if (this.result.overcast.usage.other) {
      this.result.overcast.usage.other.available = this.result.overcast.available >= 2;
    }
  }

  async calculateDamage() {
    this.result.additionalDamage = this.preData.additionalDamage || 0;
    let overCastTable = game.wfrp4e.config.overCastTable;
    if (game.wfrp4e.config.magicWind[this.spell.lore.value] == "Dhar") {
      overCastTable = game.wfrp4e.config.dharOverCastTable;
    }
    // Calculate Damage if the this.item has it specified and succeeded in casting
    try {
      if (this.item.Damage && this.result.castOutcome == "success") {
        this.result.damage = Number(this.item.Damage);
        if (this.result.overcast.usage.damage && this.result.overcast.usage.damage.count > 0) {
          this.result.additionalDamage += overCastTable.damage[this.result.overcast.usage.damage.count - 1].value;
          this.result.damage += this.result.additionalDamage;
        }
      }
      if (this.item.damage.dice && !this.result.additionalDamage) {
        let roll = await new Roll(this.item.damage.dice).roll();
        this.result.diceDamage = { value: roll.total, formula: roll.formula };
        this.preData.diceDamage = this.result.diceDamage;
        this.result.additionalDamage += roll.total;
        this.preData.additionalDamage = this.result.additionalDamage;
      }
    }
    catch (error) {
      ui.notifications.error(game.i18n.localize("ErrorDamageCalc") + ": " + error);
    } // If something went wrong calculating damage, do nothing and continue
  }


  // @@@@@@@ Overcast functions placed in root class because it is used by both spells and prayers @@@@@@@
  async _overcast(choice) {
    if (!game.settings.get("wfrp4e", "useWoMOvercast")) {
      await super._overcast(choice);
    } else {
      const overcastData = this.result.overcast;

      if (!overcastData.available)
        return overcastData

      if (typeof overcastData.usage[choice].initial != "number")
        return overcastData

      let overCastTable = game.wfrp4e.config.overCastTable;
      if (game.wfrp4e.config.magicWind[this.spell.lore.value] == "Dhar") {
        overCastTable = game.wfrp4e.config.dharOverCastTable;
      }
      const count = overcastData.usage[choice].count;

      // If no table entry, or costs more than SL available, do nothing
      // AoE is separate column from target, so must be tested separately 
      if (choice == "target" && overcastData.usage.target.AoE) {
        if (!overCastTable["AoE"][count] || overCastTable["AoE"][count].cost > overcastData.available) {
          return overcastData;
        }
      } 
      // Other options are not in the table, so assume cost is 2 per original rules
      else if (choice == "other") {
        if (game.wfrp4e.config.magicWind[this.spell.lore.value] == "Dhar") {
          if (1 > overcastData.available) {
            return overcastData
          }
        } else {
          if (2 > overcastData.available) {
            return overcastData
          }
        }
      }
      else {
        if (!overCastTable[choice][count] || overCastTable[choice][count].cost > overcastData.available) {
          return overcastData;
        }
      }

      // Set current value based on overcast choice
      switch (choice) {
        case "range":
          if (overCastTable[choice][count] && overCastTable[choice][count].cost <= overcastData.available) {
            overcastData.usage[choice].current = overCastTable[choice][count].value * overcastData.usage[choice].initial;
          }
          break
        case "target":
          if (overcastData.usage["target"].AoE) {
            if (overCastTable[choice][count] && overCastTable["AoE"][count].cost <= overcastData.available) {
              overcastData.usage[choice].current = overCastTable["AoE"][count].value * overcastData.usage[choice].initial;
            }
          } else {
            if (overCastTable[choice][count] && overCastTable["target"][count].cost <= overcastData.available) {
              overcastData.usage[choice].current = overCastTable["target"][count].value + overcastData.usage[choice].initial;
            }
          }
          break
        case "duration":
          if (overCastTable[choice][count] && overCastTable[choice][count].cost <= overcastData.available) {
            overcastData.usage[choice].current = overCastTable[choice][count].value * overcastData.usage[choice].initial;
          }
          break
        case "damage": 
        if (overCastTable[choice][count] && overCastTable[choice][count].cost <= overcastData.available) {
          overcastData.usage[choice].current = overCastTable[choice][count].value + overcastData.usage[choice].initial;
        }
          break
        case "other":
          if (overcastData.valuePerOvercast.type == "value")
            overcastData.usage[choice].current += overcastData.valuePerOvercast.value;
          else if (overcastData.valuePerOvercast.type == "SL")
            overcastData.usage[choice].current += (parseInt(this.result.SL) + (parseInt(this.item.computeSpellPrayerFormula(undefined, false, overcastData.valuePerOvercast.additional)) || 0));
          else if (overcastData.valuePerOvercast.type == "characteristic")
            overcastData.usage[choice].current += (overcastData.usage[choice].increment || 0); // Increment is specialized storage for characteristic data so we don't have to look it up
          break
      }


      // Subtract cost of overcasting from available SL
      // AoE is separate column from target, so must be tested separately 
      if (choice == "target" && overcastData.usage.target.AoE) {
        overcastData.available = overcastData.available - overCastTable["AoE"][count].cost;
      } 
      else if (choice == "other") {
        overcastData.available = overcastData.available - 2;
      }
      else {
        overcastData.available = overcastData.available - overCastTable[choice][count].cost;
      }

      overcastData.usage[choice].count++;

      // Check if options are still available for more overcasting (now that count is incremented)
      // It is not available if 1). no more entries in the table or 2). not enough available SL
      if (overcastData.usage.range) {
        overcastData.usage.range.available = overCastTable.range[overcastData.usage.range.count] && overcastData.available >= overCastTable.range[overcastData.usage.range.count].cost;
      }
      if (overcastData.usage.target) {
        if (overcastData.usage.target.AoE) {
          overcastData.usage.target.available = overCastTable.AoE[overcastData.usage.target.count] && overcastData.available >= overCastTable.AoE[overcastData.usage.target.count].cost;
        } else {          
          overcastData.usage.target.available = overCastTable.target[overcastData.usage.target.count] && overcastData.available >= overCastTable.target[overcastData.usage.target.count].cost;
        }
      }
      if (overcastData.usage.duration) {
        overcastData.usage.duration.available = overCastTable.duration[overcastData.usage.duration.count] && overcastData.available >= overCastTable.duration[overcastData.usage.duration.count].cost;
      }
      if (overcastData.usage.damage) {
        overcastData.usage.damage.available = overCastTable.damage[overcastData.usage.damage.count] && overcastData.available >= overCastTable.damage[overcastData.usage.damage.count].cost;
      }

      // Subtract SL by the amount spent on overcasts
      this.data.result.SL = `+${overcastData.originalSL - (overcastData.total - overcastData.available)}`;
      await this.calculateDamage();
      await this.updateMessageFlags();
      this.renderRollCard();
    }
  }

  async _overcastReset() {
    if (!game.settings.get("wfrp4e", "useWoMOvercast")) {
      await super._overcastReset();
    } else {
      let overcastData = this.result.overcast;
      overcastData.available = overcastData.total;
      let overCastTable = game.wfrp4e.config.overCastTable;
      if (game.wfrp4e.config.magicWind[this.spell.lore.value] == "Dhar") {
        overCastTable = game.wfrp4e.config.dharOverCastTable;
      }

      // For each usage option, set count to 0, reset current value to initial, and check availability
      for (let overcastType in overcastData.usage) {
        if (overcastData.usage[overcastType]) {
          overcastData.usage[overcastType].count = 0;
          overcastData.usage[overcastType].current = overcastData.usage[overcastType].initial;

          if (overcastType == "other") {
            if (game.wfrp4e.config.magicWind[this.spell.lore.value] == "Dhar") {
              overcastData.usage[overcastType].available = overcastData.available >= 1;
            }
            else {
              overcastData.usage[overcastType].available = overcastData.available >= 2;
            }
          }
          else if(overcastType == "target" && overcastData.usage.target.AoE) {
            overcastData.usage[overcastType].available = overcastData.available >= overCastTable.AoE[0].cost;
          } 
          else {
            overcastData.usage[overcastType].available = overcastData.available >= overCastTable[overcastType][0].cost;
          }
        }
      }

      this.data.result.additionalDamage = this.preData.additionalDamage || 0;
      this.data.result.SL = `+${overcastData.originalSL}`;
      await this.calculateDamage();
      this.renderRollCard();
    }
  }
}

class OpposedTest {
  constructor(attackerTest = undefined, defenderTest = undefined, opposeResult = {}) {
    this.data = {
      attackerTestData : attackerTest?.data,
      defenderTestData : defenderTest?.data,
      opposeResult
    };

    this.attackerTest = attackerTest;
    this.defenderTest = defenderTest;
  }
  get opposeResult() { return this.data.opposeResult }
  get result() { return this.data.opposeResult }
  get attacker() { return this.attackerTest.actor }
  get defender() { return this.defenderTest.actor }

  static recreate(data)
  {
    let opposedTest = new OpposedTest();
    opposedTest.data = data;
    opposedTest.createAttackerTest(data.attackerTestData);
    opposedTest.createDefenderTest(data.defenderTestData);
    return opposedTest;
  }

  _createTest(testData) {
    if (!testData)
      return testData
    let test = game.wfrp4e.rolls.TestWFRP.recreate(testData);
    test.data = testData;
    return test
  }

  createAttackerTest(testData) {
    this.attackerTest = this._createTest(testData);
    this.data.attackerTestData = testData;
  }

  createDefenderTest(testData) {
    this.defenderTest = this._createTest(testData);
    this.data.defenderTestData = testData;
  }

  createUnopposedDefender(actor) {
    this.defenderTest = new game.wfrp4e.rolls.CharacteristicTest({
      item: "ws",
      SL: 0,
      target: 0,
      roll: 0,
      unopposedTarget: true,
    }, actor);
    this.defenderTest.data.context.unopposed = true;
    this.data.defenderTestData = this.defenderTest.data;
  }


  /*Known Bugs: attempting to reroll causes it to not reroll at all, actually. Manually editing cards causes a duplicate result card at the end.
*
*
*
*/
  checkPostModifiers() {

    let didModifyAttacker = false, didModifyDefender = false;

    let modifiers = {
      attacker: {
        target: 0,
        SL: 0
      },
      defender: {
        target: 0,
        SL: 0
      },
      message: []
    };

    // Things to Check:
    // Weapon Length DONE
    // Fast Weapon Property DONE
    // Size 
    // Done - Weapon Defending: You suer a penalty of 2 SL for each step larger your opponent is when using Melee to defend an Opposed Test
    // Done - To Hit Modifiers: +10 Bonus if smaller
    // Done - Ranged to Hit Modifiers : You gain a hefty bonus when shooting at larger targets (Ex. +40 to hit Enormous).
    //Shooting at smaller targets?

    if (game.settings.get("wfrp4e", "weaponLength") && this.attackerTest.weapon && this.defenderTest.weapon && this.attackerTest.weapon.attackType == "melee" && this.defenderTest.weapon.attackType == "melee") {
      let attackerReach = this.attackerTest.item.reachNum;
      let defenderReach = this.defenderTest.item.reachNum;
      if (defenderReach > attackerReach && !this.attackerTest.result.infighter) {
        didModifyAttacker = true;
        modifiers.message.push(game.i18n.format(game.i18n.localize('CHAT.TestModifiers.WeaponLength'), { defender: this.defenderTest.actor.prototypeToken.name, attacker: this.attackerTest.actor.prototypeToken.name }));
        modifiers.attacker.target += -10;
      }
    }


    //Apply the modifiers
    if (didModifyAttacker || didModifyDefender) {
      modifiers.message.push(game.i18n.localize('CHAT.TestModifiers.FinalModifiersTitle'));
      if (didModifyAttacker)
        modifiers.message.push(`${game.i18n.format(game.i18n.localize('CHAT.TestModifiers.FinalModifiers'), { target: modifiers.attacker.target, sl: modifiers.attacker.SL, name: this.attackerTest.actor.prototypeToken.name })}`);
    }
    return mergeObject(modifiers, { didModifyAttacker, didModifyDefender });
  }

  /**
    * Main Opposed test evaluation logic. Takes attacker and defender test data and 
    * determines who won, by how much, etc. Displays who won accordingly, with different
    * logic for manual and targeted opposed tests
    * 
    * @param {Object} attacker Attacker data
    * @param {Object} defender Defender Data
    * @param {Object} options Targeted?
    */
  async evaluate() {
    try {
      let opposeResult = this.result;
      let attackerTest = this.attackerTest;
      let defenderTest = this.defenderTest;

      let soundContext = {};
      opposeResult.other = [];


      let attacker = this.attackerTest.actor;
      let defender = this.defenderTest.actor;


      await Promise.all(attacker.runScripts("preOpposedAttacker", { attackerTest, defenderTest, opposedTest: this }));
      await Promise.all(defender.runScripts("preOpposedDefender", { attackerTest, defenderTest, opposedTest: this }));


      opposeResult.modifiers = this.checkPostModifiers(attackerTest, defenderTest);

      // Redo the test with modifiers
      if (opposeResult.modifiers.didModifyAttacker) {
        attackerTest.preData.roll = attackerTest.result.roll;
        attackerTest.preData.postOpposedModifiers = opposeResult.modifiers.attacker;
        attackerTest.preData.hitloc = attackerTest.result.hitloc?.roll;
        await attackerTest.computeResult();
        await attackerTest.renderRollCard();
      }

      // Redo the test with modifiers
      if (opposeResult.modifiers.didModifyDefender) {
        defenderTest.preData.roll = defenderTest.result.roll;
        defenderTest.preData.postOpposedModifiers = opposeResult.modifiers.defender;
        defenderTest.preData.hitloc = defenderTest.result.hitloc?.roll;
        await defenderTest.computeResult();
        await defenderTest.renderRollCard();
      }
      else if (defenderTest.context.unopposed)
        await defenderTest.roll();

      opposeResult.other = opposeResult.other.concat(opposeResult.modifiers.message);

      let attackerSL = parseInt(attackerTest.result.SL ?? 0);
      let defenderSL = parseInt(defenderTest.result.SL ?? 0);
      opposeResult.differenceSL = 0;

      // If attacker has more SL OR the SLs are equal and the attacker's target number is greater than the defender's, then attacker wins. 
      // Note: I know this isn't technically correct by the book, where it states you use the tested characteristic/skill, not the target number, i'll be honest, I don't really care.
      if (attackerSL > defenderSL || (attackerSL === defenderSL && (attackerTest.target > defenderTest.target || (attackerTest.outcome == "success" && defenderTest.context.unopposed)))) {
        opposeResult.winner = "attacker";
        opposeResult.differenceSL = attackerSL - defenderSL;

        // If Damage is a numerical value
        if (Number.isNumeric(attackerTest.damage)) {
          let damage = await this.calculateOpposedDamage();
          opposeResult.damage = {
            description: `<b>${game.i18n.localize("Damage")}</b>: ${damage}`,
            value: damage
          };
        }
        // If attacker is using a weapon or trait but there wasn't a numerical damage value, output unknown
        else if (attackerTest.weapon || attackerTest.trait) {
          opposeResult.damage = {
            description: `<b>${game.i18n.localize("Damage")}</b>: ?`,
            value: null
          };
        }
        if (attackerTest.hitloc) {
          // Remap the hit location roll to the defender's hit location table, note the change if it is different
          let remappedHitLoc = await game.wfrp4e.tables.rollTable(defender.details.hitLocationTable.value, { lookup: attackerTest.hitloc.roll, hideDSN: true });
          if (remappedHitLoc.result != attackerTest.hitloc.result) {
            remappedHitLoc.description = game.i18n.localize(remappedHitLoc.description) + " (Remapped)";
            remappedHitLoc.remapped = true;
            attackerTest.result.hitloc = remappedHitLoc;
          }

          opposeResult.hitloc = {
            description: `<b>${game.i18n.localize("ROLL.HitLocation")}</b>: ${attackerTest.hitloc.description}`,
            value: attackerTest.hitloc.result
          };
        }

        try // SOUND
        {
          if (attackerTest.weapon.weaponGroup.value === "bow"
            || attackerTest.weapon.weaponGroup.value === "crossbow") {
            soundContext = { item: attackerTest.weapon, action: "hit" };
          }
          if (attackerTest.weapon.weaponGroup.value == "throwing") {
            soundContext.item = { type: "throw" };
            if (attackerTest.weapon.properties.qualities.hack) {
              soundContext.item = { type: "throw_axe" };
            }
          }
        }
        catch (e) { WFRP_Utility$1.log("Sound Context Error: " + e, true); } // Ignore sound errors
      }
      else // Defender won
      {
        try {
          if (attackerTest.weapon
            && (attackerTest.weapon.weaponGroup.value === "bow"
              || attackerTest.weapon.weaponGroup.value === "crossbow"
              || attackerTest.weapon.weaponGroup.value === "blackpowder"
              || attackerTest.weapon.weaponGroup.value === "engineering")) {
            soundContext = { item: attackerTest.weapon, action: "miss" };
          }
          if (defenderTest.weapon && defenderTest.weapon.properties.qualities.shield) {
            if (attackerTest.weapon.attackType == "melee") {
              soundContext = { item: { type: "shield" }, action: "miss_melee" };
            }
            else {
              if (attackerTest.weapon.weaponGroup.value === "bow"
                || attackerTest.weapon.weaponGroup.value === "sling"
                || attackerTest.weapon.weaponGroup.value === "throwing"
                || attackerTest.weapon.weaponGroup.value === "crossbow") {
                soundContext = { item: { type: "shield" }, action: "miss_ranged" };
              }
            }
          }
        }
        catch (e) { WFRP_Utility$1.log("Sound Context Error: " + e, true); } // Ignore sound errors


        opposeResult.winner = "defender";
        opposeResult.differenceSL = defenderSL - attackerSL;

        let riposte;
        if (defenderTest.weapon)
          riposte = defenderTest.result.riposte && !!defenderTest.weapon.properties.qualities.fast;

        if (defenderTest.result.champion || riposte) {
          let temp = duplicate(defenderTest.data);
          this.defenderTest = game.wfrp4e.rolls.TestWFRP.recreate(attackerTest.data);
          this.attackerTest = game.wfrp4e.rolls.TestWFRP.recreate(temp);
          this.data.attackerTestData = this.attackerTest.data;
          this.data.defenderTestData = this.defenderTest.data;
          let damage = await this.calculateOpposedDamage();
          opposeResult.damage = {
            description: `<b>${game.i18n.localize("Damage")} (${riposte ? game.i18n.localize("NAME.Riposte") : game.i18n.localize("NAME.Champion")})</b>: ${damage}`,
            value: damage
          };
          let hitloc = await game.wfrp4e.tables.rollTable(defenderTest.actor.details.hitLocationTable.value, {hideDSN : true});

          opposeResult.hitloc = {
            description: `<b>${game.i18n.localize("ROLL.HitLocation")}</b>: ${hitloc.description}`,
            value: hitloc.result
          };
          opposeResult.swapped = true;

          soundContext = { item: { type: "weapon" }, action: "hit" };
        }
      }

      await Promise.all(attacker.runScripts("opposedAttacker", { opposedTest: this, attackerTest, defenderTest }));
      if (defender)
        await Promise.all(defender.runScripts("opposedDefender", { opposedTest: this, attackerTest, defenderTest }));

      Hooks.call("wfrp4e:opposedTestResult", this, attackerTest, defenderTest);
      WFRP_Audio.PlayContextAudio(soundContext);

      return opposeResult
    }
    catch (err) {
      ui.notifications.error(`${game.i18n.localize("ErrorOpposed")}: ` + err);
      console.error("Could not complete opposed test: " + err);
    }
  }


  async calculateOpposedDamage() {
    // Calculate size damage multiplier 
    let damageMultiplier = 1;
    let sizeDiff;

    if (this.attackerTest.actor.type == "vehicle" || this.defenderTest.actor.type == "vehicle")
      sizeDiff = 0;
    else 
      sizeDiff = game.wfrp4e.config.actorSizeNums[this.attackerTest.size] - game.wfrp4e.config.actorSizeNums[this.defenderTest.size];

    if (this.attackerTest.actor.getItemTypes("trait").find(i => i.name == game.i18n.localize("NAME.Swarm") && i.included) || this.defenderTest.actor.getItemTypes("trait").find(i => i.name == game.i18n.localize("NAME.Swarm")))
      sizeDiff = 0;

    if (game.settings.get("wfrp4e", "mooSizeDamage"))
      sizeDiff = 0;

    damageMultiplier = sizeDiff >= 2 ? sizeDiff : 1;


    let opposedSL = Number(this.attackerTest.result.SL ?? 0) - Number(this.defenderTest.result.SL ?? 0);
    let item = this.attackerTest.item;

    if (item?.system.damage?.hasOwnProperty("addSL") && !item.system.damage.addSL)
    {
      opposedSL = 0;
    }

    let damage;
    if (this.attackerTest.useMount)
      damage = item.mountDamage;
    else
      damage = item.Damage;

    //@HOUSE
    if (game.settings.get("wfrp4e", "mooSLDamage")) {
      game.wfrp4e.utility.logHomebrew("mooSLDamage");
      opposedSL = Number(this.attackerTest.result.SL);
    }
    //@/HOUSE

    // Winds of Magic overcast
    if (this.attackerTest instanceof WomCastTest) {	
      damage += (this.attackerTest.result.additionalDamage || 0);	
    } else {	
      damage += (opposedSL + (this.attackerTest.result.additionalDamage || 0));	
    }

    //@HOUSE
    if (game.settings.get("wfrp4e", "mooRangedDamage"))
    {
      game.wfrp4e.utility.logHomebrew("mooRangedDamage");
      if (this.attackerTest.item && this.attackerTest.item.attackType == "ranged")
      {
        damage -= (Math.floor(this.attackerTest.targetModifiers / 10) || 0);
        if (damage < 0)
          damage = 0;
      }
    }
    //@/HOUSE

    let effectArgs = { damage, damageMultiplier, sizeDiff, opposedTest: this, addDamaging : false, addImpact : false };
    await Promise.all(this.attackerTest.actor.runScripts("calculateOpposedDamage", effectArgs));
    await Promise.all(this.attackerTest.item?.runScripts("calculateOpposedDamage", effectArgs));
    ({ damage, damageMultiplier, sizeDiff } = effectArgs);

    let addDamaging = effectArgs.addDamaging || false;
    let addImpact = effectArgs.addImpact || false;
    if (this.attackerTest.trait) {
      if (sizeDiff >= 1)
        addDamaging = true;
      if (sizeDiff >= 2)
        addImpact = true;
    }

    let hasDamaging = false;
    let hasImpact = false;
    if (this.attackerTest.item.properties) {
      hasDamaging = this.attackerTest.item.properties.qualities.damaging;
      hasImpact = this.attackerTest.item.properties.qualities.impact;

      if (this.attackerTest.result.charging || !this.attackerTest.item.properties.flaws.tiring) {
        if (hasDamaging)
          addDamaging = true;
        if (hasImpact)
          addImpact = true;
      }

      if (sizeDiff >= 1)
        addDamaging = true;
      if (sizeDiff >= 2)
        addImpact = true;
    }

    if (addDamaging) {
      let unitValue = Number(this.attackerTest.result.roll.toString().split("").pop());
      if (unitValue === 0)
        unitValue = 10;

      if (unitValue > opposedSL) {
        damage = damage - opposedSL + unitValue; // replace opposedSL with unit value
      }
    }
    if (addImpact) {
      let unitValue = Number(this.attackerTest.result.roll.toString().split("").pop());
      if (unitValue === 0)
        unitValue = 10;
      damage += unitValue;
    }
    this.result.damaging = hasDamaging || addDamaging;
    this.result.impact = hasImpact || addImpact;
    return damage * damageMultiplier
  }

}

/**
 * Represents an opposed test. This object is stored in the "targeting" messages and is used as a central manager of a single opposed test.
 * - Stores targeting message id, attacker message id, defender message id, and result message ID
 * - Actors who have been targeted are flagged with the targeting message ID (messageId)
 * - @see TestWFRP - Tests have a list of opposedMessageIds, that being messageId
 **/
class OpposedWFRP {

  constructor(data = {}) {
    this.data = {
      messageId: data.messageId,
      attackerMessageId: data.attackerMessageId,
      defenderMessageId: data.defenderMessageId,
      resultMessageId: data.resultMessageId,
      targetSpeakerData: data.targetSpeakerData,
      options: data.options || {},
      unopposed: data.unopposed
    };
  }

  get message() {
    return game.messages.get(this.data.messageId);
  }

  get resultMessage() {
    return game.messages.get(this.data.resultMessageId);
  }

  get target() {
    return WFRP_Utility$1.getToken(this.data.targetSpeakerData);
  }

  get attackerMessage() {
    return game.messages.get(this.data.attackerMessageId);
  }

  get defenderMessage() {
    return game.messages.get(this.data.defenderMessageId);
  }

  get attackerTest() {
    return this.attackerMessage?.getTest();
  }

  get defenderTest() {
    if (this.unopposed) {
      return new game.wfrp4e.rolls.CharacteristicTest({
        item: "ws",
        SL: 0,
        target: 0,
        roll: 0,
        unopposed: true,
      }, this.target.actor)
    }
    else
      return this.defenderMessage?.getTest();
  }

  get attacker() {
    return this.attackerTest?.actor
  }

  get defender() {
    return this.defenderTest ? this.defenderTest.actor : WFRP_Utility$1.getSpeaker(this.data.targetSpeakerData) // If opposed test isn't complete, use targetSPeakerData
  }

  get options() {
    return this.data.options;
  }

  get unopposed() {
    return this.data.unopposed;
  }

  async startOppose(targetToken) {
    this.data.targetSpeakerData = targetToken.actor.speakerData(targetToken);
    await this.renderOpposedStart();
    await this._addOpposeFlagsToDefender(targetToken);
    return this.message?.id
  }

  async setAttacker(message) {
    this.data.attackerMessageId = typeof message == "string" ? message : message.id;
    this.data.options = {
      whisper: message.whisper,
      blind: message.blind
    };
    if (this.message)
      await this.updateMessageFlags();
  }

  async setDefender(message) {
    this.data.defenderMessageId = typeof message == "string" ? message : message.id;
    if (this.message)
      await this.updateMessageFlags();
  }

  async computeOpposeResult() {
    if (!this.attackerTest || !this.defenderTest)
      throw new Error(game.i18n.localize("ERROR.Opposed"))

    this.opposedTest = new OpposedTest(this.attackerTest, this.defenderTest);

    await this.opposedTest.evaluate();
    this.formatOpposedResult();
    await this.renderOpposedResult();
    await this.colorWinnerAndLoser();
  }

  async renderOpposedStart() {
    let attacker = game.canvas.tokens.get(this.attackerTest.context.chatOptions.speaker.token)?.document ?? this.attacker.prototypeToken;
    let defender;

    // Support opposed start messages when defender is not set yet - allows for manual opposed to use this message
    if (this.target)
      defender = this.target;
    else if (this.defenderTest)
      defender = WFRP_Utility$1.getToken(this.defenderTest.context.speaker) || this.defender.prototypeToken;

    let defenderImg = defender ? `<a class = "defender"><img src="${defender.texture.src}" width="50" height="50"/></a>` : `<a class = "defender"><img width="50" height="50"/></a>`;

    let content =
        `<div class ="opposed-message">
            ${game.i18n.format("ROLL.Targeting", {attacker: ((attacker.hidden) ? "???" : attacker.name), defender: defender ? defender.name : "???"})}
          </div>
          <div class = "opposed-tokens">
          <a class = "attacker"><img src="${((attacker.hidden) ? "systems/wfrp4e/tokens/unknown.png" : attacker.texture.src)}" width="50" height="50"/></a>
          ${defenderImg}
          </div>
          <div class="unopposed-button" data-target="true" title="${game.i18n.localize("Unopposed")}"><a><i class="fas fa-arrow-down"></i></a></div>`;

    // Ranged weapon opposed tests automatically lose no matter what if the test itself fails
    if (this.attackerTest.item && this.attackerTest.item.attackType == "ranged" && this.attackerTest.result.outcome == "failure") {
      await ChatMessage.create({ speaker: this.attackerMessage.speaker, content: game.i18n.localize("OPPOSED.FailedRanged") });
      return;
    }
    let chatData = {
        user: game.user.id,
        content: content,
        speaker: { alias: game.i18n.localize("CHAT.OpposedTest") },
        whisper: this.options.whisper,
        blind: this.options.blind,
        "flags.wfrp4e.opposeData": this.data
    };

    if (this.message) {
        await this.message.update(chatData);
        return this.data.messageId;
    }
    else {
        // Create the Opposed starting message
        let msg = await ChatMessage.create(chatData);
        this.data.messageId = msg.id;
        await this.updateMessageFlags();
        return msg.id;
    }
  }

  async updateMessageFlags() {
    let updateData = { "flags.wfrp4e.opposeData": this.data };
    if (this.message && game.user.isGM) {
      await this.message.update(updateData);
    }
    else if (this.message) {
      await SocketHandlers.executeOnUserAndWait("GM", "updateMsg", { id: this.message.id, updateData });
    }
  }



  async renderOpposedResult() {
    let opposeData = this.opposedTest.data;
    let opposeResult = this.opposedTest.result;
    let options = this.options;
    opposeResult.hideData = true;
    let html = await renderTemplate("systems/wfrp4e/templates/chat/roll/opposed-result.hbs", opposeResult);
    let chatOptions = {
      user: game.user.id,
      content: html,
      "flags.wfrp4e.opposeTestData": opposeData,
      "flags.wfrp4e.opposeId": this.message.id,
      whisper: options.whisper,
      blind: options.blind,
    };
    let msg = await ChatMessage.create(chatOptions);
    this.data.resultMessageId = msg.id;
    await this.updateMessageFlags();
  }

  formatOpposedResult() {

    let opposeResult = this.opposedTest.opposeResult;
    let attackerAlias = this.attackerTest.message.speaker.alias;

    // Account for unopposed tests not having a defender message
    let defenderAlias = this.defenderMessage ? this.defenderMessage.speaker.alias : this.defenderTest.actor.prototypeToken.name;

    if (opposeResult.winner == "attacker") {
      opposeResult.result = game.i18n.format("OPPOSED.AttackerWins", {
        attacker: attackerAlias,
        defender: defenderAlias,
        SL: opposeResult.differenceSL
      });
      opposeResult.img = this.attackerMessage.flags.img;
    }
    else if (opposeResult.winner == "defender") {
      opposeResult.result = game.i18n.format("OPPOSED.DefenderWins", {
        defender: defenderAlias,
        attacker: attackerAlias,
        SL: opposeResult.differenceSL
      });
      opposeResult.img = this.defenderMessage ? this.defenderMessage.flags.img : this.defenderTest.actor.prototypeToken.texture.src;
    }

    return opposeResult;
  }

  async colorWinnerAndLoser() 
  {
    try {
      let winner = this.opposedTest.opposeResult.winner;

      // The loser is "attacker" or "defender"
      let loser = winner == "attacker" ? "defender" : "attacker";

      // Replace "attacker" with "attacker winner" or "defender" with "defender winner" to apply the color coded borders
      let content = this.message.content;
      content = content.replace(winner, `${winner} winner`);
      content = content.replace(loser, `${loser} loser`);

      if (!game.user.isGM)
        await SocketHandlers.executeOnUserAndWait("GM", "updateMsg", { id: this.message.id, updateData: {content} });
      else
        await this.message.update({content});
    }
    catch(e) {
      console.error(`Error color coding winner and loser: ${e}`);
    }
  }


  async _addOpposeFlagsToDefender(target) {
    if (!game.user.isGM) {
      const payload = {
        target: target.id,
        scene: canvas.scene.id,
        opposeFlag: { opposeMessageId: this.data.messageId }
      };
      await SocketHandlers.executeOnUserAndWait("GM", "target", payload);
    }
    else {
      // Add oppose data flag to the target
      await target.actor.update({ "flags.oppose": { opposeMessageId: this.data.messageId } });
    }
  }

  /**
 * The opposed button was clicked, evaluate whether it is an attacker or defender, then proceed
 * to evaluate if necessary.
 * 
 * @param {Object} event Click event for opposed button click
 */
  static async opposedClicked(event) {
    let button = $(event.currentTarget),
      messageId = button.parents('.message').attr("data-message-id"),
      message = game.messages.get(messageId);

    if (game.wfrp4e.oppose && !game.wfrp4e.oppose.attackerMessage) {
      delete game.wfrp4e.oppose;
    }

    // Opposition already exists - click was defender
    if (game.wfrp4e.oppose) {
      await game.wfrp4e.oppose.setDefender(message);
      await game.wfrp4e.oppose.renderOpposedStart(); // Rerender opposed start with new message
      await game.wfrp4e.oppose.computeOpposeResult();
      delete game.wfrp4e.oppose;
    }
    // No opposition - click was attacker
    else {
      game.wfrp4e.oppose = new OpposedWFRP();
      await game.wfrp4e.oppose.setAttacker(message);
      await game.wfrp4e.oppose.renderOpposedStart();
    }
  }


  async resolveUnopposed() {
    this.data.unopposed = true;
    await this.computeOpposeResult();
    await this.defender.clearOpposed();
  }

  // Update starting message with result
  static async updateOpposedMessage(damageConfirmation, messageId) {
    let resultMessage = game.messages.get(messageId);
    let rollMode = resultMessage.rollMode;

    let newCard = {
      user: game.user.id,
      rollMode: rollMode,
      hideData: true,
      content: $(resultMessage.content).append(`<div>${damageConfirmation}</div>`).html()
    };
    
    await SocketHandlers.executeOnUserAndWait("GM", "updateMsg", { id: messageId, updateData: newCard });
  }
}

/**
 * ChatWFRP is the centralized object that handles all things involving rolling logic. At the base of roll evaluation, there is
 * rollTest() which provides the basics of roll evaluation - determining success, SL, etc. This function is used by more complex
 * test evaluation functions like rollWeaponTest, which calls rollTest, then extends upon it with more logic concerning weapons.
 * Another noteworthy function is renderRollCard, which is used to display the roll results of all tests. Lastly, this object
 * is where chat listeners are defined, which add interactivity to chat, usually in the form of button clickss.
 */


class ChatWFRP {


  // If content includes "@Condition[...]" add a button to apply that effect
  // Optionally provide a set of conditions
  static addEffectButtons(content, conditions = [])
  {
    // Don't add buttons if already added, or from posted items
    if (content.includes("apply-conditions") || content.includes("post-item"))
    {
      return content;
    }

    let regex = /@Condition\[(.+?)\]/gm;

    let matches = Array.from(content.matchAll(regex));

    conditions = conditions.concat(matches.map(m => m[1].toLowerCase())).filter(i => game.wfrp4e.config.conditions[i]);

    // Dedup
    conditions = conditions.filter((c, i) => conditions.indexOf(c) == i);

    if (conditions.length)
    {
      let html = `<div class="apply-conditions">`;
      conditions.forEach(c => 
          html += `<a class="chat-button apply-condition" data-cond="${c}">${game.i18n.format("CHAT.ApplyCondition", {condition: game.wfrp4e.config.conditions[c]})}</a>`
      );

      html += `</div>`;
      content += html;
    }
    return content
  }

  /**
   * Activate event listeners using the chat log html.
   * @param html {HTML}  Chat log html
   */
  static async chatListeners(html) {
    // item lookup tag looks for an item based on the location attribute (compendium), then posts that item to chat.

    // Lookp function uses specialized skill and talent lookup functions that improve searches based on specializations
    html.on("click", ".talent-lookup", async ev => {
      WFRP_Utility$1.findTalent(ev.target.text).then(talent => talent.sheet.render(true));
    });

    html.on("click", ".skill-lookup", async ev => {
      WFRP_Utility$1.findSkill(ev.target.text).then(skill => skill.sheet.render(true));
    });

    // If draggable skill/talent, right click to open sheet
    html.on("mousedown", ".talent-drag", async ev => {
      if (ev.button == 2)
        WFRP_Utility$1.findTalent(ev.target.text).then(talent => talent.sheet.render(true));
    });
    html.on("mousedown", ".skill-drag", async ev => {
      if (ev.button == 2)
        WFRP_Utility$1.findSkill(ev.target.text).then(skill => skill.sheet.render(true));
    });



    html.on("click", ".symptom-tag", WFRP_Utility$1.handleSymptomClick.bind(WFRP_Utility$1));
    html.on("click", ".condition-chat", WFRP_Utility$1.handleConditionClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.table-click', WFRP_Utility$1.handleTableClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.pay-link', WFRP_Utility$1.handlePayClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.credit-link', WFRP_Utility$1.handleCreditClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.corruption-link', WFRP_Utility$1.handleCorruptionClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.fear-link', WFRP_Utility$1.handleFearClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.terror-link', WFRP_Utility$1.handleTerrorClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.exp-link', WFRP_Utility$1.handleExpClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.travel-click', TravelDistanceWfrp4e.handleTravelClick.bind(TravelDistanceWfrp4e));

    html.on('change', '.card-edit', this._onCardEdit.bind(this));
    html.on('click', '.opposed-toggle', OpposedWFRP.opposedClicked.bind(OpposedWFRP));
    html.on("mousedown", '.overcast-button', this._onOvercastButtonClick.bind(this));
    html.on("mousedown", '.overcast-reset', this._onOvercastResetClicked.bind(this));
    html.on("click", '.vortex-movement', this._onMoveVortex.bind(this));
    html.on("click", '.unopposed-button', this._onUnopposedButtonClicked.bind(this));
    html.on("click", '.market-button', this._onMarketButtonClicked.bind(this));
    html.on("click", ".haggle", this._onHaggleClicked.bind(this));
    html.on("click", ".corrupt-button", this._onCorruptButtonClicked.bind(this));
    html.on("click", ".fear-button", this._onFearButtonClicked.bind(this));
    html.on("click", ".terror-button", this._onTerrorButtonClicked.bind(this));
    html.on("click", ".experience-button", this._onExpButtonClicked.bind(this));
    html.on("click", ".condition-script", this._onConditionScriptClick.bind(this));
    html.on("click", ".apply-target-effect", this._onApplyTargetEffect.bind(this));
    html.on("click", ".place-area-effect", this._onPlaceAreaEffect.bind(this));
    html.on("click", ".attacker, .defender", this._onOpposedImgClick.bind(this));
    html.on("click", ".apply-condition", this._onApplyCondition.bind(this));

    // Respond to template button clicks
    html.on("click", '.aoe-template', event => {
      
      let actorId = event.currentTarget.dataset.actorId;
      let itemId = event.currentTarget.dataset.itemId;
      let type = event.currentTarget.dataset.type;

      let messageId = $(event.currentTarget).parents('.message').attr("data-message-id");

      AbilityTemplate.fromString(event.currentTarget.text, actorId, itemId, messageId, type=="diameter").drawPreview(event);
    });

    html.on("click", '.place-area-effect', async event => {
      let messageId = $(event.currentTarget).parents('.message').attr("data-message-id");
      let effectUuid = event.currentTarget.dataset.uuid;

      let test = game.messages.get(messageId).getTest();
      let radius;
      if (test?.result.overcast)
      {
        radius = game.messages.get(messageId).getTest().result.overcast.usage.target.current;
      }

      (await AbilityTemplate.fromEffect(effectUuid, messageId, radius)).drawPreview(event);
    });
  

    // Post an item property (quality/flaw) description when clicked
    html.on("click", '.item-property', event => {
      WFRP_Utility$1.postProperty(event.target.text);
    });


    // Change card to edit mode
    html.on('click', '.edit-toggle', ev => {
      ev.preventDefault();
      this.toggleEditable(ev.currentTarget);
    });

  }


  // Respond to editing chat cards - take all inputs and call the same function used with the data filled out
  static _onCardEdit(ev) {
    let button = $(ev.currentTarget),
      messageId = button.parents('.message').attr("data-message-id"),
      message = game.messages.get(messageId);

    let test = message.getTest();
    test.context.edited = true;

    test.context.previousResult = duplicate(test.result);

    test.preData[button.attr("data-edit-type")] = parseInt(ev.target.value);

    if (button.attr("data-edit-type") == "hitloc") // If changing hitloc, keep old value for roll
      test.preData.roll = $(message.content).find(".card-content.test-data").attr("data-roll");
    else // If not changing hitloc, use old value for hitloc
      test.preData.hitloc = $(message.content).find(".card-content.test-data").attr("data-loc");

    if (button.attr("data-edit-type") == "SL") // If changing SL, keep both roll and hitloc
    {
      test.preData.roll = $(message.content).find(".card-content.test-data").attr("data-roll");
      test.preData.slBonus = 0;
      test.preData.successBonus = 0;
    }

    if (button.attr("data-edit-type") == "target") // If changing target, keep both roll and hitloc
      test.preData.roll = $(message.content).find(".card-content.test-data").attr("data-roll");


    // Send message as third argument (rerenderMessage) so that the message will be updated instead of rendering a new one

    test.roll();
  }

  /**
   * Toggles a chat card from to edit mode - switches to using <input>
   * 
   * @param {Object} html  chat card html
   */
  static toggleEditable(html) {
    let elementsToToggle = $(html).parents(".chat-card").find(".display-toggle");
    if (!elementsToToggle.length)
      elementsToToggle = $(html).find(".display-toggle");

    for (let elem of elementsToToggle) {
      if (elem.style.display == "none")
        elem.style.display = "";
      else
        elem.style.display = "none";
    }
  }

  // Respond to overcast button clicks
  static _onOvercastButtonClick(event) {
    event.preventDefault();
    let msg = game.messages.get($(event.currentTarget).parents('.message').attr("data-message-id"));
    if (!msg.isOwner && !msg.isAuthor)
      return ui.notifications.error("CHAT.EditError")

    let test = msg.getTest();
    let overcastChoice = event.currentTarget.dataset.overcast;
    // Set overcast and rerender card
    test._overcast(overcastChoice);
    
    //@HOUSE
    if (game.settings.get("wfrp4e", "mooOvercasting"))
    {
      game.wfrp4e.utility.logHomebrew("mooOvercasting");
    }
    //@/HOUSE

    
  }

  // Button to reset the overcasts
  static _onOvercastResetClicked(event) {
    event.preventDefault();
    let msg = game.messages.get($(event.currentTarget).parents('.message').attr("data-message-id"));
    if (!msg.isOwner && !msg.isAuthor)
      return ui.notifications.error("CHAT.EditError")

    let test = msg.getTest();
    // Reset overcast and rerender card
    test._overcastReset();
        
    //@HOUSE
    if (game.settings.get("wfrp4e", "mooOvercasting"))
    {
      game.wfrp4e.utility.logHomebrew("mooOvercasting");
    }
    //@/HOUSE
  }

  
  static _onMoveVortex(event)
  {
    let msg = game.messages.get($(event.currentTarget).parents('.message').attr("data-message-id"));
    if (!msg.isOwner && !msg.isAuthor)
      return ui.notifications.error("CHAT.EditError")
    let test = msg.getTest();
    test.moveVortex();

  }

  // Proceed with an opposed test as unopposed
  static _onUnopposedButtonClicked(event) {
    event.preventDefault();
    let messageId = $(event.currentTarget).parents('.message').attr("data-message-id");

    let oppose = game.messages.get(messageId).getOppose();
    oppose.resolveUnopposed();
  }

  // Click on botton related to the market/pay system
  static _onMarketButtonClicked(event) {
    event.preventDefault();
    let msg = game.messages.get($(event.currentTarget).parents(".message").attr("data-message-id"));
    // data-button tells us what button was clicked
    switch ($(event.currentTarget).attr("data-button")) {
      case "rollAvailability":
        MarketWfrp4e.generateSettlementChoice($(event.currentTarget).attr("data-rarity"));
        break;
      case "payItem":
        if (!game.user.isGM) {
          let actor = game.user.character;
          let itemData;
          if (msg.flags.transfer)
            itemData = JSON.parse(msg.flags.transfer).payload;
          if (actor) {
            let money = MarketWfrp4e.payCommand($(event.currentTarget).attr("data-pay"), actor);
            if (money) {
              WFRP_Audio.PlayContextAudio({ item: { "type": "money" }, action: "lose" });
              actor.updateEmbeddedDocuments("Item", money);
              if (itemData) {
                actor.createEmbeddedDocuments("Item", [itemData]);
                ui.notifications.notify(game.i18n.format("MARKET.ItemAdded", { item: itemData.name, actor: actor.name }));
              }
            }
          } else {
            ui.notifications.notify(game.i18n.localize("MARKET.NotifyNoActor"));
          }
        } else {
          ui.notifications.notify(game.i18n.localize("MARKET.NotifyUserMustBePlayer"));
        }
        break;
      case "creditItem":
        if (!game.user.isGM) {
          let actor = game.user.character;
          if (actor) {
            let dataExchange = $(event.currentTarget).attr("data-amount");
            let money = MarketWfrp4e.creditCommand(dataExchange, actor);
            if (money) {
              WFRP_Audio.PlayContextAudio({ item: { type: "money" }, action: "gain" });
              actor.updateEmbeddedDocuments("Item", money);
              let instances = msg.getFlag("wfrp4e", "instances") - 1;
              let messageUpdate = {};

              // Only allow credit to be taken as many times as it has been split
              // This allows a player to take multiple times if they wish, but not more than the original total amount
              // This solution might fail if two or more players click the button at the same time and create a race condition
              if (instances <= 0)
              {
                messageUpdate = { "content": `<p><strong>${game.i18n.localize("CHAT.NoMoreLeft")}</strong></p>` };
              }
              else 
              {
                messageUpdate = { "flags.wfrp4e.instances": instances };
              }
              game.socket.emit("system.wfrp4e", { type: "updateMsg", payload: { id: msg.id, updateData: messageUpdate } });
            }
          } else {
            ui.notifications.notify(game.i18n.localize("MARKET.NotifyNoActor"));
          }
        } else {
          ui.notifications.notify(game.i18n.localize("MARKET.NotifyUserMustBePlayer"));
        }
        break;
      case "rollAvailabilityTest":
        let options = {
          settlement: $(event.currentTarget).attr("data-settlement").toLowerCase(),
          rarity: $(event.currentTarget).attr("data-rarity").toLowerCase(),
          modifier: 0
        };
        MarketWfrp4e.testForAvailability(options);
        break;
    }
  }


  static _onHaggleClicked(event) {
    let html = $(event.currentTarget).parents(".message");
    let msg = game.messages.get(html.attr("data-message-id"));
    let multiplier = $(event.currentTarget).attr("data-type") == "up" ? 1 : -1;
    let payString = html.find("[data-button=payItem]").attr("data-pay");
    let originalPayString = payString;
    if (!msg.getFlag("wfrp4e", "originalPrice"))
      msg.setFlag("wfrp4e", "originalPrice", payString);
    else
      originalPayString = msg.getFlag("wfrp4e", "originalPrice");

    let originalAmount = MarketWfrp4e.parseMoneyTransactionString(originalPayString);
    let currentAmount = MarketWfrp4e.parseMoneyTransactionString(payString);

    let originalBPAmount = originalAmount.gc * 240 + originalAmount.ss * 12 + originalAmount.bp;
    let bpAmount = currentAmount.gc * 240 + currentAmount.ss * 12 + currentAmount.bp;
    bpAmount += Math.round((originalBPAmount * .1)) * multiplier;

    let newAmount = MarketWfrp4e.makeSomeChange(bpAmount, 0);
    let newPayString = MarketWfrp4e.amountToString(newAmount);
    html.find("[data-button=payItem]")[0].setAttribute("data-pay", newPayString);
    let newContent = html.find(".message-content").html();
    newContent = newContent.replace(`${currentAmount.gc} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${currentAmount.ss} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${currentAmount.bp} ${game.i18n.localize("MARKET.Abbrev.BP")}`, `${newAmount.gc} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${newAmount.ss} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${newAmount.bp} ${game.i18n.localize("MARKET.Abbrev.BP")}`);
    msg.update({ content: newContent });
  }

  static _onCorruptButtonClicked(event) {
    let strength = $(event.currentTarget).attr("data-strength").toLowerCase();
    if (strength != "moderate" && strength != "minor" && strength != "major")
      return ui.notifications.error(game.i18n.localize("ErrorCorruption"))

    let actors = canvas.tokens.controlled.map(t => t.actor);
    if (actors.length == 0)
      actors = [game.user.character];
    if (actors.length == 0)
      return ui.notifications.error(game.i18n.localize("ErrorCharAssigned"))


    actors.forEach(a => {
      a.corruptionDialog(strength);
    });
  }

  static _onFearButtonClicked(event) {
    let value = parseInt($(event.currentTarget).attr("data-value"));
    let name = $(event.currentTarget).attr("data-name");

    let targets = canvas.tokens.controlled.concat(Array.from(game.user.targets).filter(i => !canvas.tokens.controlled.includes(i)));
    if (canvas.scene) { 
      game.user.updateTokenTargets([]);
      game.user.broadcastActivity({targets: []});
    }


    if (game.user.isGM) {
      if (!targets.length)
        return ui.notifications.warn(game.i18n.localize("ErrorTarget"))
      targets.forEach(t => {
        t.actor.applyFear(value, name);
        if (canvas.scene) {
          game.user.updateTokenTargets([]);
          game.user.broadcastActivity({ targets: [] });
        }
      });
    }
    else {
      if (!game.user.character)
        return ui.notifications.warn(game.i18n.localize("ErrorCharAssigned"))
      game.user.character.applyFear(value, name);
    }
  }

  static _onTerrorButtonClicked(event) {
    let value = parseInt($(event.currentTarget).attr("data-value"));
    let name = parseInt($(event.currentTarget).attr("data-name"));
    
    let targets = canvas.tokens.controlled.concat(Array.from(game.user.targets).filter(i => !canvas.tokens.controlled.includes(i)));
    if (canvas.scene) {
      game.user.updateTokenTargets([]);      
      game.user.broadcastActivity({ targets: [] });
    }

    if (game.user.isGM) {
      if (!targets.length)
        return ui.notifications.warn(game.i18n.localize("ErrorTarget"))
      targets.forEach(t => {
        t.actor.applyTerror(value, name);
      });
    }
    else {
      if (!game.user.character)
        return ui.notifications.warn(game.i18n.localize("ErrorCharAssigned"))
      game.user.character.applyTerror(value, name);
    }
  }

  static _onExpButtonClicked(event) {
    let amount = parseInt($(event.currentTarget).attr("data-amount"));
    let reason = $(event.currentTarget).attr("data-reason");
    let msg = game.messages.get($(event.currentTarget).parents('.message').attr("data-message-id"));
    let alreadyAwarded = duplicate(msg.getFlag("wfrp4e", "experienceAwarded") || []);


    if (game.user.isGM) {
      if (!game.user.targets.size)
        return ui.notifications.warn(game.i18n.localize("ErrorExp"))
      game.user.targets.forEach(t => {
        if (!alreadyAwarded.includes(t.actor.id)) {
          t.actor.awardExp(amount, reason);
          alreadyAwarded.push(t.actor.id);
        }
        else
          ui.notifications.notify(`${t.actor.name} already received this reward.`);
      });
      msg.unsetFlag("wfrp4e", "experienceAwarded").then(m => {
        msg.setFlag("wfrp4e", "experienceAwarded", alreadyAwarded);
      });
      if (canvas.scene){ 
        game.user.updateTokenTargets([]);
        game.user.broadcastActivity({ targets: [] });
      }
    }
    else {
      if (!game.user.character)
        return ui.notifications.warn(game.i18n.localize("ErrorCharAssigned"))
      if (alreadyAwarded.includes(game.user.character.id))
        return ui.notifications.notify(`${game.user.character.name} already received this reward.`)

      alreadyAwarded.push(game.user.character.id);
      game.socket.emit("system.wfrp4e", { type: "updateMsg", payload: { id: msg.id, updateData: { "flags.wfrp4e.experienceAwarded": alreadyAwarded } } });
      game.user.character.awardExp(amount, reason);
    }
  }

  static async _onConditionScriptClick(event) {
    let condkey = event.target.dataset["condId"];
    let combatantId = event.target.dataset["combatantId"];
    let combatant = game.combat.combatants.get(combatantId);
    let msgId = $(event.currentTarget).parents(".message").attr("data-message-id");
    let message = game.messages.get(msgId);
    let conditionResult;

    if (combatant.actor.isOwner)
      conditionResult = await game.wfrp4e.config.conditionScripts[condkey](combatant.actor);
    else
      return ui.notifications.error(game.i18n.localize("CONDITION.ApplyError"))

    if (game.user.isGM)
      message.update(conditionResult);
    else
      await SocketHandlers.executeOnUserAndWait("GM", "updateMsg", { id: msgId, updateData: conditionResult });
  }

  static async _onApplyTargetEffect(event) {

    let uuid = event.target.dataset.uuid;// || (event.target.dataset.lore ? "lore" : "")
    let messageId = $(event.currentTarget).parents('.message').attr("data-message-id");
    let message = game.messages.get(messageId);
    let test = message.getTest();
    let actor = test.actor;
    let item = test.item;

    if (!actor.isOwner)
      return ui.notifications.error("CHAT.ApplyError")


    // let effect = actor.populateEffect(effectId, item, test)
    
    let targets = (game.user.targets.size ? game.user.targets : test.context.targets.map(t => WFRP_Utility$1.getToken(t))).map(t => t.actor);
    game.user.updateTokenTargets([]);
    game.user.broadcastActivity({ targets: [] });
     
          
    if (item && // If spell's Target and Range is "You", Apply to caster, not targets
      item.range && 
      item.range.value.toLowerCase() == game.i18n.localize("You").toLowerCase() && 
      item.target && 
      item.target.value.toLowerCase() == game.i18n.localize("You").toLowerCase())
      {
        targets = [actor];
      }

      for(let target of targets)
      {
        await target.applyEffect({effectUuids : uuid, messageId});
      }
  }

  static _onPlaceAreaEffect(event) {

    event.target.dataset.effectId || (event.target.dataset.lore ? "lore" : "");
    let messageId = $(event.currentTarget).parents('.message').attr("data-message-id");
    let message = game.messages.get(messageId);
    message.getTest();
  }

  static _onOpposedImgClick(event) {
    let msg = game.messages.get($(event.currentTarget).parents(".message").attr("data-message-id"));
    let oppose = msg.getOppose();
    let speaker;

    if ($(event.currentTarget).hasClass("attacker"))
      speaker = oppose.attacker;
    else if ($(event.currentTarget).hasClass("defender"))
      speaker = oppose.defender;

    speaker.sheet.render(true);

  }

  static _onApplyCondition(event) {
    let actors = canvas.tokens.controlled.concat(Array.from(game.user.targets).filter(i => !canvas.tokens.controlled.includes(i))).map(a => a.actor);

    if (actors.length == 0)
    {
      actors.push(game.user.character);
      ui.notifications.notify(`${game.i18n.format("EFFECT.Applied", {name: game.wfrp4e.config.conditions[event.currentTarget.dataset.cond]})} ${game.user.character.name}`);
    }

    actors.forEach(a => {
      a.addCondition(event.currentTarget.dataset.cond);
    });
  }

}

/**
 * Provides general useful functions for various different parts of the system.
 *
 * This is basically a catch-all for useful functions that don't quite fit anywhere
 * else, but is used by many different areas of the system. Most of these functions
 * involve retrieving data from the configuration values or the compendia.
 *
 */
class WFRP_Utility$1 {

  static CtrlKeyPressed = false;

  static _keepID(id, document) {
    try {
      let compendium = !!document.pack;
      let world = !compendium;
      let collection;

      if (compendium) {
        let pack = game.packs.get(document.pack);
        collection = pack.index;
      }
      else if (world)
        collection = document.collection;

      if (collection.has(id)) {
        ui.notifications.notify(`${game.i18n.format("ERROR.ID", {name: document.name})}`);
        return false
      }
      else return true
    }
    catch (e) {
      console.error(e);
      return false
    }
  }

  static propertyStringToArray(propertyString, propertyObject)
  {
      let newProperties = [];
      let oldProperties = propertyString.split(",").map(i => i.trim());
      for (let property of oldProperties) {
        if (!property)
          continue
  
        let newProperty = {};
        let splitProperty = property.split(" ");
        if (Number.isNumeric(splitProperty[splitProperty.length - 1])) {
          newProperty.value = parseInt(splitProperty[splitProperty.length - 1]);
          splitProperty.splice(splitProperty.length - 1, 1);
        }
  
        splitProperty = splitProperty.join(" ");
  
        newProperty.name = game.wfrp4e.utility.findKey(splitProperty, propertyObject);
        if (newProperty)
          newProperties.push(newProperty);
        else
          newProperties.push(property);
      }
      return newProperties
  }

  
  static propertyStringToObject(propertyString, propertyObject)
  {
      let array = this.propertyStringToArray(propertyString, propertyObject);
      return ItemWfrp4e._propertyArrayToObject(array, propertyObject)
  }

  /**
   * Roll characteristics given a species, or take average depending input
   * 
   * @param {string} species      Key or value for species in config
   * @param {bool} average        Take average or not
   */
  static async  speciesCharacteristics(species, average, subspecies) {
    let characteristics = {};
    let characteristicFormulae = game.wfrp4e.config.speciesCharacteristics[species];
    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].characteristics)
      characteristicFormulae = game.wfrp4e.config.subspecies[species][subspecies].characteristics;

    if (!characteristicFormulae) {
      ui.notifications.info(`${game.i18n.format("ERROR.Species", { name: species })}`);
      WFRP_Utility$1.log("Could not find species " + species + ": " + error, true);
      throw error
    }


    for (let char in game.wfrp4e.config.characteristics) {
      if (average) {
        // Take average - 2d10+20 -> split on +, take the 20, add 10 (average of 2d10). This assumes, perhaps erroneously, that all species will have a 2d10 randomizer
        characteristics[char] = { value: parseInt(characteristicFormulae[char].split("+")[1]) + 10, formula: characteristicFormulae[char] };
      }
      else {
        let roll = await new Roll(characteristicFormulae[char]).roll();
        characteristics[char] = { value: roll.total, formula: characteristicFormulae[char] + ` (${roll.result})` };
      }
    }
    return characteristics
  }


  static speciesSkillsTalents(species, subspecies) {
    let skills, talents;

    skills = game.wfrp4e.config.speciesSkills[species];
    talents = game.wfrp4e.config.speciesTalents[species];

    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].skills)
      skills = game.wfrp4e.config.subspecies[species][subspecies].skills;

    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].talents)
      talents = game.wfrp4e.config.subspecies[species][subspecies].talents;

    return { skills, talents }
  }

  /**
   * Retrieves species movement value from config.
   * 
   * @param {String} species  species key for lookup
   */
  static speciesMovement(species, subspecies) {
    let move = game.wfrp4e.config.speciesMovement[species];
    if (subspecies && game.wfrp4e.config.subspecies[species].movement)
      move = game.wfrp4e.config.subspecies[species].movement;
    return move;
  }

  /**
   * Searches an object for a key that matches the given value.
   * 
   * @param {String} value  value whose key is being searched for
   * @param {Object} obj    object to be searched in
   */
  static findKey(value, obj, options = {}) {
    if (!value || !obj)
      return undefined;

    if (options.caseInsensitive) {
      for (let key in obj) {
        if (obj[key].toLowerCase() == value.toLowerCase())
          return key;
      }
    }
    else {
      for (let key in obj) {
        if (obj[key] == value)
          return key;
      }
    }
  }

  static getSystemEffects() {
    let systemEffects = duplicate(game.wfrp4e.config.systemEffects);
    let symptomEffects = duplicate(game.wfrp4e.config.symptomEffects);

    mergeObject(systemEffects, symptomEffects);

    return systemEffects
  }

  static find(name, type)
  {
    if (type == "skill")
      return game.wfrp4e.utility.findSkill(name)
    if (type == "talent")
      return game.wfrp4e.utility.findTalent(name)
    else 
      return game.wfrp4e.utility.findItem(name, type)
  }

  
  static findItemId(id, type) {
    if (id.includes("."))
      return fromUuid(id);

    if (game.items.has(id))
      return game.items.get(id)

    let packs = game.wfrp4e.tags.getPacksWithTag(type);
    for (let pack of packs) {
      if (pack.index.has(id)) {
        return pack.getDocument(id)
      }
    }
  }


  /**
   * Specialized function to find a skill that accommodates for specializations.
   * 
   * Special considerations needs to be provided for finding skills because of specializations.
   * First, it will try to find the skill exactly, if that cannot be found, remove the specialization
   * and try to find any skill that would match if it had no specialization. If it is found, it will 
   * return that skill, renaming it to match the query.
   * 
   * For example, input could be Lore (Cheese), which doesn't exist. So it will try again testing
   * with just the skill "Lore", and trying to match it with any other skill by removing its 
   * specialization as well. Thus, lore matches with the first Lore skill, which should be 
   * the blank "Lore ()" skill. This is renamed as Lore (Cheese) and returned.
   * 
   * @param {String} skillName skill name to be searched for
   */
  static async findSkill(skillName) {
    let skill = await WFRP_Utility$1.findBaseName(skillName, "skill");
    if (!skill)
    {
      throw `"${game.i18n.format("ERROR.NoSkill", {skill: skillName})}"`
    }
    return skill
  }

  /**
   * Specialized function to find a talent that accommodates for specializations.
   * 
   * Special considerations needs to be provided for finding talents because of specializations.
   * First, it will try to find the talent exactly, if that cannot be found, remove the specialization
   * and try to find any talent that would match if it had no specialization. If it is found, it will 
   * return that talent, renaming it to match the query.
   * 
   * For example, input could be Etiquette (Cheesemongers), which doesn't exist. So it will try again testing
   * with just the talent "Etiquette", and trying to match it with any other talent by removing its 
   * specialization as well. Thus, Etiquette matches with the first Etiquette talent, which should be 
   * the blank "Etiquette ()" talent. This is renamed as Etiquette (Cheesemongers) and returned.
   * 
   * @param {String} talentName talent name to be searched for
   */
  static async findTalent(talentName) {
    // First try world items
    let talent = await WFRP_Utility$1.findBaseName(talentName, "talent");
    if (!talent)
    {
      throw `"${game.i18n.format("ERROR.NoTalent", {talent: talentName})}"`
    }
    return talent;
  }


  /**
   * Finds an item with the same base name (Prejudice (Target) == Prejudice (Nobles)).
   * 
   * @param {String} name item name to be searched for
   * @param {Collection} collection collection to search in, could be a world collection or pack index
   * @param {String} pack if collection is a pack index, include the pack to retrieve the document
   * 
   */
  static async findBaseName(name, type)
  {
    let baseName = this._extractBaseName(name);

    let searchResult = game.items.contents.find(t => t.type == type && (t.name == name || this._extractBaseName(t.name) == baseName));
    if (!searchResult)
    {
      // Search compendium packs for base name item
      for (let pack of game.wfrp4e.tags.getPacksWithTag(type)) {
        const index = pack.indexed ? pack.index : await pack.getIndex();
        let indexResult = index.find(t => this._extractBaseName(t.name) == this._extractBaseName(name) && (type == t.type)); // if type is specified, check, otherwise it doesn't matter
        if (indexResult)
          searchResult = await pack.getDocument(indexResult._id);
      }
    }

    if (searchResult) {
      let item = searchResult.clone();
      item.updateSource({ name }); // This is important if a specialized talent wasn't found. Without it, <Talent ()> would be added instead of <Talent (Specialization)>
      return item;
    }
  }

  static _extractBaseName(name)
  {
    return name.split("(")[0].trim();
  }


  /**
   * 
   * @param {String} itemName   Item name to be searched for 
   * @param {String|Array} itemType   Item's type (armour, weapon, etc.)
   */
  static async findItem(itemName, itemType) {
    itemName = itemName.trim();
    if (typeof itemType == "string")
    {
      itemType = [itemType];
    }

    let items;
    if (itemType?.length)
      items = game.items.contents.filter(i => itemType.includes(i.type));
    else 
      items = game.items.contents;

    // Search imported items first
    for (let i of items) {
      if (i.name.toLowerCase() == itemName.toLowerCase())
        return i;
    }
    let itemList;

    // If all else fails, search each pack. Search indices to avoid unnecessarily loading all documents
    for (let pack of game.wfrp4e.tags.getPacksWithTag(itemType)) {
      const index = pack.indexed ? pack.index : await pack.getIndex();
      itemList = index;
      let searchResult = itemList.find(t => t.name.toLowerCase() == itemName.toLowerCase() && (!itemType?.length || itemType?.includes(t.type))); // if type is specified, check, otherwise it doesn't matter
      if (searchResult)
        return await pack.getDocument(searchResult._id)
    }
  }

  /**
   * Gets every item of the type specified in the world and compendium packs (that have included a tag)
   * @param {String} type type of items to retrieve
   */
  static async findAll(type, loadingLabel = "") {
    let items = game.items.contents.filter(i => i.type == type);

    let packCounter = 0;
    let packs = game.wfrp4e.tags.getPacksWithTag(type);
    for (let p of packs) {
      if (loadingLabel)
      {
        packCounter++;
        SceneNavigation.displayProgressBar({label: loadingLabel, pct: (packCounter / packs.length)*100 });
      }
      let content = await p.getDocuments();
      items = items.concat(content.filter(i => i.type == type));
    }
    return items
  }


  // Used to sort arrays based on string value (used in organizing skills to be alphabetical - see ActorWfrp4e.prepareItems())
  static nameSorter(a, b) {
    if (a.name.toLowerCase() < b.name.toLowerCase())
      return -1;
    if (a.name.toLowerCase() > b.name.toLowerCase())
      return 1;
    return 0;
  }

  /**
   * Return a list of all qualities
   */
  static qualityList() {
    let weapon = duplicate(game.wfrp4e.config.weaponQualities);
    let armor = duplicate(game.wfrp4e.config.armorQualities);
    let item = duplicate(game.wfrp4e.config.itemQualities);
    let list = mergeObject(weapon, mergeObject(item, armor));
    return list;
  }


  /**
   * Return a list of all flaws
   */
  static flawList() {
    let weapon = duplicate(game.wfrp4e.config.weaponFlaws);
    let armor = duplicate(game.wfrp4e.config.armorFlaws);
    let item = duplicate(game.wfrp4e.config.itemFlaws);
    let list = mergeObject(weapon, mergeObject(item, armor));
    return list;
  }

  static allProperties() {
    return mergeObject(this.qualityList(), this.flawList())
  }

  /**
   * Looks up advancement cost based on current advancement and type.
   *
   * @param {Number} currentAdvances   Number of advances currently
   * @param {String} type              "characteristic" or "skill"
   * @param {Number} modifier          Cost modifier per advancement
   */
  static _calculateAdvCost(currentAdvances, type, modifier = 0) {
    let index = Math.floor(currentAdvances / 5);
    index = index < 0 ? 0 : index; // min 0

    if (index >= game.wfrp4e.config.xpCost[type].length)
      return game.wfrp4e.config.xpCost[type][game.wfrp4e.config.xpCost[type].length - 1] + modifier;
    return game.wfrp4e.config.xpCost[type][index] + modifier;
  }

  /**
   * Looks up a bulk advancement cost based on current advancement and type.
   *
   * @param {Number} start        Number of current advances
   * @param {Number} end          Target number of advances
   * @param {String} type         "characteristic" or "skill"
   * @param {Number} modifier     Cost modifier of the skill
   */
  static _calculateAdvRangeCost(start, end, type, modifier = 0) {
    let cost = 0;

    let multiplier = 1;

    // If reverse advance, multiply by -1 to grant XP back
    if (end < start) {
      multiplier = -1;
      let temp = end;
      end = start;
      start = temp;
    }

    while (start < end) {
      cost += this._calculateAdvCost(start, type, modifier);
      start++;
    }
    return cost * multiplier
  }

  static advancementDialog(item, advances, type, actor)
  {
    let start = item instanceof Item ? item.advances.value : actor.characteristics[item].advances;
    let end = advances;
    let name = item instanceof Item ? item.name : game.wfrp4e.config.characteristics[item];

    let career = false;
    try 
    {

      if (item instanceof Item)
      {
        let currentCareer = actor.currentCareer;
        if (currentCareer.system.skills.find(i => i == item.name))
        {
          career = true;
        }
      }
      else 
      {
        career = actor.system.characteristics[item].career;
      }
    }
    catch(e)
    {
      career = false;
    }
    return new Promise(resolve => {
      let xp = this._calculateAdvRangeCost(start, end, type, item.advances?.costModifier);
      if (!career)
      {
        xp *= 2;
      }
      if (xp) {
        new Dialog({
          title: game.i18n.localize("DIALOG.Advancement"),
          content: 
          `
          <p>${game.i18n.localize("DIALOG.AdvancementContent")}</p>
          <div class="form-group">
          <input type="number" value=${xp}>
          </div>
          `,
          buttons: {
            ok: {
              label: game.i18n.localize("Ok"),
              callback: async (dlg) => {
                xp = Number(dlg.find("input")[0]?.value) || xp;
                if (xp != 0)
                {
                  try {

                    let newSpent = actor.details.experience.spent + xp;
                    WFRP_Utility$1.checkValidAdvancement(actor.details.experience.total, newSpent, game.i18n.localize("ACTOR.ErrorImprove"), name);
                    let log = actor._addToExpLog(xp, `${name} (${end-start})`, newSpent);
                    actor.update({ "system.details.experience.spent": newSpent, "system.details.experience.log": log });
                    resolve(true);
                  }
                  catch (e)
                  {
                    ui.notifications.error(e);
                    resolve(false);
                  }
                }
              }
            },
            free: {
              label: game.i18n.localize("Free"),
              callback: () => { resolve(true); }
            }
          },
          close : () => {resolve(false);}
        }).render(true);
      }
      else resolve(true);
    })
  }

  static memorizeCostDialog(spell, actor) {
    return new Promise(resolve => {
      let xp = this.calculateSpellCost(spell, actor);
      if (xp) {
        new Dialog({
          title: game.i18n.localize("DIALOG.MemorizeSpell"),
          content: `<p>${game.i18n.format("DIALOG.MemorizeSpellContent", { xp })}</p>`,
          buttons: {
            ok: {
              label: game.i18n.localize("Ok"),
              callback: () => {
                let newSpent = actor.details.experience.spent + xp;
                let log = actor._addToExpLog(xp, game.i18n.format("LOG.MemorizedSpell", { name: spell.name }), newSpent);
                actor.update({ "system.details.experience.spent": newSpent, "system.details.experience.log": log });
                resolve(true);
              }
            },
            free: {
              label: game.i18n.localize("Free"),
              callback: () => { resolve(true); }
            }
          },
          close : () => {resolve(false);}
        }).render(true);
      }
      else resolve(true);
    })
  }


  
  static miracleGainedDialog(miracle, actor)
  {
    let xp = 100 * (actor.itemTypes["prayer"].filter(p => p.prayerType.value == "miracle").length);
    if (xp) {
      new Dialog({
        title: game.i18n.localize("DIALOG.GainPrayer"),
        content: `<p>${game.i18n.format("DIALOG.GainPrayerContent", { xp })}</p>`,
        buttons: {
          ok: {
            label: game.i18n.localize("Ok"),
            callback: () => {
              let newSpent = actor.details.experience.spent + xp;
              let log = actor._addToExpLog(xp, game.i18n.format("LOG.GainPrayer", { name: miracle.name }), newSpent);
              actor.update({ "system.details.experience.spent": newSpent, "system.details.experience.log": log });
            }
          },
          free: {
            label: game.i18n.localize("Free"),
            callback: () => { }
          }
        }
      }).render(true);
    }
  }

  static calculateSpellCost(spell, actor)
  {
    let cost = 0;
    let bonus = 0;
    let currentlyKnown = 0;

    if (spell.system.ritual.value)
    {
      return spell.system.ritual.xp;
    }


    if (["slaanesh", "tzeentch", "nurgle"].includes(spell.lore.value))
      return 0

    if (spell.lore.value == "petty" || spell.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty"))
      bonus = actor.characteristics.wp.bonus;
    else 
      bonus = actor.characteristics.int.bonus;

    if (spell.lore.value != "petty" && spell.lore.value != game.i18n.localize("WFRP4E.MagicLores.petty"))
    {
      currentlyKnown = actor.itemTypes["spell"].filter(i => i.lore.value == spell.lore.value && i.memorized.value).length;
    }
    else if (spell.lore.value == "petty" || spell.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty"))
    {
      currentlyKnown = actor.itemTypes["spell"].filter(i => i.lore.value == spell.lore.value).length;
      if (currentlyKnown < bonus)
        return 0 // First WPB petty spells are free
    }

    let costKey = currentlyKnown;
    if (spell.lore.value != "petty" && spell.lore.value != game.i18n.localize("WFRP4E.MagicLores.petty"))
      costKey++; // Not sure if this is right, but arcane and petty seem to scale different per th example given

    cost = Math.ceil(costKey / bonus) * 100;

    if (spell.lore.value == "petty" || spell.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty")) cost *= 0.5; // Petty costs 50 each instead of 100

    return cost
  }

  /**
   * Posts the symptom effects, then secretly posts the treatment to the GM.
   * 
   * @param {String} symptom  symptom name to be posted
   */
  static async postSymptom(symptom) {
    let symkey = WFRP_Utility$1.findKey(symptom.split("(")[0].trim(), game.wfrp4e.config.symptoms);
    let content = `<b>${symptom}</b>: ${game.wfrp4e.config.symptomDescriptions[symkey]}`;
    let chatOptions = {
      user: game.user.id,
      rollMode: game.settings.get("core", "rollMode"),
      content: content
    };
    if (["gmroll", "blindroll"].includes(chatOptions.rollMode)) chatOptions["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (chatOptions.rollMode === "blindroll") chatOptions["blind"] = true;
    ChatMessage.create(chatOptions);

    if (game.user.isGM) {
      content = `<b>${symptom} ${game.i18n.localize("Treatment")}</b>: ${game.wfrp4e.config.symptomTreatment[symkey]}`;
      chatOptions = {
        user: game.user.id,
        rollMode: game.settings.get("core", "rollMode"),
        content: await TextEditor.enrichHTML(content, {async: true})
      };
      chatOptions["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
      ChatMessage.create(chatOptions);
    }
  }

  /**
   * Posts the definition of a quality or flaw to chat.
   * 
   * @param {String} property   name of the quality or flaw
   */
  static  async postProperty(property) {
    let properties = mergeObject(WFRP_Utility$1.qualityList(), WFRP_Utility$1.flawList()),
      propertyDescr = Object.assign(duplicate(game.wfrp4e.config.qualityDescriptions), game.wfrp4e.config.flawDescriptions),
      propertyKey;

    property = this.parsePropertyName(property.replace(/,/g, '').trim());

    propertyKey = WFRP_Utility$1.findKey(property, properties);

    let propertyDescription = `<b>${property}:</b><br>${propertyDescr[propertyKey]}`;
    propertyDescription = propertyDescription.replace("(Rating)", property.split(" ")[1]);


    let chatOptions = {
      user: game.user.id,
      rollMode: game.settings.get("core", "rollMode"),
      content: await TextEditor.enrichHTML(propertyDescription, {async: true})
    };
    if (["gmroll", "blindroll"].includes(chatOptions.rollMode)) chatOptions["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (chatOptions.rollMode === "blindroll") chatOptions["blind"] = true;
    ChatMessage.create(chatOptions);
  }

  /**
   * Helper function to easily find the property name
   * // Todo: regex?
   * @param {String} property 
   */
  static parsePropertyName(property) {
    property = property.trim();
    if (!isNaN(property[property.length - 1]))
      return property.substring(0, property.length - 2).trim()
    else if (property.includes("("))
      return property.split("(")[0].trim()
    else
      return property;
  }

  /**
   * Helper function to set up chat data (set roll mode and content).
   * 
   * @param {String} content 
   * @param {String} modeOverride 
   * @param {Boolean} isRoll 
   */
  static chatDataSetup(content, modeOverride, isRoll = false, {forceWhisper, alias, flavor}={}) {
    let chatData = {
      user: game.user.id,
      rollMode: modeOverride || game.settings.get("core", "rollMode"),
      content: content
    };
    if (isRoll)
      chatData.sound = CONFIG.sounds.dice;

    if (["gmroll", "blindroll"].includes(chatData.rollMode)) chatData["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (chatData.rollMode === "blindroll") chatData["blind"] = true;
    else if (chatData.rollMode === "selfroll") chatData["whisper"] = [game.user.id];

    if (alias)
      chatData.speaker = {alias};
    if (flavor)
      chatData.flavor = flavor;

    if (forceWhisper) { // Final force !
      chatData["speaker"] = ChatMessage.getSpeaker();
      chatData["whisper"] = ChatMessage.getWhisperRecipients(forceWhisper);
    }

    return chatData;
  }

  /**
   * Looks through object values and finds the one that most closely matches the query, returning the key.
   * 
   * Used by condition lookup.
   * 
   * @param {Object} Object Object being searched in
   * @param {*} query Value trying to match
   */
  static matchClosest(object, query, options = {}) {
    query = query.toLowerCase();
    let keys = Object.keys(object);
    let match = [];
    for (let key of keys) {
      let percentage = 0;
      let matchCounter = 0;
      let myword;
      if (options.matchKeys)
        myword = key.toLowerCase();
      else
        myword = object[key].toLowerCase();
      for (let i = 0; i < myword.length; i++) {
        if (myword[i] == query[i]) {
          matchCounter++;
        }
      }
      percentage = matchCounter / key.length;
      match.push(percentage);
    }
    let maxIndex = match.indexOf(Math.max.apply(Math, match));
    return keys[maxIndex]
  }

  /**
   * Returns token speaker if available, otherwise, returns actor.
   * 
   * @param {Object} speaker  speaker object containing actor and otken
   */
  static getSpeaker(speaker) {
    let actor = game.actors.get(speaker.actor);
    if (speaker.token)
      actor = game.scenes.get(speaker.scene).tokens.get(speaker.token).actor;
    return actor
  }


  static getToken(speaker) {
    return game.scenes.get(speaker?.scene)?.tokens?.get(speaker?.token)
  }

  /**
   * Returns all basic skills from the skills compendium
   */
  static async allBasicSkills() {
    let returnSkills = [];

    const packs = game.wfrp4e.tags.getPacksWithTag(["skill"]);

    if (!packs.length)
      return ui.notifications.error(game.i18n.localize("ERROR.Found"))

    for (let pack of packs) {
      let items;
      await pack.getDocuments().then(content => items = content.filter(i => i.type == "skill"));
      for (let i of items) {
        if (i.system.advanced.value == "bsc") {
          if (i.system.grouped.value != "noSpec") {
            let skill = i.toObject();
            let startParen = skill.name.indexOf("(");
            skill.name = skill.name.substring(0, startParen).trim();
            if (returnSkills.filter(x => x.name.includes(skill.name)).length <= 0)
              returnSkills.push(skill);
          }
          else
            returnSkills.push(i.toObject());
        }
      }
    }
    WFRP_Utility$1.log("Found Basic Skills: ", undefined, returnSkills );
    return returnSkills;
  }

  /**
   * Returns Gold Crown, Silver Shilling, and Brass Penny from trappings compendium
   */
  static async allMoneyItems() {
    let moneyItems = [];
    const packs = game.wfrp4e.tags.getPacksWithTag("money");

    if (!packs.length)
      return ui.notifications.error(game.i18n.localize("ERROR.Found"))

    for (let pack of packs) {
      let items;
      await pack.getDocuments().then(content => items = content.filter(i => i.type == "money").map(i => i.toObject()));

      let money = items.filter(t => Object.values(game.wfrp4e.config.moneyNames).map(n => n.toLowerCase()).includes(t.name.toLowerCase()));

      moneyItems = moneyItems.concat(money);
    }
    WFRP_Utility$1.log("Found Money Items: ", undefined, moneyItems);
    return moneyItems
  }

  static alterDifficulty(difficulty, steps) {
    let difficulties = Object.keys(game.wfrp4e.config.difficultyLabels);
    let difficultyIndex = difficulties.findIndex(d => d == difficulty) + steps;
    difficultyIndex = Math.clamped(difficultyIndex, 0, difficulties.length - 1);
    return difficulties[difficultyIndex]
  }

  /**
   * Converts custom entity to clickable html element.
   * 
   * @param {String} match Entire string being converted (@Roll["1d8"])
   * @param {String} entityType Custom entity type - Roll, Table, etc
   * @param {String} id Input given in the custom link "1d8" above
   * @param {String} name Name given @Table["minormis"]{name}
   */
  static _replaceCustomLink(match, entityType, id, name) {
    let ids = id.split(","); // only used by fear/terror/exp for multiple arguments
    switch (entityType) {
      case "Roll":
        return `<a class="chat-roll" data-roll="${ids[0]}"><i class='fas fa-dice'></i> ${name ? name : id}</a>`
      case "Table":
        return `<a class = "table-click" data-table="${ids[0]}"><i class="fas fa-list"></i> ${(game.wfrp4e.tables.findTable(id)?.name && !name) ? game.wfrp4e.tables.findTable(id)?.name : name}</a>`
      case "Symptom":
        return `<a class = "symptom-tag" data-symptom="${ids[0]}"><i class='fas fa-user-injured'></i> ${name ? name : id}</a>`
      case "Condition":
        return `<a class = "condition-chat" data-cond="${ids[0]}"><i class='fas fa-user-injured'></i> ${name ? name : id}</a>`
      case "Pay":
        return `<a class = "pay-link" data-pay="${ids[0]}"><i class="fas fa-coins"></i> ${name ? name : id}</a>`
      case "Credit":
        return `<a class = "credit-link" data-credit="${ids[0]}"><i class="fas fa-coins"></i> ${name ? name : id}</a>`
      case "Corruption":
        return `<a class = "corruption-link" data-strength="${ids[0]}"><img src="systems/wfrp4e/ui/chaos.svg" height=15px width=15px style="border:none"> ${name ? name : id}</a>`
      case "Fear":
        return `<a class = "fear-link" data-value="${ids[0]}" data-name="${ids[1] || ""}"><img src="systems/wfrp4e/ui/fear.svg" height=15px width=15px style="border:none"> ${entityType} ${ids[0]}</a>`
      case "Terror":
        return `<a class = "terror-link" data-value="${ids[0]}" data-name="${ids[1] || ""}"><img src="systems/wfrp4e/ui/terror.svg" height=15px width=15px style="border:none"> ${entityType} ${ids[0]}</a>`
      case "Exp":
        return `<a class = "exp-link" data-amount="${ids[0]}" data-reason="${ids[1] || ""}"><i class="fas fa-plus"></i> ${name ? name : (ids[1] || ids[0])}</a>`
    }
  }

  /**
   * Collects data from the table click event and sends it to game.wfrp4e.tables to be rolled.
   * 
   * @param {Object} event  click event
   */
  static async handleTableClick(event) {
    let modifier = parseInt($(event.currentTarget).attr("data-modifier")) || 0;
    let html;
    let chatOptions = this.chatDataSetup("", game.settings.get("core", "rollMode"), true);

    if (event.button == 0 && game.user.isGM) {
      let clickText = event.target.text || event.target.textContent;
      if (clickText.trim() == game.i18n.localize("ROLL.CritCast")) {
        html = game.wfrp4e.tables.criticalCastMenu($(event.currentTarget).attr("data-table"));
      }

      else if (clickText.trim() == game.i18n.localize("ROLL.TotalPower"))
        html = game.wfrp4e.tables.restrictedCriticalCastMenu();

      // Not really a table but whatever
      else if ($(event.currentTarget).attr("data-table") == "misfire") {
        let damage = $(event.currentTarget).attr("data-damage");
        html = game.i18n.format("ROLL.Misfire", { damage: damage });
      }
      else {
        html = await game.wfrp4e.tables.formatChatRoll($(event.currentTarget).attr("data-table"),
          {
            modifier: modifier,
            showRoll: true
          }, $(event.currentTarget).attr("data-column"));
      }

      chatOptions["content"] = html;
      chatOptions["type"] = 0;
      if (html)
        ChatMessage.create(chatOptions);

    }
  }

  /**
   * Post condition when clicked.
   * 
   * @param {Object} event click event
   */
  static handleConditionClick(event) {
    let cond = $(event.currentTarget).attr("data-cond");
    if (!cond)
      cond = event.target.text.trim();
    if (!isNaN(cond.split(" ").pop())) // check if the condition level is specified
      cond = cond.split(" ").slice(0, -1).join(" "); // remove the condition level
    let condkey = WFRP_Utility$1.findKey(cond, game.wfrp4e.config.conditions, { caseInsensitive: true });
    let condName = game.wfrp4e.config.conditions[condkey];
    let condDescr = game.wfrp4e.config.conditionDescriptions[condkey];
    let messageContent = `<b>${condName}</b><br>${condDescr}`;

     messageContent = ChatWFRP.addEffectButtons(messageContent, [condkey]);

    let chatData = WFRP_Utility$1.chatDataSetup(messageContent);
    ChatMessage.create(chatData);
  }

  /**
   * Post symptom when clicked
   * 
   * @param {Object} event click event
   */
  static handleSymptomClick(event) {
    let symptom = $(event.currentTarget).attr("data-symptom");
    if (!symptom)
      symptom = event.target.text;
    WFRP_Utility$1.postSymptom(symptom);
  }

  /**
   * Roll to chat when roll entity is clicked
   * 
   * @param {Object} event clicke event
   */
  static async handleRollClick(event) {
    let roll = $(event.currentTarget).attr("data-roll");
    if (!roll)
      roll = event.target.text.trim();
    let rollMode = game.settings.get("core", "rollMode");
    (await new Roll(roll).roll()).toMessage(
      {
        user: game.user.id,
        rollMode
      });
  }


  /**
 * Handle a payment entity link
 * 
 * @param {Object} event clicke event
 */
  static handlePayClick(event) {
    let payString = $(event.currentTarget).attr("data-pay");
    if (game.user.isGM)
      MarketWfrp4e.generatePayCard(payString);
  }

  static handleCreditClick(event) {
    let creditString = $(event.currentTarget).attr("data-credit");
    let amt = creditString.split(" ")[0];
    let option = creditString.split(" ")[1];
    if (game.user.isGM)
      MarketWfrp4e.processCredit(amt, option);

  }

  static handleCorruptionClick(event) {
    return this.postCorruptionTest($(event.currentTarget).attr("data-strength"));
  }

  static postCorruptionTest(strength) {
    renderTemplate("systems/wfrp4e/templates/chat/corruption.hbs", { strength }).then(html => {
      ChatMessage.create({ content: html });
    });
  }


  static handleFearClick(event) {
    let target = $(event.currentTarget);
    return this.postFear(target.attr("data-value"), target.attr("data-name"));
  }

  static postFear(value = 0, name = undefined) {
    if (isNaN(value))
      value = 0;
    let title = `${game.i18n.localize("CHAT.Fear")} ${value}`;
    if (name)
      title += ` - ${name}`;
    renderTemplate("systems/wfrp4e/templates/chat/fear.hbs", { value, name, title }).then(html => {
      ChatMessage.create({ content: html, speaker: { alias: name } });
    });
  }

  static handleTerrorClick(event) {
    let target = $(event.currentTarget);
    return this.postTerror(target.attr("data-value"), target.attr("data-name"));
  }

  static handleExpClick(event) {
    let target = $(event.currentTarget);
    return this.postExp(target.attr("data-amount"), target.attr("data-reason"));
  }

  static postTerror(value = 1, name = undefined) {
    if (isNaN(value))
      value = 1;
    let title = `${game.i18n.localize("CHAT.Terror")} ${value}`;
    if (name)
      title += ` - ${name}`;
    renderTemplate("systems/wfrp4e/templates/chat/terror.hbs", { value, name, title }).then(html => {
      ChatMessage.create({ content: html, speaker: { alias: name } });
    });
  }


  static postExp(amount, reason = undefined) {
    if (isNaN(amount))
      return ui.notifications.error(game.i18n.localize("ERROR.Experience"))

    let title = `${game.i18n.localize("CHAT.Experience")}`;

    renderTemplate("systems/wfrp4e/templates/chat/experience.hbs", { title, amount, reason }).then(html => {
      ChatMessage.create({ content: html });
    });
  }


  static _onDragConditionLink(event) {
    event.stopPropagation();
    const a = event.currentTarget;
    let dragData = null;
    dragData = { type: "condition", payload: a.dataset.cond };

    event.originalEvent.dataTransfer.setData("text/plain", JSON.stringify(dragData));
  }

  /**
   * Retrieves the item being requested by the macro from the selected actor,
   * sending it to the correct setup____ function to be rolled.
   * 
   * @param {String} itemName name of item being rolled
   * @param {String} itemType type of item ("weapon", "spell", etc)
   */
  static rollItemMacro(itemName, itemType, bypassData) {
    const speaker = ChatMessage.getSpeaker();
    let actor;
    if (speaker.token) actor = game.actors.tokens[speaker.token];
    if (!actor) actor = game.actors.get(speaker.actor);
    let item;
    // Not technically an item, used for convenience
    if (itemType == "characteristic") {
      return actor.setupCharacteristic(itemName, bypassData).then(test => test.roll());
    }
    else {
      item = actor ? actor.itemTypes[itemType].find(i => i.name === itemName) : null;
    }
    if (!item) return ui.notifications.warn(`${game.i18n.localize("ErrorMacroItemMissing")} ${itemName}`);

    // Trigger the item roll
    switch (item.type) {
      case "weapon":
        return actor.setupWeapon(item, bypassData).then(test => test.roll());
      case "spell":
        return actor.sheet.spellDialog(item, bypassData)
      case "prayer":
        return actor.setupPrayer(item, bypassData).then(test => test.roll());
      case "trait":
        return actor.setupTrait(item, bypassData).then(test => test.roll());
      case "skill":
        return actor.setupSkill(item, bypassData).then(test => test.roll());
    }
  }

  static async toggleMorrslieb() {

    let morrsliebActive = canvas.scene.getFlag("wfrp4e", "morrslieb");
    morrsliebActive = !morrsliebActive;
    await canvas.scene.setFlag("wfrp4e", "morrslieb", morrsliebActive);

    if (game.modules.get("fxmaster") && game.modules.get("fxmaster").active) {
      FXMASTER.filters.switch("morrslieb", "color", CONFIG.MorrsliebObject);
    }
    else {
      game.socket.emit("system.wfrp4e", {
        type: "morrslieb"
      });
      canvas.draw();
    }
  }

  /**
  * Checks that the selected advancement can be afforded by the actor
  *
  * @param {Integer} total: the xp total for the actor
  * @param {Integer} spent: the spent xp plus cost
  * @param {String} action: the action, buy or improve for example
  * @param {String} item: the title of the skill, talent or characteristic
  */
  static checkValidAdvancement(total, spent, action, item) {
    if(total - spent < 0) {
       throw new Error(game.i18n.format("ACTOR.AdvancementError", { action: action, item: item }));
    }
  }


  static updateGroupAdvantage({players=undefined, enemies=undefined}={})
  {
    if (!game.user.isGM)
    {
      game.socket.emit("system.wfrp4e", {type : "changeGroupAdvantage", payload : {players, enemies}});
    }
    else 
    {
      let advantage = game.settings.get("wfrp4e", "groupAdvantageValues");
      if (Number.isNumeric(players))
        advantage.players = players;
      if (Number.isNumeric(enemies))
        advantage.enemies = enemies;
    
      return game.settings.set("wfrp4e", "groupAdvantageValues", advantage)
    }
  }

  //@HOUSE
  static optimalDifference(weapon, range)
  {
    let keys = Object.keys(game.wfrp4e.config.rangeBands);
    let rangeKey = this.findKey(range, game.wfrp4e.config.rangeBands);
    let weaponRange = weapon.getFlag("wfrp4e", "optimalRange");
    if (!weaponRange || !rangeKey)
      return 1
    
    return Math.abs(keys.findIndex(i => i == rangeKey) - keys.findIndex(i => i == weaponRange))
  }
  //@/HOUSE


  static log(message, force=false, args) {
    if (CONFIG.debug.wfrp4e || force)
      console.log(`%cWFRP4e` + `%c | ${message}`, "color: gold", "color: unset", args || "");
  }

  
  static logHomebrew(message) {
    this.log("Applying Homebrew Rule: " + message, true);
  }

  static extractLinkLabel(link)
  {
    let text;
    try {
      // Extract text
      text = Array.from(link.matchAll(/{(.+?)}/gm))[0][1];
      if (!text)
        text = link;
    }
    catch(e)
    {
      text = link;
    }
    return text
  }


  // Since popout tokens display very small in HTML, try to replace them
  static replacePopoutTokens(html) {
    // Try to replace popout tokens in chat
    let images = html.find('img:not(.profile)'); // This is required to prevent saving the absolute actor image path
    Array.from(images).forEach(async element => {
      element.src = this.replacePopoutPath(element.src);
    });
  }

  static replacePopoutPath(path)
  {
    if (path.includes("tokens/popout/")) { 
      WFRP_Utility$1.log("Replacing popout token: " + path);
    }
    return path.replace("tokens/popout/", "tokens/");
  }

  static async sleep(ms) {
    await new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Find the owner of a document, prioritizing non-GM users 
   * 
   * @param {Object} document Document whose owner is being found
   * @returns 
   */
    static getActiveDocumentOwner(document)
    {
        // let document = fromUuidSync(uuid);
        if (document.documentName == "Item" && document.isOwned)
        {
            document = document.actor;
        }
        let activePlayers = game.users.contents.filter(u => u.active && u.role <= 2 && u.name != "Stream"); // Not assistant or GM 
        let owningUser;

        // First, prioritize if any user has this document as their assigned character
        owningUser = activePlayers.find(u => u.character?.id == document.id);

        // If not found, find the first non-GM user that can update this document
        if (!owningUser)
        {
            owningUser = activePlayers.find(u => document.testUserPermission(u, "OWNER"));
        }

        // If still no owning user, simply find the first GM
        if (!owningUser)
        {
            owningUser = game.users.contents.filter(u => u.active).find(u => u.isGM);
        }
        return owningUser;
    }
 


  static async setupSocket(owner, payload, content) {
    let chatData = {
      content: "<b><u>" + owner.name + "</u></b>: " + content,
      whisper: ChatMessage.getWhisperRecipients("GM")
    };
    if (game.user.isGM) {
      chatData.user = owner;
    }
    let msg = await ChatMessage.create(chatData);
    payload.messageId = msg.id;
    await SocketHandlers.executeOnUserAndWait(owner.id, "setupSocket", payload);
    msg = game.messages.get(msg.id);
    if (!msg) {
      return null;
    } else {
      const test = TestWFRP.recreate(msg.flags.data.test.data);
      return test;
    }
  }

  static _setSocketTests(event) {
    WFRP_Utility$1.CtrlKeyPressed = true;
  }

  static _resetSocketTests(event) {
    WFRP_Utility$1.CtrlKeyPressed = false;
  }

  static IsSocketTest() {
    const useSocketTests = game.settings.get("wfrp4e","useSocketTests");
    if (useSocketTests && !WFRP_Utility$1.CtrlKeyPressed) {
      return true;
    }
    if (!useSocketTests && WFRP_Utility$1.CtrlKeyPressed) {
      return true;
    }
    return false;
  }

  static mergeCareerReplacements(replacements)
  {

    // For each species in added replacements
    for(let species in replacements)
    {
      // Check if there already is a species listing
      if (game.wfrp4e.config.speciesCareerReplacements[species])
      {
        let currentReplacements = game.wfrp4e.config.speciesCareerReplacements[species];

        // For each career in the added replacements
        for(let career in replacements[species])
        {
          // If there are replacement options already, concatenate them
          if (currentReplacements[career]?.length > 0)
          {
            currentReplacements[career] = currentReplacements[career].concat(replacements[species][career]);
          }
          else  // If no current replacement opions, simply use the added replacements
          {
            currentReplacements[career] = replacements[species][career];
          }
        }
      }
      else // If no species listing, simply use the added replacements 
      {
        game.wfrp4e.config.speciesCareerReplacements[species] = replacements[species];
      }
    }
  }

  // Add the source of a compendium link
  // e.g. Compendium.wfrp4e-core -> (WFRP4e Core Rulebook) tooltip
  static addLinkSources(html)
  {
    html.find(".content-link").each((index, element) => {
      let uuid = element.dataset.uuid;
      let tooltip = element.dataset.tooltip || "";
      if (uuid)
      {
        let moduleKey = uuid.split(".")[1];
        if (game.wfrp4e.config.premiumModules[moduleKey])
        {
          if (!tooltip)
          {
            tooltip = `${game.wfrp4e.config.premiumModules[moduleKey]}`;
          }
          else 
          {
            tooltip += ` (${game.wfrp4e.config.premiumModules[moduleKey]})`;
          }
        }
      }

      element.dataset.tooltip = tooltip;

    });
  }
}


Hooks.on("renderFilePicker", (app, html, data) => {
  let folder = data.target.split("/")[0];
  if (folder == "systems" || folder == "modules") {
    html.find("input[name='upload']").css("display", "none");
    let label = html.find(".upload-file label");
    label.text("Upload Disabled");
    label.append(`<i data-tooltip="Upload disabled while in system directory. DO NOT put your assets within any system or module folder." style="display:inline-block; margin-left:5px;" class="fa-regular fa-circle-question"></i>`);
  }
});

/**
 * WIP
 * This class contains functions and helpers related to the market and Pay system
 */
class MarketWfrp4e {
  /**
   * Roll a test for the availability and the stock quantity of an item based on the rulebook
   * Takes as a parameter an object with localized settlement type, localized rarity and a modifier for the roll
   * @param {Object} options settlement, rarity, modifier
   */
  static async testForAvailability({ settlement, rarity, modifier }) {
    //This method read the table  game.wfrp4e.config.availabilityTable defined in the config file

    //First we get the different settlements size
    let validSettlements = Object.getOwnPropertyNames(game.wfrp4e.config.availabilityTable);
    let validSettlementsLocalized = {};
    let validRarityLocalized = {};

    //For each settlements we found in the config, we try to translate them and we build a correlation table
    validSettlements.forEach(function (index) {
      validSettlementsLocalized[game.i18n.localize(index).toLowerCase()] = index;
    });

    //If we found a valid settlement size, we now do the same thing for the rarity datas
    if (settlement && validSettlementsLocalized.hasOwnProperty(settlement)) {
      let validRarity = Object.getOwnPropertyNames(game.wfrp4e.config.availabilityTable[validSettlementsLocalized[settlement]]);
      validRarity.forEach(function (index) {
        validRarityLocalized[game.i18n.localize(index).toLowerCase()] = index;
      });
    }

    let msg = `<h3><b>${game.i18n.localize("MARKET.AvailabilityTest")}</b></h3>`;

    //If at least one of the args isnt specified or if the specified options are not valid, we give informations on the correct syntax
    if (!settlement || !rarity || !validSettlementsLocalized.hasOwnProperty(settlement) || !validRarityLocalized.hasOwnProperty(rarity)) {
      msg += `<p>${game.i18n.localize("MARKET.AvailWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.AvailCommandExample")}</i></p>`;
    }
    //Everything is ok, lets roll for availability
    else {
      let roll = await new Roll("1d100 - @modifier", { modifier: modifier }).roll();
      //we retrieve the correct line
      let availabilityLookup = game.wfrp4e.config.availabilityTable[validSettlementsLocalized[settlement]][validRarityLocalized[rarity]];
      let isAvailable = availabilityLookup.test > 0 && roll.total <= availabilityLookup.test;

      let finalResult = {
        settlement: settlement.charAt(0).toUpperCase() + settlement.slice(1),
        rarity: rarity.charAt(0).toUpperCase() + rarity.slice(1),
        instock: isAvailable ? game.i18n.localize("Yes") : game.i18n.localize("No"),
        quantity: isAvailable ? availabilityLookup.stock : 0,
        roll: roll.total
      };

      //We roll the stock if we detect a valid roll value
      if (availabilityLookup.stock.includes("d")) {
        let stockRoll = await new Roll(availabilityLookup.stock).roll();
        finalResult.quantity = stockRoll.total;
      }

      //Format the message before sending it back to chat
      msg += this.formatTestForChat(finalResult);
    }
    ChatMessage.create(WFRP_Utility$1.chatDataSetup(msg, "roll", true));
  }

  /**
   * Format an availability test before sending it to chat
   * @param {Object} result
   */
  static formatTestForChat(result) {
    return `
        <b>${game.i18n.localize("MARKET.SettlementSize")}</b> ${result.settlement}<br>
        <b>${game.i18n.localize("MARKET.Rarity")}</b> ${result.rarity}<br><br>
        <b>${game.i18n.localize("MARKET.InStock")}</b> ${result.instock}<br>
        <b>${game.i18n.localize("MARKET.QuantityAvailable")}</b> ${result.quantity}<br>
        <b>${game.i18n.localize("Roll")}:</b> ${result.roll}
      `;
  }

  /**
   * Send a whispered card menu to the player to start an availability test
   * The card let him choose a settlement size
   * @param {String} rarity
   */
  static generateSettlementChoice(rarity) {
    let cardData = { rarity: game.wfrp4e.config.availability[rarity] };
    renderTemplate("systems/wfrp4e/templates/chat/market/market-settlement.hbs", cardData).then(html => {
      let chatData = WFRP_Utility$1.chatDataSetup(html, "selfroll");
      ChatMessage.create(chatData);
    });
  }

  /**
   * Consolidate every money the player has in order to give him the fewer coins possible
   * @param {Array} money
   */
  static consolidateMoney(money) {
    //We sort the money from the highest BP value to the lowest (so gc => ss => bp)
    //This allow us to deal with custom money too and to not be dependent on the money name (translation errors could break the code otherwise)
    money.sort((a, b) => b.system.coinValue.value - a.system.coinValue.value);

    let brass = 0;
    //First we calculate the BP value
    for (let m of money)
      brass += m.system.quantity.value * m.system.coinValue.value;

    //Then we consolidate the coins
    for (let m of money) {
      //We don't know what players could create as a custom money and we dont want to divide by zero, ever. It would kill a kitten somewhere, probably.
      if (m.system.coinValue.value <= 0)
        break;
      m.system.quantity.value = Math.trunc(brass / m.system.coinValue.value);
      brass = brass % m.system.coinValue.value;
    }

    return money;
  }

  /**
   * Execute a /credit amount and add the money to the player inventory
   * @param {string} amount the amount of money transfered
   * @param {Array} moneyItemInventory
   */
  static creditCommand(amount, actor, options = {}) {
    //First we parse the amount
    let moneyItemInventory = actor.getItemTypes("money").map(i => i.toObject());
    let moneyToSend = this.parseMoneyTransactionString(amount);
    let msg = `<h3><b>${game.i18n.localize("MARKET.CreditCommand")}</b></h3>`;
    let errorOccured = false;
    //Wrong amount
    if (!moneyToSend) {
      msg += `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.CreditCommandExample")}</i></p>`;
      errorOccured = true;
    }
    //Command is ok, let's try to pay
    else {
      //We need to get the character money items for gc, ss and bp. This is a "best effort" lookup method. If it fails, we stop the amount to prevent any data loss.
      let characterMoney = this.getCharacterMoney(moneyItemInventory);
      this.checkCharacterMoneyValidity(moneyItemInventory, characterMoney);

      //If one money is missing, we stop here before doing anything bad
      if (Object.values(characterMoney).includes(false)) {
        msg += `<p>${game.i18n.localize("MARKET.CantFindMoneyItems")}</p>`;
        errorOccured = true;
      } else {
        //Great, we can just deduce the quantity for each money
        moneyItemInventory[characterMoney.gc].system.quantity.value += moneyToSend.gc;
        moneyItemInventory[characterMoney.ss].system.quantity.value += moneyToSend.ss;
        moneyItemInventory[characterMoney.bp].system.quantity.value += moneyToSend.bp;
      }
    }
    if (errorOccured)
      moneyItemInventory = false;
    else {
      msg += game.i18n.format("MARKET.Credit", {
        number1: moneyToSend.gc,
        number2: moneyToSend.ss,
        number3: moneyToSend.bp
      });
      msg += `<br><b>${game.i18n.localize("MARKET.ReceivedBy")}</b> ${actor.name}`;
      this.throwMoney(moneyToSend);

    }
    if (options.suppressMessage)
      ui.notifications.notify(`${actor.name} received ${moneyToSend.gc}${game.i18n.localize("MARKET.Abbrev.GC")} ${moneyToSend.ss}${game.i18n.localize("MARKET.Abbrev.SS")} ${moneyToSend.bp}${game.i18n.localize("MARKET.Abbrev.BP")}`);
    else
      ChatMessage.create(WFRP_Utility$1.chatDataSetup(msg, "roll"));
    return moneyItemInventory;
  }

  /**
   * Execute a /pay command and remove the money from an actor inventory, without chat card
   * @param {String} amount
   * @param {Actor} actor
   */
   static directPayCommand(amount, actor, options = {}) {
    let moneyPaid = this.payCommand(amount, actor);
    if (moneyPaid) {
      actor.updateEmbeddedDocuments("Item", moneyPaid);
    }
  }

  /**
   * Execute a /pay command and remove the money from the player inventory
   * @param {String} command
   * @param {Array} moneyItemInventory
   * @param transactionType  game.wfrp4e.config.transactionType, is it a payment or an income
   */
  static payCommand(command, actor, options = {}) {
    //First we parse the command
    let moneyItemInventory = actor.getItemTypes("money").map(i => i.toObject());
    let moneyToPay = this.parseMoneyTransactionString(command);
    let msg = `<h3><b>${game.i18n.localize("MARKET.PayCommand")}</b></h3>`;
    let errorOccured = false;
    //Wrong command
    if (!moneyToPay) {
      msg += `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.PayCommandExample")}</i></p>`;
      errorOccured = true;
    }
    //Command is ok, let's try to pay
    else {
      //We need to get the character money items for gc, ss and bp. This is a "best effort" lookup method. If it fails, we stop the command to prevent any data loss.
      let characterMoney = this.getCharacterMoney(moneyItemInventory);
      this.checkCharacterMoneyValidity(moneyItemInventory, characterMoney);
      //If one money is missing, we stop here before doing anything bad
      if (Object.values(characterMoney).includes(false)) {
        msg += `<p>${game.i18n.localize("MARKET.CantFindMoneyItems")}</p>`;
        errorOccured = true;
      } else {
        //Now its time to check if the actor has enough money to pay
        //We'll start by trying to pay without consolidating the money
        if (moneyToPay.gc <= moneyItemInventory[characterMoney.gc].system.quantity.value &&
          moneyToPay.ss <= moneyItemInventory[characterMoney.ss].system.quantity.value &&
          moneyToPay.bp <= moneyItemInventory[characterMoney.bp].system.quantity.value) {
          //Great, we can just deduce the quantity for each money
          moneyItemInventory[characterMoney.gc].system.quantity.value -= moneyToPay.gc;
          moneyItemInventory[characterMoney.ss].system.quantity.value -= moneyToPay.ss;
          moneyItemInventory[characterMoney.bp].system.quantity.value -= moneyToPay.bp;
        } else //We'll need to calculate the brass value on both the pay command and the actor inventory, and then consolidate
        {
          let totalBPAvailable = 0;
          for (let m of moneyItemInventory)
            totalBPAvailable += m.system.quantity.value * m.system.coinValue.value;

          let totalBPPay = moneyToPay.gc * 240 + moneyToPay.ss * 12 + moneyToPay.bp;

          //Does we have enough money in the end?
          if (totalBPAvailable < totalBPPay) {
            //No
            msg += `${game.i18n.localize("MARKET.NotEnoughMoney")}<br>
              <b>${game.i18n.localize("MARKET.MoneyNeeded")}</b> ${totalBPPay} ${game.i18n.localize("NAME.BP")}<br>
              <b>${game.i18n.localize("MARKET.MoneyAvailable")}</b> ${totalBPAvailable} ${game.i18n.localize("NAME.BP")}`;
            errorOccured = true;
          } else //Yes!
          {
            totalBPAvailable -= totalBPPay;
            moneyItemInventory[characterMoney.gc].system.quantity.value = 0;
            moneyItemInventory[characterMoney.ss].system.quantity.value = 0;
            moneyItemInventory[characterMoney.bp].system.quantity.value = totalBPAvailable;

            //Then we consolidate
            moneyItemInventory = this.consolidateMoney(moneyItemInventory);
          }
        }
      }
    }
    if (errorOccured) {
      moneyItemInventory = false;
    } else {
      msg += game.i18n.format("MARKET.Paid", {
        number1: moneyToPay.gc,
        number2: moneyToPay.ss,
        number3: moneyToPay.bp
      });
      msg += `<br><b>${game.i18n.localize("MARKET.PaidBy")}</b> ${actor.name}`;

      this.throwMoney(moneyToPay);
    }
    if (options.suppressMessage)
      ui.notifications.notify(msg);
    else
      ChatMessage.create(WFRP_Utility$1.chatDataSetup(msg, "roll"));
    return moneyItemInventory;
  }

  /**
   * we'll try to look for the coin value equals to the gc/ss/bp coin value for any entry that wasn't found.
   * This allows for a better chance at detecting the money items, as they are currently not properly identified by a unique id. Meaning if a translation module made a typo in the compendium
   * or if a player/gm edit the name of the money items for any reasons, it would not be found by the first method
   * @param moneyItemInventory
   * @param characterMoney
   */
  static checkCharacterMoneyValidity(moneyItemInventory, characterMoney) {
    for (let m = 0; m < moneyItemInventory.length; m++) {
      switch (moneyItemInventory[m].system.coinValue.value) {
        case 240://gc
          if (characterMoney.gc === false)
            characterMoney.gc = m;
          break;
        case 12://ss
          if (characterMoney.ss === false)
            characterMoney.ss = m;
          break;
        case 1://bp
          if (characterMoney.bp === false)
            characterMoney.bp = m;
          break;
      }
    }
  }

  /**
   * From a moneyItemInventory we get the money of the character (GC, SS and BP)
   * @param moneyItemInventory
   * @returns {{ss: boolean, gc: boolean, bp: boolean}}
   */
  static getCharacterMoney(moneyItemInventory) {
    let moneyTypeIndex = {
      gc: false,
      ss: false,
      bp: false
    };
    //First we'll try to look at the localized name
    for (let m = 0; m < moneyItemInventory.length; m++) {
      switch (moneyItemInventory[m].name) {
        case game.i18n.localize("NAME.GC"):
          moneyTypeIndex.gc = m;
          break;
        case game.i18n.localize("NAME.SS"):
          moneyTypeIndex.ss = m;
          break;
        case game.i18n.localize("NAME.BP"):
          moneyTypeIndex.bp = m;
          break;
      }
    }
    return moneyTypeIndex;
  }

  static throwMoney(moneyValues) {
    let number = moneyValues.gc || 0;
    if ((moneyValues.ss || 0) > number)
      number = moneyValues.ss || 0;
    if ((moneyValues.bp || 0) > number)
      number = moneyValues.bp || 0;

    if (game.dice3d && game.settings.get("wfrp4e", "throwMoney")) {
      new Roll(`${number}dc`).evaluate().then((roll) => {
        game.dice3d.showForRoll(roll);
      });
    }
  }

  /**
   * Parse a price string
   * Like "8gc6bp" or "74ss 12gc", etc
   * This method use localized abbreviations
   * return an object with the moneys and quantity
   * @param {String} string
   * @returns {Object}
   */
  static parseMoneyTransactionString(string) {
    //Regular expression to match any number followed by any abbreviation. Ignore whitespaces
    const expression = /((\d+)\s?(\p{L}+))/ug;
    let matches = [...string.matchAll(expression)];

    let payRecap = {
      gc: 0,
      ss: 0,
      bp: 0
    };
    let isValid = matches.length;
    for (let match of matches) {
      //Check if we have a valid command. We should have 4 groups per match
      if (match.length !== 4) {
        isValid = false;
        break;
      }
      //Should contains the abbreviated money (like "gc")
      switch (match[3].toLowerCase()) {
        case game.i18n.localize("MARKET.Abbrev.GC").toLowerCase():
          payRecap.gc += parseInt(match[2], 10);
          break;
        case game.i18n.localize("MARKET.Abbrev.SS").toLowerCase():
          payRecap.ss += parseInt(match[2], 10);
          break;
        case game.i18n.localize("MARKET.Abbrev.BP").toLowerCase():
          payRecap.bp += parseInt(match[2], 10);
          break;
      }
    }
    if (isValid && (payRecap.gc + payRecap.ss + payRecap.bp === 0))
      isValid = false;
    if (isValid && (payRecap.gc + payRecap.ss + payRecap.bp === 0))
      isValid = false;
    return isValid ? payRecap : false;
  }

  /**
   * Generate a card in the chat with a "Pay" button.
   * GM Only
   * @param {String} payRequest
   */
  static generatePayCard(payRequest, player) {
    let parsedPayRequest = this.parseMoneyTransactionString(payRequest);
    //If the /pay command has a syntax error, we display an error message to the gm
    if (!parsedPayRequest) {
      let msg = `<h3><b>${game.i18n.localize("MARKET.PayRequest")}</b></h3>`;
      msg += `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.PayCommandExample")}</i></p>`;
      ChatMessage.create(WFRP_Utility$1.chatDataSetup(msg, "gmroll"));
    } else //generate a card with a summary and a pay button
    {
      let cardData = {
        payRequest: payRequest,
        QtGC: parsedPayRequest.gc,
        QtSS: parsedPayRequest.ss,
        QtBP: parsedPayRequest.bp
      };
      renderTemplate("systems/wfrp4e/templates/chat/market/market-pay.hbs", cardData).then(html => {
        let chatData = WFRP_Utility$1.chatDataSetup(html, "roll", false, {forceWhisper: player});
        ChatMessage.create(chatData);
      });
    }
  }

  /**
* Make some change ... to avoid player going around with tons of bronze coins
* @param {int} amount
* @returns {Object} an amount {amount.gc,amount.ss,amount.bp}
*/
  static makeSomeChange(amount, bpRemainder) {
    let gc = 0, ss = 0, bp = 0;
    if (amount >= 0) {
      gc = Math.floor(amount / 240);
      amount = amount % 240;
      ss = Math.floor(amount / 12);
      bp = amount % 12;
      bp = bp + ((bpRemainder > 0) ? 1 : 0);
    }
    return { gc: gc, ss: ss, bp: bp };
  }

  /**
* Transforms an amount of money to a string with value + currency like 2gc4ss8bp localized.
* @param {Object} amount
* @return {String} the amount
*/
  static amountToString(amount) {
    let gc = game.i18n.localize("MARKET.Abbrev.GC");
    let ss = game.i18n.localize("MARKET.Abbrev.SS");
    let bp = game.i18n.localize("MARKET.Abbrev.BP");
    return `${amount.gc}${gc} ${amount.ss}${ss} ${amount.bp}${bp}`
  }


  /**
*
* @param initialAmount {Object} {initialAmount.gc,initialAmount.ss,initialAmount.bp}
* @param {int} nbOfPlayers to split among them
* return amount {Object} an amount {amount.gc,amount.ss,amount.bp}
*/
  static splitAmountBetweenAllPlayers(initialAmount, nbOfPlayers) {
    // convert initialAmount in bp
    let bpAmount = initialAmount.gc * 240 + initialAmount.ss * 12 + initialAmount.bp;
    // divide bpAmount by nb of players and get the true remainder
    let bpRemainder = bpAmount % nbOfPlayers;
    bpAmount = Math.floor(bpAmount / nbOfPlayers);
    // rebuild an amount of gc/ss/bp from bpAmount
    let amount = this.makeSomeChange(bpAmount, bpRemainder);
    return amount;
  }


  /**TODO: Known Issue: /credit amount actor does not provide a chat message to the owning player
   * Process the credit management options.
   * GM Only
   * @param {String} creditRequest
   * @param {String} optionOrName
   */
  static processCredit(creditRequest, optionOrName) {
    let parsedPayRequest = this.parseMoneyTransactionString(creditRequest);

    //If the /credit command has a syntax error, we display an error message to the gm
    if (!parsedPayRequest) {
      let msg = `<h3><b>${game.i18n.localize("MARKET.CreditRequest")}</b></h3>`;
      msg += `<p>${game.i18n.localize("MARKET.MoneyTransactionWrongCommand")}</p><p><i>${game.i18n.localize("MARKET.CreditCommandExample")}</i></p>`;
      ChatMessage.create(WFRP_Utility$1.chatDataSetup(msg, "gmroll"));
    } else //generate a card with a summary and a receive button
    {
      let amount, message, forceWhisper;
      optionOrName = optionOrName || "split"; // Default behavior

      // Process split/each options
      let nbActivePlayers = Array.from(game.users).filter(u => u.role != 4 && u.active).length;
      if ( optionOrName.toLowerCase() == "each" || optionOrName.toLowerCase() == "split") {
        if (nbActivePlayers == 0 ) {
          let message = game.i18n.localize("MARKET.NoPlayers");
          ChatMessage.create({ content: message });
          return
        }
        if (optionOrName.toLowerCase() === "split") {
          amount = this.splitAmountBetweenAllPlayers(parsedPayRequest, nbActivePlayers);
          message = game.i18n.format("MARKET.RequestMessageForSplitCredit", {
            activePlayerNumber: nbActivePlayers,
            initialAmount: this.amountToString(parsedPayRequest)
          });
        }
        else if (optionOrName.toLowerCase() === "each") {
          amount = parsedPayRequest;
          message = game.i18n.format("MARKET.RequestMessageForEachCredit", {
            activePlayerNumber: nbActivePlayers,
            initialAmount: this.amountToString(parsedPayRequest)
          });
        }
      } else {
        amount = parsedPayRequest;
        let paName = optionOrName.trim().toLowerCase();
        let player = game.users.players.filter(p => p.name.toLowerCase() == paName);
        if (player[0]) { // Player found !
          forceWhisper = player[0].name;
          message = game.i18n.format("MARKET.CreditToUser", {
            userName: player[0].name,
            initialAmount: this.amountToString(parsedPayRequest)
          });
        } else {
          let actor = game.actors.find(a => a.name.toLowerCase().includes(paName.toLowerCase()) );
          if ( actor) {
            let money = this.creditCommand(this.amountToString(amount), actor); // Imediate processing!
            if (money) {
              actor.updateEmbeddedDocuments("Item", money);
            }
            return
          } else {
            message = game.i18n.localize("MARKET.NoMatchingPlayer");
            ChatMessage.create({ content: message });
            return
          }
        }
      }
      let cardData = {
        digestMessage: message,
        amount: this.amountToString(amount),
        QtGC: amount.gc,
        QtSS: amount.ss,
        QtBP: amount.bp
      };
      renderTemplate("systems/wfrp4e/templates/chat/market/market-credit.hbs", cardData).then(html => {
        let chatData = WFRP_Utility$1.chatDataSetup(html, "roll", false, {forceWhisper});
        setProperty(chatData, "flags.wfrp4e.instances", nbActivePlayers);
        ChatMessage.create(chatData);
      });
    }
  }
}

/**
 * Specialized class to consume and generate from a large list of human name options extracted from
 * http://www.windsofchaos.com/wp-content/uploads/encroachment/book-of-imperial-names.pdf
 * See the `names` folder in the system directory to examine the list of names and options.
 */


class NameGenWfrp {
  static _loadNames() {
    WFRP_Utility$1.log("Loading Names...", true);

    // Surname option 1
    fetch("systems/wfrp4e/names/human_surnames.txt").then(r => r.text()).then(async nameText => {
      this.surnames = [];
      nameText.split("\n").forEach((nameGroup) => this.surnames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // Surname option 2 - prefix
    fetch("systems/wfrp4e/names/human_surnames_prefix.txt").then(r => r.text()).then(async nameText => {
      this.surnamePrefixes = [];
      nameText.split("\n").forEach((nameGroup) => this.surnamePrefixes.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Surname option 2 - suffix
    fetch("systems/wfrp4e/names/human_surnames_suffix.txt").then(r => r.text()).then(async nameText => {
      this.surnameSuffixes = [];
      nameText.split("\n").forEach((nameGroup) => this.surnameSuffixes.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Male forenames
    fetch("systems/wfrp4e/names/male_human_forenames.txt").then(r => r.text()).then(async nameText => {
      this.human_male_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.human_male_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Female forenames
    fetch("systems/wfrp4e/names/female_human_forenames.txt").then(r => r.text()).then(async nameText => {
      this.human_female_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.human_female_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // @@@@@@@@@@ DWARF @@@@@@@@@@@@@
    // male forenames
    fetch("systems/wfrp4e/names/male_dwarf_forenames.txt").then(r => r.text()).then(async nameText => {
      this.dwarf_male_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.dwarf_male_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Female forenames
    fetch("systems/wfrp4e/names/female_dwarf_forenames.txt").then(r => r.text()).then(async nameText => {
      this.dwarf_female_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.dwarf_female_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // @@@@@@@@@@ ELF @@@@@@@@@@@@@
    // elf forenames
    fetch("systems/wfrp4e/names/elf_forenames.txt").then(r => r.text()).then(async nameText => {
      this.elf_Forenames = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_Forenames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    fetch("systems/wfrp4e/names/elf_surnames.txt").then(r => r.text()).then(async nameText => {
      this.elf_surnames = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_surnames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // elf start
    fetch("systems/wfrp4e/names/elf_start.txt").then(r => r.text()).then(async nameText => {
      this.elf_start = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_start.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // elf connector
    fetch("systems/wfrp4e/names/elf_connectors.txt").then(r => r.text()).then(async nameText => {
      this.elf_connectors = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_connectors.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // female elf element
    fetch("systems/wfrp4e/names/male_elf_element.txt").then(r => r.text()).then(async nameText => {
      this.elf_male_element = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_male_element.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // male elf element
    fetch("systems/wfrp4e/names/female_elf_element.txt").then(r => r.text()).then(async nameText => {
      this.elf_female_element = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_female_element.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // wood elf end
    fetch("systems/wfrp4e/names/elf_wood_end.txt").then(r => r.text()).then(async nameText => {
      this.elf_wood_end = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_wood_end.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // high elf end
    fetch("systems/wfrp4e/names/elf_high_end.txt").then(r => r.text()).then(async nameText => {
      this.elf_high_end = [];
      nameText.split("\n").forEach((nameGroup) => this.elf_high_end.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // @@@@@@@@@@ Halfling @@@@@@@@@@@@@
    // Halfling start
    fetch("systems/wfrp4e/names/halfling_start.txt").then(r => r.text()).then(async nameText => {
      this.halfling_start = [];
      nameText.split("\n").forEach((nameGroup) => this.halfling_start.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });

    // Male ending
    fetch("systems/wfrp4e/names/male_halfling_element.txt").then(r => r.text()).then(async nameText => {
      this.male_halfling_element = [];
      nameText.split("\n").forEach((nameGroup) => this.male_halfling_element.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // Female ending
    fetch("systems/wfrp4e/names/female_halfling_element.txt").then(r => r.text()).then(async nameText => {
      this.female_halfling_element = [];
      nameText.split("\n").forEach((nameGroup) => this.female_halfling_element.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // Halfling surnames
    fetch("systems/wfrp4e/names/halfling_surnames.txt").then(r => r.text()).then(async nameText => {
      this.halfling_surnames = [];
      nameText.split("\n").forEach((nameGroup) => this.halfling_surnames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
    // Halfling nicknames
    fetch("systems/wfrp4e/names/halfling_nicknames.txt").then(r => r.text()).then(async nameText => {
      this.halfling_nicknames = [];
      nameText.split("\n").forEach((nameGroup) => this.halfling_nicknames.push(nameGroup.split(",").map(function (item) {
        return item.trim()
      })));
    });
  }

  static human = {
    forename(gender = "male") {
      let names = game.wfrp4e.names[`human_${gender}_Forenames`];
      let size = names.length;
      let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
      let nameGroup = names[roll];

      let base = nameGroup[0];
      let option;
      roll = Math.floor(CONFIG.Dice.randomUniform()*nameGroup.length);
      if (roll != 0)
        option = nameGroup[roll].substr(1);

      return game.wfrp4e.names.evaluateNamePartial(base) + (game.wfrp4e.names.evaluateNamePartial(option || ""));
    },
    surname() {
      if (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1) // Don't use prefix - suffix
      {
        let size = game.wfrp4e.names.surnames.length;
        let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
        let nameGroup = game.wfrp4e.names.surnames[roll];

        let base = nameGroup[0];
        let option;
        roll = Math.floor(CONFIG.Dice.randomUniform()*nameGroup.length);
        if (roll != 0)
          option = nameGroup[roll].substr(1);

        return game.wfrp4e.names.evaluateNamePartial(base) + (game.wfrp4e.names.evaluateNamePartial(option || ""));
      }
      else // Use prefix and suffix surname
      {
        let prefixSize = game.wfrp4e.names.surnamePrefixes.length;
        let suffixSize = game.wfrp4e.names.surnameSuffixes.length;

        let prefixChoice = game.wfrp4e.names.surnamePrefixes[Math.floor(CONFIG.Dice.randomUniform()*prefixSize)][0];
        let suffixChoice = game.wfrp4e.names.surnameSuffixes[Math.floor(CONFIG.Dice.randomUniform()*suffixSize)][0];

        return game.wfrp4e.names.evaluateNamePartial(prefixChoice) + game.wfrp4e.names.evaluateNamePartial(suffixChoice)
      }
    }
  }
  static dwarf = {
    forename(gender = "male") {
      let names = game.wfrp4e.names[`dwarf_${gender}_Forenames`];
      let size = names.length;
      let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
      let nameGroup = names[roll];

      let base = nameGroup[0];
      let option;
      roll = Math.floor(CONFIG.Dice.randomUniform()*(nameGroup.length));
      if (roll != 0)
        option = nameGroup[roll].substr(1);

      return game.wfrp4e.names.evaluateNamePartial(base) + (game.wfrp4e.names.evaluateNamePartial(option || ""));
    },
    surname(gender = "male") {
      let base = this.forename(gender);
      let suffix = "";
      if (gender == "male") {
        suffix = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? "snev" : "sson");
      }
      else {
        suffix = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? "sniz" : "sdottir");
      }
      return base + suffix;
    }
  }
  static helf = {
    forename(gender="male", type = "helf") {
      let source = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? "forename" : "generate");
      if (source == "forename") {
        let names = game.wfrp4e.names[`elf_Forenames`];
        let size = names.length;
        let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
        return names[roll][0];
      }
      else {
        /**
         * 110
         * 010
         * 101
         * 001
         */
        let useConnector = false, useElement = false, useEnd = false;

        switch (Math.floor(CONFIG.Dice.randomUniform() * 4 + 1) == 1) {
          case 1:
            useConnector = true;
            useElement = true;
            break;
          case 2:
            useElement = true;
            break;
          case 3:
            useConnector = true;
            useEnd = true;
            break;
          case 4:
            useEnd = true;
        }


        let start = game.wfrp4e.names.RollArray("elf_start");

        let connector = useConnector ? game.wfrp4e.names.RollArray("elf_connectors") : "";
        let element = useElement ? game.wfrp4e.names.RollArray(`elf_${gender}_element`) : "";

        let elfType = type.includes("h") ? "high" : "wood";
        let end = useEnd ? game.wfrp4e.names.RollArray(`elf_${elfType}_end`) : "";
        return start + connector + element + end;
      }
    },
    surname(){
      return game.wfrp4e.names.RollArray("elf_surnames")
    }
  }

  static welf = {
    forename(gender="male", type="welf"){
      return game.wfrp4e.names.helf.forename(gender, type)
    },
    surname(){
      return game.wfrp4e.names.RollArray("elf_surnames")
    }
  }

  static halfling = {
    forename(gender="male"){
      let nickname = Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? `(${game.wfrp4e.names.RollArray("halfling_nicknames")})` : "";
      return `${game.wfrp4e.names.RollArray("halfling_start")}${game.wfrp4e.names.RollArray(`${gender}_halfling_element`)} ${nickname}`
    },
    surname(){
      return game.wfrp4e.names.RollArray("halfling_surnames")
    }
  }

  /**
   * Generate a Forename + Surname
   * 
   * @param {Object} options species, gender
   */
  static generateName(options = { species: "human" }) {
    if (!options.species) {
      options.species = "human";
    }
    if (options.species)
      options.species = options.species.toLowerCase();
    if (options.gender)
      options.gender = options.gender.toLowerCase();

    // If gender not recognize, remove it (roll male or female names randomly)
    if (!["male", "female"].includes(options.gender))
      delete options.gender;

    if (!options.gender) // Generate male/female randomly
      options.gender = (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1 ? "male" : "female");

    return this[options.species].forename(options.gender) + " " + this[options.species].surname(options.gender)
  }

  /**
   * Parses down a name the partials given.
   * 
   * Name partial example: "Bar(f)sheim(er)" - randomly decide what to include within parentheses.
   * 
   * @param {String} namePartial A name partial is the inner choices
   */
  static evaluateNamePartial(namePartial) {
    var options = Array.from(namePartial.matchAll(/\((.+?)\)/g));
    for (let option of options) {
      if (Math.ceil(CONFIG.Dice.randomUniform() * 2) == 1) {
        namePartial = namePartial.replace(option[0], this.evaluateChoices(option[1]));
      }
      else {
        namePartial = namePartial.replace(option[0], "");
      }
    }
    return this.evaluateChoices(namePartial)
  }

  /**
   * A name is typically followed by choices of suffixes to use, separated by a comma.
   * 
   * Example of choices - "Aver, -land(er), -lund(er)" - Aver is not a choice, the other two are choices, however at least one of them is required.
   * 
   * @param {String} choiceString String of name chocies
   */
  static evaluateChoices(choiceString) {
    if (!choiceString)
      return choiceString
    let choices = Array.from(choiceString.matchAll(/(\w+)[\/]*/g));
    let choice = Math.floor(CONFIG.Dice.randomUniform()*choices.length);
    return choices[choice][1]
  }

  static RollArray(arrayName) {
    let elements = this[arrayName];
    let size = elements.length;
    let roll = Math.floor(CONFIG.Dice.randomUniform()*size);
    return elements[roll][0]
  }
}

var WFRP4eSheetMixin$1 = WFRP4eSheetMixin = (cls) => class extends cls 
{
    // Shared listeners between different document sheets 

    _getId(ev) 
    {
        return this._getDataAttribute(ev, "id");
    }
    
    _getIndex(ev) 
    {
        return Number(this._getDataAttribute(ev, "index"));
    }

    _getKey(ev) 
    {
        return this._getDataAttribute(ev, "key");
    }

    _getType(ev) 
    {
        return this._getDataAttribute(ev, "type");
    }

    _getPath(ev) 
    {
        return this._getDataAttribute(ev, "path");
    }

    _getCollection(ev) 
    {
        return this._getDataAttribute(ev, "collection") || "items";
    }

    _getUUID(ev)
    {
        return this._getDataAttribute(ev, "uuid");
    }


    /**
     * Search for an HTML data property, specified as data-<property>
     * First search target of the event, then search in parent properties
     * 
     * @param {Event} ev Event triggered
     * @param {String} property data-<property> being searched for
     * @returns 
     */
    _getDataAttribute(ev, property)
    {
        let value = ev.target.dataset[property];

        if (!value) 
        {
            const parent = $(ev.target).parents(`[data-${property}]`);
            if (parent) 
            {
                value = parent[0]?.dataset[property];
            }
        }
        return value;
    }

    _getDocument(event)
    {
        let id = this._getId(event);
        let collection = this._getCollection(event);
        let uuid = this._getUUID(event);

        return (uuid ? fromUuidSync(uuid) : this.object[collection].get(id));
    }

    async _onEffectCreate(ev) 
    {
        let type = ev.currentTarget.dataset.category;
        let effectData = { name: game.i18n.localize("New Effect"), icon: "icons/svg/aura.svg" };
        if (type == "temporary") 
        {
            effectData["duration.rounds"] = 1;
        }
        else if (type == "disabled") 
        {
            effectData.disabled = true;
        }

        // If Item effect, use item name for effect name
        if (this.object.documentName == "Item")
        {
            effectData.name = this.object.name;
            effectData.img = this.object.img;
        }
        this.object.createEmbeddedDocuments("ActiveEffect", [effectData]).then(effects => effects[0].sheet.render(true));
    }
};

/**
 * Provides the data and general interaction with Actor Sheets - Abstract class.
 *
 * ActorSheetWfrp4e provides the general interaction and data organization shared among all 
 * actor sheets, as this is an abstract class, inherited by either Character, NPC, or Creature
 * specific actor sheet classes. When rendering an actor sheet, getData() is called, which is
 * a large and key that prepares the actor data for display, processing the raw data
 * and items and compiling them into data to display on the sheet. Additionally, this class
 * contains all the main events that respond to sheet interaction in activateListeners().
 *
 * @see   ActorWfrp4e - Data and main computation model (this.actor)
 * @see   ActorSheetWfrp4eCharacter - Character sheet class
 * @see   ActorSheetWfrp4eNPC - NPC sheet class
 * @see   ActorSheetWfrp4eCreature - Creature sheet class
 */
class ActorSheetWfrp4e extends WFRP4eSheetMixin$1(ActorSheet) {

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.tabs = [{ navSelector: ".tabs", contentSelector: ".content", initial: "main" }];
    options.width = 576;
    options.scrollY = [".save-scroll"];
    return options;
  }

  /**
   * Overrides the default ActorSheet.render to add lity.
   * 
   * This adds scroll position saving support, as well as tooltips for the
   * custom buttons.
   * 
   * @param {bool} force      used upstream.
   * @param {Object} options  used upstream.
   */
  async _render(force = false, options = {}) {
    await super._render(force, options);

    // Add Tooltips
    this.element.find(".close").attr({"data-tooltip" : game.i18n.localize("SHEET.Close"), "data-tooltip-direction" : "UP"});
    this.element.find(".configure-sheet").attr({"data-tooltip" : game.i18n.localize("SHEET.Configure"), "data-tooltip-direction" : "UP"});
    this.element.find(".configure-token").attr({"data-tooltip" : game.i18n.localize("SHEET.Token"), "data-tooltip-direction" : "UP"});
    this.element.find(".import").attr({"data-tooltip" : game.i18n.localize("SHEET.Import"), "data-tooltip-direction" : "UP"});

    WFRP_Utility$1.replacePopoutTokens(this.element); // Opposed attackers show as tokens, replace popout versions with normal
    WFRP_Utility$1.addLinkSources(this.element);

    this._refocus(this._element);

  }

  // /**
  //  * Saves all the scroll positions in the sheet for setScrollPos() to use
  //  * 
  //  * All elements in the sheet that use ".save-scroll" class has their position saved to
  //  * this.scrollPos array, which is used when rendering (rendering a sheet resets all 
  //  * scroll positions by default).
  //  */
  // _saveScrollPos() {
  //   if (this.form === null)
  //     return;

  //   const html = $(this.form).parent();
  //   this.scrollPos = [];
  //   let lists = $(html.find(".save-scroll"));
  //   for (let list of lists) {
  //     this.scrollPos.push($(list).scrollTop());
  //   }
  // }

  // /**
  //  * Sets all scroll positions to what was saved by saveScrollPos()
  //  * 
  //  * All elements in the sheet that use ".save-scroll" class has their position set to what was
  //  * saved by saveScrollPos before rendering. 
  //  */
  // _setScrollPos() {
  //   if (this.scrollPos) {
  //     const html = $(this.form).parent();
  //     let lists = $(html.find(".save-scroll"));
  //     for (let i = 0; i < lists.length; i++) {
  //       $(lists[i]).scrollTop(this.scrollPos[i]);
  //     }
  //   }
  // }

  _refocus(html) {
    try {
      let element;
      if (this.saveFocus)
        element = html.find(`input[${this.saveFocus}]`)[0];

      if (element) {
        element.focus();
        element.select();
      }
    }
    catch (e) {
      WFRP_Utility$1.log("Could not refocus tabbed element on character sheet");
    }
  }

  /**
   * Provides the data to the template when rendering the actor sheet
   * 
   * This is called when rendering the sheet, where it calls the base actor class
   * to organize, process, and prepare all actor data for display. See ActorWfrp4e.prepare()
   * 
   * @returns {Object} sheetData    Data given to the template when rendering
   */
  async getData() {
    const sheetData = await super.getData();
    sheetData.system = sheetData.actor.system; // project system data so that handlebars has the same name and value paths

    sheetData.items = this.constructItemLists(sheetData);
    this.formatArmourSection(sheetData);

    this._addEncumbranceData(sheetData);

    this.filterActiveEffects(sheetData);
    this.addConditionData(sheetData);

    sheetData.attacker = this.actor.attacker;

    if (this.actor.type != "vehicle") {
      sheetData.effects.system = game.wfrp4e.utility.getSystemEffects();
    }

    sheetData.enrichment = await this._handleEnrichment();

    return sheetData;
  }

  async _handleEnrichment()
  {
      let enrichment = {};
      enrichment["system.details.biography.value"] = await TextEditor.enrichHTML(this.actor.system.details.biography.value, {async: true, secrets: this.actor.isOwner, relativeTo: this.actor});
      enrichment["system.details.gmnotes.value"] = await TextEditor.enrichHTML(this.actor.system.details.gmnotes.value, {async: true, secrets: this.actor.isOwner, relativeTo: this.actor});

      return expandObject(enrichment)
  }


  constructItemLists(sheetData) {

    let items = {};

    items.skills = {
      basic: sheetData.actor.getItemTypes("skill").filter(i => i.advanced.value == "bsc" && i.grouped.value == "noSpec"),
      advanced: sheetData.actor.getItemTypes("skill").filter(i => i.advanced.value == "adv" || i.grouped.value == "isSpec")
    };

    items.careers = sheetData.actor.getItemTypes("career").reverse();
    items.criticals = sheetData.actor.getItemTypes("critical");
    items.nonTrivialCriticals = items.criticals.filter(c => Number.isNumeric(c.system.wounds.value));
    items.diseases = sheetData.actor.getItemTypes("disease");
    items.injuries = sheetData.actor.getItemTypes("injury");
    items.mutations = sheetData.actor.getItemTypes("mutation");
    items.psychologies = sheetData.actor.getItemTypes("psychology");
    items.traits = sheetData.actor.getItemTypes("trait");
    items.extendedTests = sheetData.actor.getItemTypes("extendedTest");
    items.vehicleMods = sheetData.actor.getItemTypes("vehicleMod");

    items.grimoire = {
      petty: sheetData.actor.getItemTypes("spell").filter(i => i.lore.value == "petty" || i.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty")),
      lore: sheetData.actor.getItemTypes("spell").filter(i => (i.lore.value != "petty" && i.lore.value != game.i18n.localize("WFRP4E.MagicLores.petty")) || !i.lore.value)
    };

    items.prayers = {
      blessings: sheetData.actor.getItemTypes("prayer").filter(i => i.prayerType.value == "blessing"),
      miracles: sheetData.actor.getItemTypes("prayer").filter(i => i.prayerType.value == "miracle" || !i.prayerType.value)
    };

    items.equipped = {
      weapons: sheetData.actor.getItemTypes("weapon").filter(i => i.isEquipped),
      armour: sheetData.actor.getItemTypes("armour").filter(i => i.isEquipped)
    };

    items.inventory = this.constructInventory(sheetData);

    items.talents = this._consolidateTalents();

    this._sortItemLists(items);

    items.skills.basic = items.skills.basic.sort(WFRP_Utility$1.nameSorter);
    items.skills.advanced = items.skills.advanced.sort(WFRP_Utility$1.nameSorter);

    return items
  }

  constructInventory(sheetData) {

    let collapsed = this.actor.getFlag("wfrp4e", "sheetCollapsed");
    // Inventory object is for the Trappings tab - each sub object is for an individual inventory section
    const categories = {
      weapons: {
        label: game.i18n.localize("WFRP4E.TrappingType.Weapon"), // Label - what is displayed in the inventory section header
        items: sheetData.actor.getItemTypes("weapon"), // Array of items in the sectio.filter(i => !i.location.value)n
        toggle: true,                                 // Is there a toggle in the section? (Equipped, worn, etc.)
        toggleName: game.i18n.localize("Equipped"),   // What is the name of the toggle in the header
        show: false,                                  // Should this section be shown (if an item exists in this list, it is set to true)
        collapsed : collapsed?.weapons,
        dataType: "weapon"                            // What type of FVTT Item is in this section (used by the + button to add an item of this type)
      },
      armor: {
        label: game.i18n.localize("WFRP4E.TrappingType.Armour"),
        items: sheetData.actor.getItemTypes("armour"),
        toggle: true,
        toggleName: game.i18n.localize("Worn"),
        show: false,
        collapsed : collapsed?.armor,
        dataType: "armour"
      },
      ammunition: {
        label: game.i18n.localize("WFRP4E.TrappingType.Ammunition"),
        items: sheetData.actor.getItemTypes("ammunition"),
        show: false,
        collapsed : collapsed?.ammunition,
        dataType: "ammunition"
      },
      clothingAccessories: {
        label: game.i18n.localize("WFRP4E.TrappingType.ClothingAccessories"),
        items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "clothingAccessories"),
        toggle: true,
        toggleName: game.i18n.localize("Worn"),
        show: false,
        collapsed : collapsed?.clothingAccessories,
        dataType: "trapping"
      },
      booksAndDocuments: {
        label: game.i18n.localize("WFRP4E.TrappingType.BooksDocuments"),
        items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "booksAndDocuments"),
        show: false,
        collapsed : collapsed?.booksAndDocuments,
        dataType: "trapping"
      },
      toolsAndKits: {
        label: game.i18n.localize("WFRP4E.TrappingType.ToolsKits"),
        items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "toolsAndKits" || i.trappingType.value == "tradeTools"),
        show: false,
        collapsed : collapsed?.toolsAndKits,
        dataType: "trapping"
      },
      foodAndDrink: {
        label: game.i18n.localize("WFRP4E.TrappingType.FoodDrink"),
        items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "foodAndDrink"),
        show: false,
        collapsed : collapsed?.foodAndDrink,
        dataType: "trapping"
      },
      drugsPoisonsHerbsDraughts: {
        label: game.i18n.localize("WFRP4E.TrappingType.DrugsPoisonsHerbsDraughts"),
        items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "drugsPoisonsHerbsDraughts"),
        show: false,
        collapsed : collapsed?.drugsPoisonsHerbsDraughts,
        dataType: "trapping"
      },
      misc: {
        label: game.i18n.localize("WFRP4E.TrappingType.Misc"),
        items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "misc" || !i.trappingType.value),
        show: true,
        collapsed : collapsed?.misc,
        dataType: "trapping"
      },
      cargo: {
        label: game.i18n.localize("WFRP4E.TrappingType.Cargo"),
        items: sheetData.actor.getItemTypes("cargo"),
        show: false,
        collapsed : collapsed?.cargo,
        dataType: "cargo"
      }
    };

    // Money and ingredients are not in inventory object because they need more customization - note in actor-inventory.html that they do not exist in the main inventory loop
    const ingredients = {
      label: game.i18n.localize("WFRP4E.TrappingType.Ingredient"),
      items: sheetData.actor.getItemTypes("trapping").filter(i => i.trappingType.value == "ingredient"),
      show: false,
      collapsed : collapsed?.ingredients,
      dataType: "trapping"
    };
    const money = {
      items: sheetData.actor.getItemTypes("money"),
      total: 0,     // Total coinage value
      show: true,
      collapsed : false
    };
    const containers = {
      items: sheetData.actor.getItemTypes("container"),
      show: false
    };
    const misc = {};
    let inContainers = []; // inContainers is the temporary storage for items within a container


    if (sheetData.actor.hasSpells || sheetData.actor.type == "vehicle")
      inContainers = this._filterItemCategory(ingredients, inContainers);
    else
      categories.misc.items = categories.misc.items.concat(ingredients.items);

    for (let itemCategory in categories)
      inContainers = this._filterItemCategory(categories[itemCategory], inContainers);

    inContainers = this._filterItemCategory(money, inContainers);
    inContainers = this._filterItemCategory(containers, inContainers);

    misc.totalShieldDamage = categories["weapons"].items.reduce((prev, current) => prev += current.damageToItem.shield, 0);

    money.total = money.items.reduce((prev, current) => { return prev + (current.coinValue.value * current.quantity.value) }, 0);

    categories.misc.show = true;

    // ******************************** Container Setup ***********************************

    for (var cont of this.actor.getItemTypes("container")) // For each container
    {
      // All items referencing (inside) that container
      var itemsInside = inContainers.filter(i => i.location.value == cont.id);
      cont.carrying = itemsInside.filter(i => i.type != "container");    // cont.carrying -> items the container is carrying
      cont.packsInside = itemsInside.filter(i => i.type == "container"); // cont.packsInside -> containers the container is carrying
      cont.carries.current = itemsInside.reduce(function (prev, cur) {   // cont.holding -> total encumbrance the container is holding
        return Number(prev) + Number(cur.encumbrance.value);
      }, 0);
      cont.carries.current = Math.floor(cont.carries.current * 10) / 10;
      cont.collapsed=this.actor.getFlag("wfrp4e", "sheetCollapsed")?.[cont.id];
    }

    return {
      categories,
      ingredients,
      money,
      containers,
      misc
    }
  }

  _filterItemCategory(category, itemsInContainers) {
    itemsInContainers = itemsInContainers.concat(category.items.filter(i => !!i.location?.value));
    category.items = category.items.filter(i => !i.location?.value);
    category.show = category.items.length > 0;
    return itemsInContainers
  }

  addConditionData(sheetData) {
    try {
      let conditions = duplicate(game.wfrp4e.config.statusEffects).map(e => new EffectWfrp4e(e));
      let currentConditions = this.actor.conditions;
      delete conditions.splice(conditions.length - 1, 1);
      
      for (let condition of conditions) {
        let owned = currentConditions.find(e => e.conditionId == condition.conditionId);
        if (owned) {
          condition.existing = true;
          condition.flags.wfrp4e.value = owned.conditionValue;
        }
        else if (condition.isNumberedCondition) {
          condition.flags.wfrp4e.value = 0;
        }
      }
      sheetData.effects.conditions = conditions;
    }
    catch (e)
    {
      ui.notifications.error("Error Adding Condition Data: " + e);
    }
  }

  filterActiveEffects(sheetData) {
    sheetData.effects = {};
    sheetData.effects.conditions = [];
    sheetData.effects.temporary = [];
    sheetData.effects.passive = [];
    sheetData.effects.disabled = [];
    sheetData.effects.targeted = [];

    for (let e of Array.from(this.actor.allApplicableEffects(true)))
    {
      if (!e.show)
        continue
      if (e.isCondition) sheetData.effects.conditions.push(e);
      else if (e.disabled) sheetData.effects.disabled.push(e);
      else if (e.isTemporary) sheetData.effects.temporary.push(e);
      else sheetData.effects.passive.push(e);
    }

    sheetData.effects.passive = this._consolidateEffects(sheetData.effects.passive);
    sheetData.effects.temporary = this._consolidateEffects(sheetData.effects.temporary);
    sheetData.effects.disabled = this._consolidateEffects(sheetData.effects.disabled);
  }

  // Recursively go through the object and sort any arrays found
  _sortItemLists(items) {
    for (let prop in items) {
      if (Array.isArray(items[prop]))
        items[prop] = items[prop].sort((a, b) => (a.sort || 0) - (b.sort || 0));
      else if (typeof items == "object")
        this._sortItemLists(items[prop]);
    }
  }
  _consolidateEffects(effects) {
    let consolidated = [];
    for (let effect of effects) {
      let existing = consolidated.find(e => e.name == effect.name);
      if (!existing)
        consolidated.push(effect);
    }
    for (let effect of consolidated) {
      let count = effects.filter(e => e.name == effect.name).length;
      effect.count = count;
    }
    return consolidated
  }

  _consolidateTalents() {
    let talents = this.actor.getItemTypes("talent");
    let consolidated = [];
    for (let talent of talents) {
      let existing = consolidated.find(t => t.name == talent.name);
      if (!existing)
        consolidated.push(talent);
    }
    return consolidated
  }


  formatArmourSection(sheetData) {
    let AP = sheetData.system.status.armour;

    // Change out hit locations if using custom table
    let table = game.wfrp4e.tables.findTable(sheetData.system.details.hitLocationTable.value);
    for (let loc in AP) {
      if (loc == "shield" || loc == "shieldDamage")
        continue
      if (table)
      {
        try {
          let result  = table.results.find(r => r.getFlag("wfrp4e", "loc") == loc);
          if (result)
          AP[loc].label = game.i18n.localize(result.text);
          else
          AP[loc].show = false;
        }
        catch(e)
        {
          ui.notifications.error("Error formatting armour section using Hit Location Table, using fallback implementation");
          WFRP_Utility$1.log("Hit Location Format Error: " + e, true);
          AP[loc].label = game.i18n.localize(game.wfrp4e.config.locations[loc]);
        }
      }
      else if (game.wfrp4e.config.locations[loc]) // fallback implementation
      {
        AP[loc].label = game.i18n.localize(game.wfrp4e.config.locations[loc]);
      }
    }
  }

  _addEncumbranceData(sheetData) {
    if (this.type != "vehicle")
      sheetData.system.status.encumbrance.pct = Math.min((sheetData.system.status.encumbrance.current / sheetData.system.status.encumbrance.max * 100), 100);
  }

  addMountData(data) {
    try {
      if (!this.actor.mount)
        return

      data.mount = this.actor.mount.data;
      if (data.mount.system.status.wounds.value == 0)
        this.actor.status.mount.mounted = false;
      if (data.actor.status.mount.isToken)
        data.mount.sceneName = game.scenes.get(data.actor.system.status.mount.tokenData.scene).name;
    }
    catch (e) {
      console.error(this.actor.name + ": Failed to get mount data: " + e.message);
    }
  }

  /**
   * Takes the user-entered hp value and interprets it as relative or absolute
   * and modifies the hp accordingly. 
   * 
   * Takes an either relative (+12 or -5) or an absolute value (12 or 5), interprets
   * it, and processes it with the actor's hp value.
   * 
   * @param {String} value   user entered value 
   */
  modifyWounds(value) {
    let sign = value.split('')[0]; // Sign is the first character entered
    if (sign === "+" || sign === "-") // Relative
      return this.actor.modifyWounds(parseInt(value))
    else                            // Absolute
      return this.actor.setWounds(parseInt(value));
  }

  /**
 * Display a dialog for the user to choose casting or channelling.
 *
 * When clicking on a spell, the user will get an option to Cast or Channel that spell
 * Each option leads to their respective "setup" .
 *
 * @param {Object} spell     The spell item clicked on, petty spells will automatically be Casted, without the option to channel.
 *
 */
  spellDialog(spell, options = {}) {
    // Do not show the dialog for Petty spells, just cast it.
    if (spell.lore.value == "petty" || spell.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty"))
      this.actor.setupCast(spell, options).then(setupData => {
        this.actor.castTest(setupData);
      });
    else {
        new Dialog({
          title: game.i18n.localize("DIALOG.CastOrChannel"),
          content: `<div class="cast-channel-dialog selection"> 
                    <p>${game.i18n.localize("DIALOG.CastChannel")}</p> 
                    </div>`,
          buttons: {
            cast: {
              label: game.i18n.localize("Cast"),
              callback: btn => {
                this.actor.setupCast(spell, options).then(setupData => {
                  this.actor.castTest(setupData);
                });
              }
            },
            channel: {
              label: game.i18n.localize("Channel"),
              callback: async btn => {
                let test = await this.actor.setupChannell(spell, options);
                await test.roll();
                if (test.context.channelUntilSuccess) {
                  await WFRP_Utility$1.sleep(200);
                  do {
                    if (test.item.cn.SL >= test.item.cn.value) {
                      break;
                    }
                    if (test.result.minormis || test.result.majormis || test.result.catastrophicmis) {
                      break;
                    }
                    test.context.messageId = null; // Clear message so new message is made
                    await test.roll();
                    await WFRP_Utility$1.sleep(200);
                  } while (true);
                }
              }
            }
          },
          default: 'cast'
        }).render(true);
    }
  }


  _getSubmitData(updateData = {}) {
    this.actor.overrides = {};
    let data = super._getSubmitData(updateData);
    data = diffObject(flattenObject(this.actor.toObject(false)), data);
    return data
  }



  /* --------------------------------------------------------------------------------------------------------- */
  /* ------------------------------------ ev Listeners and Handlers --------------------------------------- */
  /* --------------------------------------------------------------------------------------------------------- */
  /**
   * This gargatuan list is all the interactions shared between all types of sheets. Every button click and text
   * fields that require special interaction are handled here. See each ev handler for more details. 
   *
  /* --------------------------------------------------------------------------------------------------------- */

  /**
   * Activate ev listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    // Item summaries - displays a customized dropdown description
    html.find('.item-dropdown').click(this._onItemSummary.bind(this));

    // Item Properties - depending on the item property selected, display a dropdown definition, this can probably be consolidated...TODO
    html.find('.melee-property-quality, .melee-property-flaw, .ranged-property-quality, .ranged-property-flaw, .armour-quality, .armour-flaw').click(this._expandProperty.bind(this));

    // Other dropdowns - for other clickables (range, weapon group, reach) - display dropdown helpers
    html.find('.weapon-range, .weapon-group, .weapon-reach').click(this._expandInfo.bind(this));

    // Autoselect entire text 
    $("input[type=text]").focusin((ev) => {
      $(this).select();
      //this.focusElement = ev.target
    });

    // Everything below here is only needed if the sheet is editable
    if (!this.options.editable) return;

    html.find("#configure-actor").click(ev => {
      new game.wfrp4e.apps.ActorSettings(this.actor).render(true);
    });


    // Use customized input interpreter when manually changing wounds 
    html.find(".wounds-value").change(ev => {
      this.modifyWounds(ev.target.value);
    });

    html.find('.item-edit').click(this._onItemEdit.bind(this));
    html.find('.ch-value').click(this._onCharClick.bind(this));
    html.find('.rest-icon').click(this._onRestClick.bind(this));
    html.find(".ch-edit").change(this._onEditChar.bind(this));
    html.find(".name-gen").click(this._onNameClicked.bind(this));
    html.find('.ap-value').mousedown(this._onAPClick.bind(this));
    html.find('.stomp-icon').click(this._onStompClick.bind(this));
    html.find('.dodge-icon').click(this._onDodgeClick.bind(this));
    html.find('.repeater').click(this._onRepeaterClick.bind(this));
    html.find('.item-toggle').click(this._onItemToggle.bind(this));
    html.find('.item-remove').click(this._onItemRemove.bind(this));
    html.find('.item-delete').click(this._onItemDelete.bind(this));
    html.find('.fist-icon').click(this._onUnarmedClick.bind(this));
    html.find('.item-create').click(this._onItemCreate.bind(this));
    html.find(".aggregate").click(this._onAggregateClick.bind(this));
    html.find('.worn-container').click(this._onWornClick.bind(this));
    html.find('.effect-toggle').click(this._onEffectToggle.bind(this));
    html.find('.effect-title').click(this._onEffectEdit.bind(this));
    html.find('.spell-roll').mousedown(this._onSpellRoll.bind(this));
    html.find('.trait-roll').mousedown(this._onTraitRoll.bind(this));
    html.find(".skill-switch").click(this._onSkillSwitch.bind(this));
    html.find(".item-post").click(this._onItemPostClicked.bind(this));
    html.find('.ammo-selector').change(this._onSelectAmmo.bind(this));
    html.find('.randomize').click(this._onRandomizeClicked.bind(this));
    html.find('.input.species').change(this._onSpeciesEdit.bind(this));
    html.find('.effect-delete').click(this._onEffectDelete.bind(this));
    html.find('.prayer-roll').mousedown(this._onPrayerRoll.bind(this));
    html.find('.effect-create').click(this._onEffectCreate.bind(this));
    html.find('.item-checkbox').click(this._onCheckboxClick.bind(this));
    html.find('.sl-counter').mousedown(this._onSpellSLClick.bind(this));
    html.find('.spell-selector').change(this._onSelectSpell.bind(this));
    html.find('.dollar-icon').click(this._onMoneyIconClicked.bind(this));
    html.find('.disease-roll').mousedown(this._onDiseaseRoll.bind(this));
    html.find(".shield-total").mousedown(this._onShieldClick.bind(this));
    html.find(".test-select").click(this._onExtendedTestSelect.bind(this));
    html.find('.loaded-checkbox').mousedown(this._onLoadedClick.bind(this));
    html.find('.advance-diseases').click(this._onAdvanceDisease.bind(this));
    html.find('.memorized-toggle').click(this._onMemorizedClick.bind(this));
    html.find('.improvised-icon').click(this._onImprovisedClick.bind(this));
    html.find(".extended-SL").mousedown(this._onExtendedSLClick.bind(this));
    html.find(".condition-click").click(this._onConditionClicked.bind(this));
    html.find('.quantity-click').mousedown(this._onQuantityClick.bind(this));
    html.find('.weapon-item-name').click(this._onWeaponNameClick.bind(this));
    html.find(".armour-total").mousedown(this._onArmourTotalClick.bind(this));
    html.find('.auto-calc-toggle').mousedown(this._onAutoCalcToggle.bind(this));
    html.find('.weapon-damage').mousedown(this._onWeaponDamageClick.bind(this));
    html.find('.skill-advances').change(this._onChangeSkillAdvances.bind(this));
    html.find(".condition-toggle").mousedown(this._onConditionToggle.bind(this));
    html.find('.toggle-enc').click(this._onToggleContainerEncumbrance.bind(this));
    html.find('.ingredient-selector').change(this._onSelectIngredient.bind(this));
    html.find('.injury-duration').mousedown(this._onInjuryDurationClick.bind(this));
    html.find(".system-effect-select").change(this._onSystemEffectChanged.bind(this));
    html.find(".condition-value").mousedown(this._onConditionValueClicked.bind(this));
    html.find('.metacurrency-value').mousedown(this._onMetaCurrrencyClick.bind(this));
    html.find('.skill-total, .skill-select').mousedown(this._onSkillClick.bind(this));
    html.find(".tab.inventory .item .item-name").mousedown(this._onItemSplit.bind(this));
    html.find('.skill-advances, .ch-edit').focusin(this._saveFocus.bind(this));
    html.find(".attacker-remove").click(this._onAttackerRemove.bind(this));
    html.find(".currency-convert-right").click(this._onConvertCurrencyClick.bind(this));
    html.find(".sort-items").click(this._onSortClick.bind(this));
    html.find(".invoke").click(this._onInvokeClick.bind(this));
    html.find(".group-actions").click(this._toggleGroupAdvantageActions.bind(this));
    html.find(".weapon-property .inactive").click(this._toggleWeaponProperty.bind(this));
    html.find(".section-collapse").click(this._toggleSectionCollapse.bind(this));

    // Item Dragging
    let handler = this._onDragStart.bind(this);
    html.find('.item').each((i, li) => {
      li.setAttribute("draggable", true);
      li.addEventListener("dragstart", handler, false);
    });


    html.on("dragenter", ".mount-drop", ev => {
      ev.target.classList.add("dragover");
    });
    html.on("dragleave", ".mount-drop", ev => {
      ev.target.classList.remove("dragover");
    });
    html.on("drop", ".mount-drop", async ev => {
      ev.target.classList.remove("dragover");
      let dragData = JSON.parse(ev.originalEvent.dataTransfer.getData("text/plain"));

      let mount = await Actor.implementation.fromDropData(dragData);
      if (game.wfrp4e.config.actorSizeNums[mount.details.size.value] < game.wfrp4e.config.actorSizeNums[this.actor.details.size.value])
        return ui.notifications.error(game.i18n.localize("MountError"))

      let mountData = {
        id: mount.id,
        mounted: true,
        isToken: false
      };
      if(this.actor.prototypeToken.actorLink && !mount.prototypeToken.actorLink)
        ui.notifications.warn(game.i18n.localize("WarnUnlinkedMount"));

      this.actor.update({ "system.status.mount": mountData });
    });

    html.find('.mount-toggle').click(this._onMountToggle.bind(this));
    html.find('.mount-remove').click(this._onMountRemove.bind(this));


    html.find('.mount-section').click(ev => {
      this.actor.mount.sheet.render(true);
    });

    // ---- Listen for custom entity links -----
    html.on("click", ".chat-roll", WFRP_Utility$1.handleRollClick.bind(WFRP_Utility$1));
    html.on("click", ".symptom-tag", WFRP_Utility$1.handleSymptomClick.bind(WFRP_Utility$1));
    html.on("click", ".condition-chat", WFRP_Utility$1.handleConditionClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.table-click', WFRP_Utility$1.handleTableClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.pay-link', WFRP_Utility$1.handlePayClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.credit-link', WFRP_Utility$1.handleCreditClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.corruption-link', WFRP_Utility$1.handleCorruptionClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.fear-link', WFRP_Utility$1.handleFearClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.terror-link', WFRP_Utility$1.handleTerrorClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.exp-link', WFRP_Utility$1.handleExpClick.bind(WFRP_Utility$1));

    html.on("click", ".use-grp-adv", this._onUseGrpAdvAction.bind(this));

  }

  //#region ROLLING
  //@@@@@@@@@ ROLLING @@@@@@@@@@@/

  _onCharClick(ev) {
    ev.preventDefault();
    let characteristic = ev.currentTarget.attributes["data-char"].value;
    this.actor.setupCharacteristic(characteristic).then(setupData => {
      this.actor.basicTest(setupData);
    });
  }

  _onSkillClick(ev) {
    let itemId = this._getId(ev);
    let skill = this.actor.items.get(itemId);

    if (ev.button == 0) {
      skill = this.actor.items.get(itemId);
      this.actor.setupSkill(skill).then(setupData => {
        this.actor.basicTest(setupData);
      });
    }
    else if (ev.button == 2) {
      skill.sheet.render(true);
    }
  }

  _onExtendedTestSelect(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    this.actor.setupExtendedTest(item);
  }

  _onWeaponNameClick(ev) {
    ev.preventDefault();
    let itemId = this._getId(ev);
    let weapon = this.actor.items.get(itemId);
    if (weapon) this.actor.setupWeapon(weapon).then(setupData => {
      if (!setupData.abort)
        this.actor.weaponTest(setupData);
    });
  }
  async _onUnarmedClick(ev) {
    ev.preventDefault();
    let unarmed = game.wfrp4e.config.systemItems.unarmed;
    this.actor.setupWeapon(unarmed).then(setupData => {
      this.actor.weaponTest(setupData);
    });
  }
  async _onDodgeClick(ev) {
      this.actor.setupSkill(game.i18n.localize("NAME.Dodge")).then(setupData => {
        this.actor.basicTest(setupData);
      });
  }
  async _onImprovisedClick(ev) {
    ev.preventDefault();
    let improv = game.wfrp4e.config.systemItems.improv;
    this.actor.setupWeapon(improv).then(setupData => {
      this.actor.weaponTest(setupData);
    });
  }

  async _onStompClick(ev) {
    ev.preventDefault();
    let stomp = game.wfrp4e.config.systemItems.stomp;
    this.actor.setupTrait(stomp).then(setupData => {
      this.actor.traitTest(setupData);
    });
  }
  async _onRestClick(ev) {
    let skill = this.actor.getItemTypes("skill").find(s => s.name == game.i18n.localize("NAME.Endurance"));
    let options = {rest: true, tb: this.actor.characteristics.t.bonus};
    if (skill)
      this.actor.setupSkill(skill, options).then(setupData => {
        this.actor.basicTest(setupData);
      });
    else
      this.actor.setupCharacteristic("t", options).then(setupData => {
        this.actor.basicTest(setupData);
      });
  }

  _onTraitRoll(ev) {
    ev.preventDefault();
    if (ev.button == 2)
      return this._onItemSummary(ev);

    let itemId = this._getId(ev);
    let trait = this.actor.items.get(itemId);
    this.actor.setupTrait(trait).then(setupData => {
      this.actor.traitTest(setupData);
    });
  }
  _onSpellRoll(ev) {
    ev.preventDefault();
    if (ev.button == 2)
      return this._onItemSummary(ev);

    let itemId = this._getId(ev);
    let spell = this.actor.items.get(itemId);
    this.spellDialog(spell);
  }

  _onPrayerRoll(ev) {
    ev.preventDefault();
    if (ev.button == 2)
      return this._onItemSummary(ev);

    let itemId = this._getId(ev);
    let prayer = this.actor.items.get(itemId);
    this.actor.setupPrayer(prayer).then(setupData => {
      this.actor.prayerTest(setupData);
    });
  }

  //#endregion

  //#region SHEET INTERACTIONS
  //@@@@@@@@@ INTERACTIONS @@@@@@@@@@@/

  _saveFocus(ev) {
    if (ev.target.attributes["data-id"])
      this.saveFocus = `data-id="${ev.target.attributes["data-id"].value}`;

    if (ev.target.attributes["data-char"])
      this.saveFocus = `data-char="${ev.target.attributes["data-char"].value}`;
  }

  async _onEditChar(ev) {
    ev.preventDefault();
    let characteristics = duplicate(this.actor._source.characteristics);
    let ch = ev.currentTarget.attributes["data-char"].value;
    let newValue = Number(ev.target.value);

    if (this.actor.type == "character")
    {
      let resolved = await WFRP_Utility$1.advancementDialog(ch, newValue, "characteristic", this.actor);

      // If not resolved, reset characteristic ui value
      if (!resolved)
      {
        ev.target.value = characteristics[ch].advances;
        return 
      }
      else characteristics[ch].advances = newValue;
    }
    else { // If not character
      if (!(newValue == characteristics[ch].initial + characteristics[ch].advances)) {
        characteristics[ch].initial = newValue;
        characteristics[ch].advances = 0;
      }
    }
    return this.actor.update({ "system.characteristics": characteristics })
  }

  async _onChangeSkillAdvances(ev) {
    ev.preventDefault();
    let itemId = ev.target.attributes["data-id"].value;
    let itemToEdit = this.actor.items.get(itemId);
    if (this.actor.type == "character")
    {
      let resolved = await WFRP_Utility$1.advancementDialog(
        itemToEdit,
        Number(ev.target.value), 
        "skill", 
        this.actor);

        // reset advances value if dialog was not resolved
        if (!resolved)  
        {
          ev.target.value = itemToEdit.advances.value;
          return
        }
    }
    itemToEdit.update({ "system.advances.value": Number(ev.target.value) });
  }

  _onSelectAmmo(ev) {
    let itemId = ev.target.attributes["data-id"].value;
    const item = this.actor.items.get(itemId);
    WFRP_Audio.PlayContextAudio({ item, action: "load" });
    return item.update({ "system.currentAmmo.value": ev.target.value });
  }

  _onSelectSpell(ev) {
    let itemId = ev.target.attributes["data-id"].value;
    const ing = this.actor.items.get(itemId);
    return ing.update({ "system.spellIngredient.value": ev.target.value });
  }

  _onSelectIngredient(ev) {
    let itemId = ev.target.attributes["data-id"].value;
    const spell = this.actor.items.get(itemId);
    return spell.update({ "system.currentIng.value": ev.target.value });
  }

  _onSkillSwitch(ev) {
    this.actor.setFlag("wfrp4e", "showExtendedTests", !getProperty(this.actor, "flags.wfrp4e.showExtendedTests"));
    this.render(true);
  }

  _onExtendedSLClick(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    let SL;
    if (ev.button == 0) SL = item.SL.current + 1;
    else if (ev.button == 2) SL = item.SL.current - 1;

    if (SL < 0 && !item.negativePossible.value)
      SL = 0;
    return item.update({ "system.SL.current": SL })
  }

  _onAPClick(ev) {
    let itemId = this._getId(ev);
    let APlocation = $(ev.currentTarget).parents(".armour-box").attr("data-location");
    let item = this.actor.items.get(itemId);
    let itemData = item.toObject();

    let maxDamageAtLocation = item.AP[APlocation] + Number(item.properties.qualities.durable?.value || 0);
    let minDamageAtLocation = 0;

    switch (ev.button) {
      case 2:
        itemData.system.APdamage[APlocation] = Math.min(maxDamageAtLocation, itemData.system.APdamage[APlocation] + 1);
        break;
      case 0:
        itemData.system.APdamage[APlocation] = Math.max(minDamageAtLocation, itemData.system.APdamage[APlocation] - 1);
        break
    }
    this.actor.updateEmbeddedDocuments("Item", [itemData]);
  }

  _onWeaponDamageClick(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    let itemData = item.toObject();

    let regex = /\d{1,3}/gm;
    let maxDamage = Number(regex.exec(item.damage.value)[0] || 0) + Number(item.properties.qualities.durable?.value || 0) || 999;
    let minDamage = 0;

    if (ev.button == 2) {
      itemData.system.damageToItem.value = Math.min(maxDamage, itemData.system.damageToItem.value + 1);
      WFRP_Audio.PlayContextAudio({ item: item, action: "damage", outcome: "weapon" });
    }
    else if (ev.button == 0)
      itemData.system.damageToItem.value = Math.max(minDamage, itemData.system.damageToItem.value - 1);

    //TODO This (and other validations) really should be elsewhere 
    if (maxDamage == itemData.system.damageToItem.value)
    {
        itemData.system.equipped = false;
    }


    this.actor.updateEmbeddedDocuments("Item", [itemData]);
  }

  _onArmourTotalClick(ev) {
    let location = $(ev.currentTarget).closest(".column").find(".armour-box").attr("data-location");
    if (!location) location = $(ev.currentTarget).closest(".column").attr("data-location");
    if (!location) return;

    let armourTraits = this.actor.getItemTypes("trait").filter(i => i.name.toLowerCase() == game.i18n.localize("NAME.Armour").toLowerCase()).map(i => i.toObject());
    let armourItems = this.actor.getItemTypes("armour").filter(i => i.isEquipped).sort((a, b) => a.sort - b.sort);
    let armourToDamage;
    let usedTrait = false;
    // Damage traits first
    for (let armourTrait of armourTraits) {
      // If APDamage flag doesn't exist
      if (armourTrait && !getProperty(armourTrait, "flags.wfrp4e.APdamage")) setProperty(armourTrait, "flags.wfrp4e.APdamage", { head: 0, body: 0, lArm: 0, rArm: 0, lLeg: 0, rLeg: 0 });
      if (armourTrait) {
        if (ev.button == 0) {
          if (armourTrait.flags.wfrp4e.APdamage[location] != 0) {
            armourTrait.flags.wfrp4e.APdamage[location]--;
            usedTrait = true;
          }
        }
        if (ev.button == 2) {
          // If AP Damage at location is maxed, go to the next iteration
          if (armourTrait.flags.wfrp4e.APdamage[location] == Number(armourTrait.system.specification.value)) { continue }
          // Else, damage that location
          if (armourTrait.flags.wfrp4e.APdamage[location] != Number(armourTrait.system.specification.value)) {
            armourTrait.flags.wfrp4e.APdamage[location]++;
            usedTrait = true;
          }
        }
        if (usedTrait)
          return this.actor.updateEmbeddedDocuments("Item", [armourTrait])

      }
    }
    if (armourItems && !usedTrait) {
      if (ev.button == 0) armourItems.reverse();
      for (let a of armourItems) {
        if (ev.button == 2) {
          if (a.currentAP[location] > 0) {
            armourToDamage = a;
            break
          }
        }
        else if (ev.button == 0) {
          if (a.AP[location] > 0 && a.APdamage[location] > 0) {
            armourToDamage = a;
            break
          }
        }
      }
    }
    if (!armourToDamage)
      return
    let durable = armourToDamage.properties.qualities.durable;
    armourToDamage = armourToDamage.toObject();

      // Damage on right click 
      if (ev.button == 2) {                            // Damage shouldn't go past AP max (accounting for durable)
        armourToDamage.system.APdamage[location] = Math.min(armourToDamage.system.AP[location] + (Number(durable?.value) || 0), armourToDamage.system.APdamage[location] + 1);
        ui.notifications.notify(game.i18n.localize("SHEET.ArmourDamaged"));
      }
      // Repair on left
      if (ev.button == 0) {                         // Damage shouldn't go below 0
        armourToDamage.system.APdamage[location] = Math.max(0, armourToDamage.system.APdamage[location] - 1);
        ui.notifications.notify(game.i18n.localize("SHEET.ArmourRepaired"));
      }
      return this.actor.updateEmbeddedDocuments("Item", [armourToDamage])
    }


  _onShieldClick(ev) {
    let shields = this.actor.getItemTypes("weapon").filter(i => i.isEquipped && i.properties.qualities.shield);
    for (let s of shields) {
      let shieldQualityValue = s.properties.qualities.shield.value;
      if (ev.button == 2) {
        if (s.damageToItem.shield < Number(shieldQualityValue)) {
          WFRP_Audio.PlayContextAudio({ item: s, action: "damage", outcome: "shield" });
          return s.update({ "system.damageToItem.shield": s.damageToItem.shield + 1 });
        }
      }
      if (ev.button == 0) {
        if (s.damageToItem.shield != 0) {
          return s.update({ "system.damageToItem.shield": s.damageToItem.shield - 1 });
        }
      }
    }
  }

  async _onMemorizedClick(ev) {
    let itemId = this._getId(ev);
    const spell = this.actor.items.get(itemId);


    // unmemorized
    if (spell.memorized.value)
    {
      WFRP_Audio.PlayContextAudio({ item: spell, action: "unmemorize" });
      return spell.update({ "system.memorized.value": !spell.memorized.value })
    }


    let memorize = true;
    if (this.actor.type == "character") {
      memorize = await WFRP_Utility$1.memorizeCostDialog(spell, this.actor);
    }

    if (!memorize) 
      return
    
    if (!spell.memorized.value)
      WFRP_Audio.PlayContextAudio({ item: spell, action: "memorize" });
    else
      WFRP_Audio.PlayContextAudio({ item: spell, action: "unmemorize" });
    
    return spell.update({ "system.memorized.value": !spell.memorized.value })


  }

  _onSpellSLClick(ev) {
    let itemId = this._getId(ev);
    const spell = this.actor.items.get(itemId);
    let SL = spell.cn.SL;
    switch (ev.button) {
      case 0: SL++;
        if (SL > (spell.memorized.value ? spell.cn.value : spell.cn.value * 2))
          SL = (spell.memorized.value ? spell.cn.value : spell.cn.value * 2);
        break;
      case 2:
        SL--;
        if (SL < 0)
          SL = 0;
        break
    }
    return spell.update({ "system.cn.SL": SL })
  }

  async _onAutoCalcToggle(ev) {
    let toggle = ev.target.attributes["toggle-type"].value;
    if (ev.button == 2) {
      let newFlags = duplicate(this.actor.flags);
      if (toggle == "walk") newFlags.autoCalcWalk = !newFlags.autoCalcWalk;

      else if (toggle == "run")
        newFlags.autoCalcRun = !newFlags.autoCalcRun;
      else if (toggle == "wounds")
        newFlags.autoCalcWounds = !newFlags.autoCalcWounds;
      else if (toggle == "critW")
        newFlags.autoCalcCritW = !newFlags.autoCalcCritW;
      else if (toggle == "corruption")
        newFlags.autoCalcCorruption = !newFlags.autoCalcCorruption;
      else if (toggle == "encumbrance")
        newFlags.autoCalcEnc = !newFlags.autoCalcEnc;

      return this.actor.update({ 'flags': newFlags })
    }
  }

  async _onDiseaseRoll(ev) {
    let itemId = this._getId(ev);
    const disease = this.actor.items.get(itemId).toObject();
    let type = ev.target.dataset["type"];
    if (type == "incubation")
      disease.system.duration.active = false;
    if (!isNaN(disease.system[type].value)) {
      let number = Number(disease.system[type].value);
      if (ev.button == 0)
        return this.actor.decrementDisease(disease)
      else
        number++;
      disease.system[type].value = number;
      return this.actor.updateEmbeddedDocuments("Item", [disease])
    }
    else if (ev.button == 0) {
      try {
        let rollValue = (await new Roll(disease.system[type].value).roll()).total;
        disease.system[type].value = rollValue;
        if (type == "duration")
          disease.system.duration.active = true;
      }
      catch
      {
        return ui.notifications.error(game.i18n.localize("ERROR.ParseDisease"))
      }
      return this.actor.updateEmbeddedDocuments("Item", [disease])
    }
  }

  async _onInjuryDurationClick(ev) {
    let itemId = this._getId(ev);
    let injury = this.actor.items.get(itemId).toObject();
    if (!isNaN(injury.system.duration.value)) {
      if (ev.button == 0)
        return this.actor.decrementInjury(injury)
      else injury.system.duration.value++;
      return this.actor.updateEmbeddedDocuments("Item", [injury])
    }
    else {
      try {
        let rollValue = (await new Roll(injury.system.duration.value).roll()).total;
        injury.system.duration.value = rollValue;
        injury.system.duration.active = true;
        return this.actor.updateEmbeddedDocuments("Item", [injury])
      }
      catch
      {
        return ui.notifications.error(game.i18n.localize("ERROR.ParseInjury"))
      }
    }
  }

  async _onMetaCurrrencyClick(ev) {
    let type = $(ev.currentTarget).attr("data-point-type");
    let newValue = ev.button == 0 ? this.actor.status[type].value + 1 : this.actor.status[type].value - 1;
    return this.actor.update({ [`system.status.${type}.value`]: newValue })
  }

  _onItemEdit(ev) {
    let itemId = this._getId(ev);
    const item = this.actor.items.get(itemId);
    return item.sheet.render(true)
  }

  _onEffectDelete(ev) {
    let uuid = this._getUUID(ev);
    let effect = fromUuidSync(uuid);
    effect.delete();  
  }

  async _onEffectEdit(ev) {
    let uuid = this._getUUID(ev);
    let effect = fromUuidSync(uuid);
    return effect.sheet.render(true);
  }

  async _onEffectToggle(ev)
  {
    let uuid = this._getUUID(ev);
    let effect = fromUuidSync(uuid);
    return effect.update({disabled : !effect.disabled});
  }


  _onEffectTarget(ev) {
    let id = this._getId(ev);
    
    let effect = this.actor.populateEffect(id);
    if (effect.trigger == "apply")
      game.wfrp4e.utility.applyEffectToTarget(effect);
    else {
      game.wfrp4e.utility.runSingleEffect(effect, this.actor, effect.item, {actor : this.actor, effect, item : effect.item});
    }
  }

  _onAdvanceDisease(ev) {
    return this.actor.decrementDiseases()
  }

  _onItemDelete(ev) {
    let li = $(ev.currentTarget).parents(".item");
    let itemId = this._getId(ev);
    if (this.actor.items.get(itemId).name == "Boo") {
      AudioHelper.play({ src: `${game.settings.get("wfrp4e", "soundPath")}squeek.wav` }, false);
      return
    }
    renderTemplate('systems/wfrp4e/templates/dialog/delete-item-dialog.hbs').then(html => {
      new Dialog({
        title: game.i18n.localize("Delete Confirmation"), 
        content: `<div class="delete-item-dialog selection"> 
                  <label>${game.i18n.localize("DIALOG.DeleteItem")}</label>
                  </div>`,
        buttons: {
          yes: {
            icon: '<i class="fa fa-check"></i>', label: game.i18n.localize("Yes"), callback: async dlg => {
              await this.actor.deleteEmbeddedDocuments("Item", [itemId]);
              li.slideUp(200, () => this.render(false));
            }
          }, cancel: { icon: '<i class="fas fa-times"></i>', label: game.i18n.localize("Cancel") },
        }, default: 'yes'
      }).render(true);
    });
  }

  _onItemRemove(ev) {
    let itemId = this._getId(ev);
    const item = this.actor.items.get(itemId);
    return item.update({ "system.location.value": "" })
  }

  _onToggleContainerEncumbrance(ev) {
    let itemId = this._getId(ev);
    const item = this.actor.items.get(itemId);
    return item.update({ "system.countEnc.value": !item.countEnc.value })
  }

  _onItemToggle(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId).toObject();
    let equippedState;
    if (item.type == "armour") {
      item.system.worn.value = !item.system.worn.value;
      equippedState = item.system.worn.value;
    } else if (item.type == "weapon") {
      item.system.equipped = !item.system.equipped;
      equippedState = item.system.equipped;
      let newEqpPoints = item.system.twohanded.value ? 2 : 1;
      if (item.flags?.wfrp4e?.noEqpPoints) {
        newEqpPoints = 0;
      }
      if (game.settings.get("wfrp4e", "limitEquippedWeapons") && this.actor.type != "vehicle")
        if (this.actor.equipPointsUsed + newEqpPoints > this.actor.equipPointsAvailable && equippedState) {
          AudioHelper.play({ src: `${game.settings.get("wfrp4e", "soundPath")}/no.wav` }, false);
          return ui.notifications.error(game.i18n.localize("ErrorLimitedWeapons"))
        }
      setProperty(item, "system.offhand.value", false);
    }
    else if (item.type == "trapping" && item.system.trappingType.value == "clothingAccessories") {
      item.system.worn = !item.system.worn;
      equippedState = item.system.worn;
    }
    WFRP_Audio.PlayContextAudio({ item: this.actor.items.get(itemId), action: "equip", outcome: equippedState });
    this.actor.updateEmbeddedDocuments("Item", [item]);
  }

  _onCheckboxClick(ev) {
    let itemId = this._getId(ev);
    let target = $(ev.currentTarget).attr("data-target");
    this.toggleItemCheckbox(itemId, target);
  }

  _onLoadedClick(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    let itemObject = item.toObject();
    if (item.repeater) {
      if (ev.button == 0 && itemObject.system.loaded.amt >= itemObject.system.loaded.max) return
      if (ev.button == 2 && itemObject.system.loaded.amt <= 0)
        return
      if (ev.button == 0) itemObject.system.loaded.amt++;
      if (ev.button == 2) itemObject.system.loaded.amt--;
      itemObject.system.loaded.value = !!itemObject.system.loaded.amt;
    }
    else {
      itemObject.system.loaded.value = !itemObject.system.loaded.value;
      if (itemObject.system.loaded.value)
        itemObject.system.loaded.amt = itemObject.system.loaded.max || 1;
      else itemObject.system.loaded.amt = 0;
    }
    this.actor.updateEmbeddedDocuments("Item", [itemObject]).then(i => this.actor.checkReloadExtendedTest(item));
  }

  _onRepeaterClick(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId).toObject();
    item.system.loaded.value = !item.system.loaded.value;
    if (item.system.loaded.value) item.system.loaded.amt = item.system.loaded.max || 1;
    this.actor.updateEmbeddedDocuments("Item", [item]);
  }

  _onWornClick(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    return item.update({ "system.worn.value": !item.worn.value })
  }

  _onQuantityClick(ev) {
    let itemId = this._getId(ev);
    let item = this.actor.items.get(itemId);
    let quantity = item.quantity.value;
    switch (ev.button) {
      case 0: if (ev.ctrlKey) quantity += 10;
      else quantity++;
        break;
      case 2: if (ev.ctrlKey) quantity -= 10;
      else quantity--;
        if (quantity < 0) quantity = 0;
        break
    }
    item.update({ "system.quantity.value": quantity });
  }

  async _onAggregateClick(ev) {
    let itemType = $(ev.currentTarget).attr("data-type");
    if (itemType == "ingredient") itemType = "trapping";
    let items = this.actor.getItemTypes(itemType).map(i => i.toObject());
    for (let i of items) {
      let duplicates = items.filter(x => x.name == i.name);
      if (duplicates.length > 1) {
        let newQty = duplicates.reduce((prev, current) => prev + parseInt(current.system.quantity.value), 0);
        i.system.quantity.value = newQty;
      }
    }
    let noDuplicates = [];
    for (let i of items) {
      if (!noDuplicates.find(x => x.name == i.name)) {
        noDuplicates.push(i);
        await this.actor.updateEmbeddedDocuments("Item", [{ "_id": i._id, "system.quantity.value": i.system.quantity.value }]);
      }
      else await this.actor.deleteEmbeddedDocuments("Item", [i._id]);
    }
  }
  _onItemSplit(ev) {
    if (ev.button == 2) {
      new Dialog({
        title: game.i18n.localize("SHEET.SplitTitle"), content: `<p>${game.i18n.localize("SHEET.SplitPrompt")}</p><div class="form-group"><input name="split-amt"type="text"/></div>`, buttons: {
          split: {
            label: game.i18n.localize("Split"), callback: (dlg) => {
              let amt = Number(dlg.find('[name="split-amt"]').val());
              if (Number.isNumeric(amt))
                return this.splitItem(this._getId(ev), amt)
            }
          }
        }, default: "split"
      }).render(true);
    }
  }
  async _onConditionValueClicked(ev) {
    let condKey = $(ev.currentTarget).parents(".sheet-condition").attr("data-cond-id");
    if (ev.button == 0)
      await this.actor.addCondition(condKey);
    else if (ev.button == 2)
      await this.actor.removeCondition(condKey);
  }
  async _onConditionToggle(ev) {
    let condKey = $(ev.currentTarget).parents(".sheet-condition").attr("data-cond-id");
    if (game.wfrp4e.config.statusEffects.find(e => e.id == condKey).flags.wfrp4e.value == null) {
      if (this.actor.hasCondition(condKey))
        await this.actor.removeCondition(condKey);
      else 
        await this.actor.addCondition(condKey);
      return
    }
    if (ev.button == 0)
      await this.actor.addCondition(condKey);
    else if (ev.button == 2)
      await this.actor.removeCondition(condKey);
  }
  async _onSpeciesEdit(ev) {
    let input = ev.target.value;
    let split = input.split("(");
    let species = split[0].trim();
    let subspecies;
    if (split.length > 1)
      subspecies = split[1].replace(")", "").trim();
    let speciesKey = WFRP_Utility$1.findKey(species, game.wfrp4e.config.species) || species;
    let subspeciesKey = "";
    if (subspecies) {
      for (let sub in game.wfrp4e.config.subspecies[speciesKey]) {
        if (game.wfrp4e.config.subspecies[speciesKey][sub].name == subspecies) subspeciesKey = sub;
      }
      if (!subspeciesKey)
        subspeciesKey = subspecies;
    }
    await this.actor.update({ "system.details.species.value": speciesKey, "system.details.species.subspecies": subspeciesKey });
    if (this.actor.type == "character")
      return
    try {
      let initialValues = await WFRP_Utility$1.speciesCharacteristics(speciesKey, true, subspeciesKey);
      let characteristics = this.actor.toObject().system.characteristics;
      for (let c in characteristics) {
        characteristics[c].initial = initialValues[c].value;
      }

      new Dialog({
        content: game.i18n.localize("SpecChar"), title: game.i18n.localize("Species Characteristics"), buttons: {
          yes: {
            label: game.i18n.localize("Yes"), callback: async () => {
              await this.actor.update({ 'system.characteristics': characteristics });

              await this.actor.update({ "system.details.move.value": WFRP_Utility$1.speciesMovement(species) || 4 });
            }
          }, no: { label: game.i18n.localize("No"), callback: () => { } }
        }
      }).render(true);
    } catch{ }
  }

  async _onRandomizeClicked(ev) {
    ev.preventDefault();
    let species = this.actor.details.species.value;
    let subspecies = this.actor.details.species.subspecies;
    try {
      switch (ev.target.text) {
        case game.i18n.localize("RANDOMIZER.C"): let creatureMethod = false;
          let characteristics = this.actor.toObject().system.characteristics;
          if (this.actor.type == "creature" || !species) creatureMethod = true;
          if (!creatureMethod) {
            let averageCharacteristics = await WFRP_Utility$1.speciesCharacteristics(species, true, subspecies);
            for (let char in characteristics) {
              if (characteristics[char].initial != averageCharacteristics[char].value) creatureMethod = true;
            }
          }
          if (!creatureMethod) {
            let rolledCharacteristics = await WFRP_Utility$1.speciesCharacteristics(species, false, subspecies);
            for (let char in rolledCharacteristics) {
              characteristics[char].initial = rolledCharacteristics[char].value;
            }
            await this.actor.update({ "system.characteristics": characteristics });
          }
          else if (creatureMethod) {
            let roll = new Roll("2d10");
            await roll.roll();
            let characteristics = this.actor.toObject().system.characteristics;
            for (let char in characteristics) {
              if (characteristics[char].initial == 0)
                continue
              characteristics[char].initial -= 10;
              characteristics[char].initial += (await roll.reroll()).total;
              if (characteristics[char].initial < 0)
                characteristics[char].initial = 0;
            }
            await this.actor.update({ "system.characteristics": characteristics });
          }
          return

        case game.i18n.localize("RANDOMIZER.S"):
          this.actor._advanceSpeciesSkills();
          return
        case game.i18n.localize("RANDOMIZER.T"):
          this.actor._advanceSpeciesTalents();
          return
      }
    }
    catch (error) {
      WFRP_Utility$1.log("Could not randomize: " + error, true);
    }
  }

  // Add condition description dropdown
  async _onConditionClicked(ev) {
    ev.preventDefault();
    let li = $(ev.currentTarget).parents(".sheet-condition"),
      elementToAddTo = $(ev.currentTarget).parents(".condition-list"),
      condkey = li.attr("data-cond-id"), expandData = await TextEditor.enrichHTML(`<h2>${game.wfrp4e.config.conditions[condkey]}</h2>` + game.wfrp4e.config.conditionDescriptions[condkey], {async: true});

    if (elementToAddTo.hasClass("expanded")) {
      let summary = elementToAddTo.parents(".effects").children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    }
    else {
      let div = $(`<div class="item-summary">${expandData}</div>`);
      if (game.wfrp4e.config.conditionScripts[condkey] && this.actor.hasCondition(condkey)) {
        let button = $(`<br><br><a class="condition-script">${game.i18n.format("CONDITION.Apply", { condition: game.wfrp4e.config.conditions[condkey] })}</a>`);
        div.append(button);
      }
      elementToAddTo.after(div.hide());
      div.slideDown(200);
      div.on("click", ".condition-script", async ev => {
        ui.sidebar.activateTab("chat");
        ChatMessage.create(await game.wfrp4e.config.conditionScripts[condkey](this.actor));
      });
    }
    elementToAddTo.toggleClass("expanded");
  }
  _onItemPostClicked(ev) {
    let itemId = this._getId(ev);
    const item = this.actor.items.get(itemId);
    item.postItem();
  }

  _onNameClicked(ev) {
    let name = NameGenWfrp.generateName({ species: this.actor.details.species.value, gender: this.actor.details.gender.value });
    this.actor.update({ "name": name });
  }

  _onMountToggle(ev) {
    ev.stopPropagation();
    this.actor.update({ "system.status.mount.mounted": !this.actor.status.mount.mounted });
  }

  _onMountRemove(ev) {
    ev.stopPropagation();
    let mountData = { id: "", mounted: false, isToken: false };
    this.actor.update({ "system.status.mount": mountData });
  }

  _onAttackerRemove(ev) {
    this.actor.update({ "flags.-=oppose": null });
  }

  _onMountClicked(ev) {
    this.actor.mount.sheet.render(true);
  }
  _onSystemEffectChanged(ev) {
    let ef = ev.target.value;
    this.actor.addSystemEffect(ef);
  }

  _onMoneyIconClicked(ev) {
    ev.preventDefault();
    let money = this.actor.getItemTypes("money");
    let newMoney = MarketWfrp4e.consolidateMoney(money.map(i => i.toObject()));
    return this.actor.updateEmbeddedDocuments("Item", newMoney)
  }

  /**
   * Handle creating a new Owned Item for the actor using initial data defined in the HTML dataset
   * @private
   * @param {Object} ev    ev triggered by clicking on the + button for any item list
   *  
   */
  _onItemCreate(ev) {
    ev.preventDefault();
    let header = ev.currentTarget,
      data = duplicate(header.dataset);

    if (data.type == "effect")
      return this.actor.createEmbeddedDocuments("ActiveEffect", [{ name: game.i18n.localize("New Effect") }])

    if (data.type == "vehicle-role" && this.actor.type == "vehicle") {
      let roles = duplicate(this.actor.roles);
      let newRole = { name: game.i18n.localize("NewRole"), actor: "", test: "", testLabel: "" };
      roles.push(newRole);
      return this.actor.update({ "system.roles": roles })
    }

    // Conditional for creating skills from the skills tab - sets to the correct skill type depending on column
    if (ev.currentTarget.attributes["data-type"].value == "skill") {
      data = mergeObject(data,
        {
          "system.advanced.value": ev.currentTarget.attributes["data-skill-type"].value
        });
    }

    if (data.type == "trapping")
      data = mergeObject(data,
        {
          "system.trappingType.value": ev.currentTarget.attributes["item-section"].value
        });

    if (data.type == "ingredient") {
      data = mergeObject(data,
        {
          "system.trappingType.value": "ingredient"
        });
      data.type = "trapping";
    }

    // Conditional for creating spells/prayers from their tabs, create the item with the correct type
    else if (data.type == "spell" || data.type == "prayer") {
      let itemSpecification = ev.currentTarget.attributes[`data-${data.type}-type`].value;

      if (data.type == "spell") {
        data = mergeObject(data,
          {
            "system.lore.value": itemSpecification
          });
      }
      else if (data.type == "prayer") {
        data = mergeObject(data,
          {
            "system.type.value": itemSpecification
          });
      }
    }
    data["img"] = "systems/wfrp4e/icons/blank.png";
    data["name"] = `${game.i18n.localize("New")} ${data.type.capitalize()}`;
    this.actor.createEmbeddedDocuments("Item", [data]);
  }

  // _onEffectCreate(ev) {
  //   let type = ev.currentTarget.attributes["data-effect"].value
  //   let effectData = { name: game.i18n.localize("New Effect") }
  //   if (type == "temporary") {
  //     effectData["duration.rounds"] = 1;
  //   }
  //   if (type == "applied") {
  //     effectData["flags.wfrp4e.effectApplication"] = "apply"
  //   }
  //   this.actor.createEmbeddedDocuments("ActiveEffect", [effectData])
  // }


  _onInvokeClick(ev) {
    let id = this._getId(ev);
    game.wfrp4e.utility.invokeEffect(this.actor, id);
  }

  //#endregion


  //#region DRAG/DROP
  /**
   * Sets up the data transfer within a drag and drop ev. This is triggered
   * when the user starts dragging an inventory item, and dataTransfer is set to the 
   * relevant data needed by the _onDrop  See that for how drop events
   * are handled.
   * 
   * @private
   * 
   * @param {Object} ev    ev triggered by item dragging
   */
  _onDragStart(event) {
    const li = event.currentTarget;
    if ( event.target.classList.contains("content-link") ) return;

    // Create drag data
    let dragData;

    if (li.dataset.uuid)
    {
      let doc = fromUuidSync(li.dataset.uuid);
      dragData = doc.toDragData();
    }

    // Owned Items (assumed)
    else if ( li.dataset.id ) {
      const item = this.actor.items.get(li.dataset.id);
      dragData = item.toDragData();
    }

    // Owned Items (explicit)
    else if ( li.dataset.itemId ) {
      const item = this.actor.items.get(li.dataset.itemId);
      dragData = item.toDragData();
    }

    // Active Effect
    else if ( li.dataset.effectId ) {
      const effect = this.actor.effects.get(li.dataset.effectId);
      dragData = effect.toDragData();
    }

    if ( !dragData ) return;

    dragData.root = event.currentTarget.getAttribute("root");

    // Set data transfer
    event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
  }

  /**
   * Handles all different types of drop events and processes the transfer data
   * for each type.
   * 
   * 
   * If you want to see how these (except inventory tab) drag events are generated, see the renderChatMessage hook
   * Besides containers, drag vents should be generated with a "type" and a "payload" at top level
   * 
   * type tells us what to do with the payload. 
   * Current types are: 
   * - generation (character generation drag and drop, which also includes generationType, telling us what stage was dragged)
   * - postedItem (item that was posted to chat)
   * - lookup (entity lookup, payload.lookupType tells us whether it's a skill or talent. Adds to the sheet)
   * - experience (payload is amount to add)
   * - wounds (payload is amount to add)
   *  
   * 
   * @private 
   * @param {Object} ev     ev triggered by item dropping
   */
  async _onDrop(ev) {
    let dragData = JSON.parse(ev.dataTransfer.getData("text/plain"));

    // Inventory Tab - Containers - Detected when you drop something onto a container, otherwise, move on to other drop types
    if ($(ev.target).parents(".item").attr("inventory-type") == "container")
      this._onDropIntoContainer(ev);

    // Dropping an item from chat
    else if (dragData.type == "postedItem")
      this.actor.createEmbeddedDocuments("Item", [dragData.payload]);

    else if (dragData.type == "generation")
      this._onDropCharGen(dragData);

    else if (dragData.type == "lookup")
      this._onDropLookupItem(dragData);

    else if (dragData.type == "experience")
      this._onDropExperience(dragData);

    else if (dragData.type == "money")
      this._onDropMoney(dragData);

    else if (dragData.type == "wounds")
      this.modifyWounds(`+${dragData.payload}`);

    else if (dragData.type == "condition")
      this.actor.addCondition(`${dragData.payload}`);

    else // If none of the above, just process whatever was dropped upstream
      super._onDrop(ev);
  }

  async _onDropIntoContainer(ev) {
    let dragData = JSON.parse(ev.dataTransfer.getData("text/plain"));
    let dropID = $(ev.target).parents(".item").attr("data-id");

    let item = (await Item.implementation.fromDropData(dragData))?.toObject();

    item.system.location.value = dropID; // Change location value of item to the id of the container it is in

    //  this will unequip/remove items like armor and weapons when moved into a container
    if (item.type == "armour")
      item.system.worn.value = false;
    if (item.type == "weapon")
      item.system.equipped = false;
    if (item.type == "trapping" && item.system.trappingType.value == "clothingAccessories")
      item.system.worn = false;


    return this.actor.updateEmbeddedDocuments("Item", [item]);
  }

  // Dropping a character creation result
  _onDropCharGen(dragData) {
    let data = duplicate(this.actor._source);
    if (dragData.generationType == "attributes") // Characteristsics, movement, metacurrency, etc.
    {
      data.details.species.value = dragData.payload.species;
      data.details.species.subspecies = dragData.payload.subspecies;
      data.details.move.value = dragData.payload.movement;

      if (this.actor.type == "character") // Other actors don't care about these values
      {
        data.status.fate.value = dragData.payload.fate;
        data.status.fortune.value = dragData.payload.fate;
        data.status.resilience.value = dragData.payload.resilience;
        data.status.resolve.value = dragData.payload.resilience;
        data.details.experience.total += dragData.payload.exp;
        data.details.experience.log = this.actor._addToExpLog(dragData.payload.exp, "Character Creation", undefined, data.details.experience.total);
      }
      for (let c in game.wfrp4e.config.characteristics) {
        data.characteristics[c].initial = dragData.payload.characteristics[c].value;
      }
      return this.actor.update({ "data": data })
    }
    else if (dragData.generationType === "details") // hair, name, eyes
    {
      data.details.eyecolour.value = dragData.payload.eyes;
      data.details.haircolour.value = dragData.payload.hair;
      data.details.age.value = dragData.payload.age;
      data.details.height.value = dragData.payload.height;
      let name = dragData.payload.name;
      return this.actor.update({ "name": name, "data": data, "token.name": name.split(" ")[0] })
    }
  }

  // This is included in character creation, but not limited to.
  // lookupType is either skill or talent. Instead of looking up the
  // data on the drag ev (could cause a delay), look it up on drop
  async _onDropLookupItem(dragData) {
    let item;
    if (dragData.payload.lookupType === "skill") {
      // Advanced find  returns the skill the user expects it to return, even with skills not included in the compendium (Lore (whatever))
      item = await WFRP_Utility$1.findSkill(dragData.payload.name);
    }
    else if (dragData.payload.lookupType === "talent") {
      // Advanced find  returns the talent the user expects it to return, even with talents not included in the compendium (Etiquette (whatever))
      item = await WFRP_Utility$1.findTalent(dragData.payload.name);
    }
    else {
      item = await WFRP_Utility$1.findItem(dragData.payload.name, dragData.payload.lookupType);
    }
    if (item)
      this.actor.createEmbeddedDocuments("Item", [item.toObject()]);
  }

  // From character creation - exp drag values
  _onDropExperience(dragData) {
    let system = duplicate(this.actor._source);
    system.details.experience.total += dragData.payload;
    system.details.experience.log = this.actor._addToExpLog(dragData.payload, "Character Creation", undefined, system.details.experience.total);
    this.actor.update({ "system": system });
  }

  // From Income results - drag money value over to add
  _onDropMoney(dragData) {
    // Money string is in the format of <amt><type>, so 12b, 5g, 1.5g
    let moneyString = dragData.payload;
    let type = moneyString.slice(-1);
    let amt;
    // Failure means divide by two, so mark whether we should add half a gold or half a silver, just round pennies
    let halfS = false, halfG = false;
    if (type === "b")
      amt = Math.round(moneyString.slice(0, -1));
    else if (type === "s") {
      if (moneyString.slice(0, -1).includes("."))
        halfS = true;
      amt = Math.floor(moneyString.slice(0, -1));
    }
    else if (type === "g") {
      if (moneyString.slice(0, -1).includes("."))
        halfG = true;
      amt = Math.floor(moneyString.slice(0, -1));
    }
    let money = this.actor.getItemTypes("money").map(m => m.toObject());

    let moneyItem;
    switch (type) {
      case 'b':
        moneyItem = money.find(i => i.name === game.i18n.localize("NAME.BP"));
        break;
      case 's':
        moneyItem = money.find(i => i.name === game.i18n.localize("NAME.SS"));
        break;
      case 'g':
        moneyItem = money.find(i => i.name === game.i18n.localize("NAME.GC"));
        break;
    }

    // If 0, means they failed the roll by -6 or more, delete all money
    if (!amt && !halfG && !halfS)
      money.forEach(m => m.system.quantity.value = 0);
    else // Otherwise, add amount to designated type
      moneyItem.system.quantity.value += amt;

    // add halves
    if (halfS)
      money.find(i => i.name === game.i18n.localize("NAME.BP")).system.quantity.value += 6;
    if (halfG)
      money.find(i => i.name === game.i18n.localize("NAME.SS")).system.quantity.value += 10;

    this.actor.updateEmbeddedDocuments("Item", money);
  }

  _onConvertCurrencyClick(ev) {
    let type = ev.currentTarget.dataset.type;
    let money = this.actor.getItemTypes("money").map(m => m.toObject());

    if (type == "gc")
    {
      let currentGC = money.find(i => i.name == game.i18n.localize("NAME.GC"));
      let currentSS = money.find(i => i.name == game.i18n.localize("NAME.SS"));

      if (currentGC && currentSS && currentGC.system.quantity.value )
      {
        currentGC.system.quantity.value -= 1;
        currentSS.system.quantity.value += 20;
        return this.actor.updateEmbeddedDocuments("Item", [currentGC, currentSS])
      }
      else
        return ui.notifications.error(game.i18n.localize("ErrorMoneyConvert"))
    }
    
    if (type == "ss")
    {
      let currentSS = money.find(i => i.name == game.i18n.localize("NAME.SS"));
      let currentBP = money.find(i => i.name == game.i18n.localize("NAME.BP"));

      if (currentBP && currentSS  && currentSS.system.quantity.value)
      {
        currentSS.system.quantity.value -= 1;
        currentBP.system.quantity.value += 12;
        return this.actor.updateEmbeddedDocuments("Item", [currentBP, currentSS])
      }
      else
        return ui.notifications.error(game.i18n.localize("ErrorMoneyConvert"))
    }

  }

  //#endregion

  //#region DROPDOWNS
  /**
   * All item types have a drop down description, this handles what is 
   * displayed for each item type and adds additional lities
   * and listeners.
   * 
   * @private
   * 
   * @param {Object} ev    ev generated by the click 
   */
  async _onItemSummary(ev) {
    ev.preventDefault();
    let li = $(ev.currentTarget).parents(".item"),
      item = this.actor.items.get(li.attr("data-id"));
    // Call the item's expandData() which gives us what to display
    let expandData = await item.system.expandData(
      {
        secrets: this.actor.isOwner
      });

    // Toggle expansion for an item
    if (li.hasClass("expanded")) // If expansion already shown - remove
    {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    }
    else {
      // Add a div with the item summary belowe the item
      let div = "";
      div = $(`<div class="item-summary">${expandData.description.value}</div>`);

      let props = $(`<div class="item-properties"></div>`);
      expandData.properties.forEach(p => props.append(`<span class="tag">${p}</span>`));


      div.append(props);


      if (expandData.targetEffects.length) {
        let effectButtons = expandData.targetEffects.map(e => `<a class="apply-effect" data-id=${item.id} data-effect-id=${e.id}>${game.i18n.format("SHEET.ApplyEffect", { effect: e.name })}</a>`);
        let effects = $(`<div>${effectButtons}</div>`);
        div.append(effects);
      }
      if (expandData.invokeEffects.length) {
        let effectButtons = expandData.invokeEffects.map(e => `<a class="invoke-effect" data-id=${item.id} data-effect-id=${e.id}>${game.i18n.format("SHEET.InvokeEffect", { effect: e.name })}</a>`);
        let effects = $(`<div>${effectButtons}</div>`);
        div.append(effects);
      }


      li.append(div.hide());
      div.slideDown(200);

      this._dropdownListeners(div);
    }
    li.toggleClass("expanded");
  }


  async _toggleGroupAdvantageActions(ev) {
    let actions = $(ev.currentTarget).parents("form").find(".group-advantage-actions");

    if (actions.children().length == 0)
    {
      ev.currentTarget.children[0].classList.replace("fa-chevron-down", "fa-chevron-up");
      let html = ``;

      if (game.wfrp4e.config.groupAdvantageActions.length > 0)      
      {
        game.wfrp4e.config.groupAdvantageActions.forEach((action, i) => {
          html += `<div class="action">
          <a class="use-grp-adv" data-index="${i}">${action.name}</a>
          <p>${action.description}</p>
          <p class="cost"><strong>Cost</strong>: ${action.cost}</p>
          <p class="effect">${action.effect}</p>
          </div><hr>`;
        });
      }
      else 
      {
        html = "No Actions Available";
      }
      html = await TextEditor.enrichHTML(html, {async: true});
      let el = $(html).hide();
      actions.append(el);
      el.slideDown(200);
    }
    else 
    {
      actions.children().slideUp(200, () => actions.children().remove());
      
      ev.currentTarget.children[0].classList.replace("fa-chevron-up", "fa-chevron-down");
    }
  }



  async _onUseGrpAdvAction(ev) {
      let index = ev.currentTarget.dataset.index;

      let action = game.wfrp4e.config.groupAdvantageActions[index];

      if (action.cost > this.actor.status.advantage.value)
      {
        return ui.notifications.error("Not enough Advantage!")
      }

      if (action)
      {
        let html = await TextEditor.enrichHTML(`
        <p><strong>${action.name}</strong>: ${action.description}</p>
        <p>${action.effect}</p>
        `);

        this.actor.modifyAdvantage(-1 * action.cost);
        
        ChatMessage.create({
          content : html,
          speaker : {alias : this.actor.token?.name || this.actor.prototypeToken.name},
          flavor : "Group Advantage Action"
        });

        if (action.test)
        {
          if (action.test.type == "characteristic")
          {
            this.actor.setupCharacteristic(action.test.value).then(test => test.roll());
          }
        }
      }
  }


  _toggleSectionCollapse(ev)
  {
    let section = ev.currentTarget.dataset.section;
    let collapsed = this.actor.getFlag("wfrp4e", "sheetCollapsed")?.[section];

    this.actor.setFlag("wfrp4e", `sheetCollapsed.${section}`, !collapsed);
  }

  _toggleWeaponProperty(ev)
  {
    ev.stopPropagation();
    item = this.actor.items.get(this._getId(ev));
    let index = ev.currentTarget.dataset.index;
    let inactive = Object.values(item.properties.inactiveQualities);

    // Find clicked quality
    let toggled = inactive[index];

    // Find currently active
    let qualities = duplicate(item.system.qualities.value);

    // Disable all qualities of clicked group
    qualities.filter(i => i.group == toggled.group).forEach(i => i.active = false);

    // Enabled clicked quality
    qualities.find(i => i.name == toggled.key).active = true;

    item.update({"system.qualities.value" : qualities});
  }



  _dropdownListeners(html) {
    // Clickable tags
    // Post an Item Quality/Flaw
    html.on("click", ".item-property", ev => {
      WFRP_Utility$1.postProperty(ev.target.text);
    });

    // Roll a career income skill
    html.on("click", ".career-income", ev => {
      let skill = this.actor.getItemTypes("skill").find(i => i.name === ev.target.text.trim());
      let career = this.actor.items.get($(ev.target).attr("data-career-id"));
      if (!skill) {
        ui.notifications.error(game.i18n.localize("SHEET.SkillMissingWarning"));
        return;
      }
      if (!career.current.value) {
        ui.notifications.error(game.i18n.localize("SHEET.NonCurrentCareer"));
        return;
      }
      let options = {
        title: `${skill.name} - ${game.i18n.localize("Income")}`, 
        income: this.actor.details.status, 
        career: career.toObject()
      };
      this.actor.setupSkill(skill, options).then(setupData => {
        this.actor.basicTest(setupData);
      });
    });

    html.on("click", ".apply-effect", async ev => {

      let effectId = ev.target.dataset["effectId"];
      let itemId = ev.target.dataset["itemId"];

      let effect = this.actor.populateEffect(effectId, itemId);
      let item = this.actor.items.get(itemId);

      if (effect.flags.wfrp4e?.reduceQuantity && game.user.targets.size > 0) // Check targets as we don't want to decrease when we know it won't get applied
      {
        if (item.quantity.value > 0)
          await item.update({"system.quantity.value" : item.quantity.value - 1});
        else 
          throw ui.notifications.error(game.i18n.localize("EFFECT.QuantityError"))
      }

      if ((item.range && item.range.value.toLowerCase() == game.i18n.localize("You").toLowerCase()) && (item.target && item.target.value.toLowerCase() == game.i18n.localize("You").toLowerCase()))
        game.wfrp4e.utility.applyEffectToTarget(effect, [{ actor: this.actor }]); // Apply to caster (self) 
      else
        game.wfrp4e.utility.applyEffectToTarget(effect);
    });

    html.on("click", ".invoke-effect", async ev => {

      let effectId = ev.target.dataset["effectId"];
      let itemId = ev.target.dataset["itemId"];

      game.wfrp4e.utility.invokeEffect(this.actor, effectId, itemId);
    });
    // Respond to template button clicks
    html.on("mousedown", '.aoe-template', ev => {

      let actorId = ev.target.dataset["actorId"];
      let itemId = ev.target.dataset["itemId"];

      AOETemplate.fromString(ev.target.text, actorId, itemId, false).drawPreview(ev);
      this.minimize();
    });
  }

  /**
   * Summary for specific property selected - like a Quality description in the combat tab.
   * Works also for "Special" and "Special Ammo" properties - user entered values in the item
   * sheets.
   * 
   * 
   * @private
   * @param {Object} ev    ev triggered by clicking on a wweapon/armor property
   */
  async _expandProperty(ev) {
    ev.preventDefault();

    let li = $(ev.currentTarget).parents(".item"),
      property = ev.target.text, // Proprety clicked on
      properties = mergeObject(WFRP_Utility$1.qualityList(), WFRP_Utility$1.flawList()), // Property names
      propertyDescr = Object.assign(duplicate(game.wfrp4e.config.qualityDescriptions), game.wfrp4e.config.flawDescriptions); // Property descriptions
    
    let item = this.actor.items.get(li.attr("data-id")).toObject();

    // Add custom properties descriptions
    if (item)
    {
      let customProperties = item.system.qualities.value.concat(item.system.flaws.value).filter(i => i.custom);
      customProperties.forEach(p => {
        properties[p.key] = p.name;
        propertyDescr[p.key] = p.description;
      });
    }
    

    property = property.replace(/,/g, '').trim(); // Remove commas/whitespace

    let propertyKey = "";
    if (property == game.i18n.localize("Special Ammo")) // Special Ammo comes from user-entry in an Ammo's Special box
    {
      this.actor.items.get(li.attr("data-id")).toObject();
      let ammo = this.actor.items.get(item.system.currentAmmo.value).toObject();
      // Add the special value to the object so that it can be looked up
      propertyDescr = Object.assign(propertyDescr,
        {
          [game.i18n.localize("Special Ammo")]: ammo.system.special.value
        });
      propertyKey = game.i18n.localize("Special Ammo");
    }
    else if (property == "Special") // Special comes from user-entry in a Weapon's Special box
    {
      this.actor.items.get(li.attr("data-id"));
      // Add the special value to the object so that it can be looked up
      propertyDescr = Object.assign(propertyDescr,
        {
          "Special": item.system.special.value
        });
      propertyKey = "Special";
    }
    else // Otherwise, just lookup the key for the property and use that to lookup the description
    {
      propertyKey = WFRP_Utility$1.findKey(WFRP_Utility$1.parsePropertyName(property), properties);
    }

    let propertyDescription = "<b>" + property + "</b>" + ": " + propertyDescr[propertyKey];
    if (propertyDescription.includes("(Rating)"))
      propertyDescription = propertyDescription.replaceAll("(Rating)", property.split(" ")[1]);

    propertyDescription = await TextEditor.enrichHTML(propertyDescription, {async: true});

    // Toggle expansion 
    if (li.hasClass("expanded")) {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    }
    else {
      let div = $(`<div class="item-summary">${propertyDescription}</div>`);
      li.append(div.hide());
      div.slideDown(200);
    }
    li.toggleClass("expanded");
  }


  _onSortClick(ev)
  {
    let type = ev.currentTarget.dataset.type;

    type = type.includes(",") ? type.split(",") : [type];

    let items = type.reduce((prev, current) => prev.concat(this.actor.getItemTypes(current).map(i => i.toObject())), []);
    items = items.sort((a,b) => a.name < b.name ? -1 : 1);
    for(let i = 1; i < items.length; i++)
      items[i].sort = items[i-1].sort + 10000;

    return this.actor.updateEmbeddedDocuments("Item", items);
  }

  /**
   * Summary for specific property selected - like a Quality description in the combat tab.
   * Works also for "Special" and "Special Ammo" properties - user entered values in the item
   * sheets.
   * 
   * 
   * @private
   * @param {Object} ev    ev triggered by clicking on range, reach, etc.
   */
  _expandInfo(ev) {
    ev.preventDefault();
    let li = $(ev.currentTarget).parents(".item");
    let classes = $(ev.currentTarget);
    let expansionText = "";

    let item = this.actor.items.get(li.attr("data-id"));
    // Breakdown weapon range bands for easy reference (clickable, see below)
    if (classes.hasClass("weapon-range")) {
      if (!game.settings.get("wfrp4e", "mooRangeBands"))
      expansionText =
        `<a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Point Blank")}`].modifier}">${item.range.bands[`${game.i18n.localize("Point Blank")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Point Blank")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Point Blank"]]}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Short Range")}`].modifier}">${item.range.bands[`${game.i18n.localize("Short Range")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Short Range")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Short Range"]]}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Normal")}`].modifier}">${item.range.bands[`${game.i18n.localize("Normal")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Normal")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Normal"]]}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Long Range")}`].modifier}">${item.range.bands[`${game.i18n.localize("Long Range")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Long Range")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Long Range"]]}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Extreme")}`].modifier}">${item.range.bands[`${game.i18n.localize("Extreme")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Extreme")}`].range[1]} ${game.i18n.localize("yds")}: ${game.wfrp4e.config.difficultyLabels[game.wfrp4e.config.rangeModifiers["Extreme"]]}</a><br>
          `;

      //@HOUSE
      else {
        game.wfrp4e.utility.logHomebrew("mooRangeBands");
        expansionText =
        `<a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Point Blank")}`].modifier}">${item.range.bands[`${game.i18n.localize("Point Blank")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Point Blank")}`].range[1]} ${game.i18n.localize("yds")}: ${item.range.bands[`${game.i18n.localize("Point Blank")}`].modifier}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Short Range")}`].modifier}">${item.range.bands[`${game.i18n.localize("Short Range")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Short Range")}`].range[1]} ${game.i18n.localize("yds")}: ${item.range.bands[`${game.i18n.localize("Short Range")}`].modifier}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Normal")}`].modifier}">${item.range.bands[`${game.i18n.localize("Normal")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Normal")}`].range[1]} ${game.i18n.localize("yds")}: ${item.range.bands[`${game.i18n.localize("Normal")}`].modifier}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Long Range")}`].modifier}">${item.range.bands[`${game.i18n.localize("Long Range")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Long Range")}`].range[1]} ${game.i18n.localize("yds")}: ${item.range.bands[`${game.i18n.localize("Long Range")}`].modifier}</a><br>
          <a class="range-click" data-range="${item.range.bands[`${game.i18n.localize("Extreme")}`].modifier}">${item.range.bands[`${game.i18n.localize("Extreme")}`].range[0]} ${game.i18n.localize("yds")} - ${item.range.bands[`${game.i18n.localize("Extreme")}`].range[1]} ${game.i18n.localize("yds")}: ${item.range.bands[`${game.i18n.localize("Extreme")}`].modifier}</a><br>
          `;
      }
      //@/HOUSE

    }
    // Expand the weapon's group description
    else if (classes.hasClass("weapon-group")) {
      let weaponGroup = ev.target.text;
      let weaponGroupKey = "";
      weaponGroupKey = WFRP_Utility$1.findKey(weaponGroup, game.wfrp4e.config.weaponGroups);
      expansionText = game.wfrp4e.config.weaponGroupDescriptions[weaponGroupKey];
    }
    // Expand the weapon's reach description
    else if (classes.hasClass("weapon-reach")) {
      let reach = ev.target.text;
      let reachKey;
      reachKey = WFRP_Utility$1.findKey(reach, game.wfrp4e.config.weaponReaches);
      expansionText = game.wfrp4e.config.reachDescription[reachKey];
    }

    // Toggle expansion 
    if (li.hasClass("expanded")) {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    }
    else {
      let div = $(`<div class="item-summary">${expansionText}</div>`);
      li.append(div.hide());
      div.slideDown(200);

      // When a rangeband is clicked, start a test at that difficulty
      div.on("click", ".range-click", ev => {
        let modifier = parseInt($(ev.currentTarget).attr("data-range"));

        let weapon = item;
        if (weapon) {
          let options = {modify: { modifier } };
          this.actor.setupWeapon(weapon, options).then(setupData => {
            this.actor.weaponTest(setupData);
          });
        }
      });

    }
    li.toggleClass("expanded");
  }

  //#endregion

  /**
   * Duplicates an owned item given its id.
   * 
   * @param {Number} itemId   Item id of the item being duplicated
   */
  duplicateItem(itemId) {
    let item = this.actor.items.get(itemId).toObject();
    this.actor.createEmbeddedDocuments("Item", [item]);
  }

  async splitItem(itemId, amount) {
    let item = this.actor.items.get(itemId).toObject();
    let newItem = duplicate(item);
    if (amount >= item.system.quantity.value)
      return ui.notifications.notify(game.i18n.localize("Invalid Quantity"))

    newItem.system.quantity.value = amount;
    item.system.quantity.value -= amount;
    await this.actor.createEmbeddedDocuments("Item", [newItem]);
    this.actor.updateEmbeddedDocuments("Item", [item]);
  }


  toggleItemCheckbox(itemId, target) {
    let item = this.actor.items.get(itemId);
    return item.update({ [`${target}`]: !getProperty(item, target) })
  }
}

/**
 * Provides the specific interaction handlers for Character Sheets.
 *
 * ActorSheetWfrp4eCharacter are assigned to character type actors, and the specific interactions
 * character type actors need are defined here, specifically for careers and spending exp.
 * 
 */
class ActorSheetWfrp4eCharacter extends ActorSheetWfrp4e {
  static get defaultOptions() {
    const options = super.defaultOptions;
    mergeObject(options,
      {
        classes: options.classes.concat(["wfrp4e", "actor", "character-sheet"]),
        width: 610,
        height: 740,
      });
    return options;
  }


  /**
   * Get the correct HTML template path to use for rendering this particular sheet
   * @type {String}
   */
  get template() {
    if (!game.user.isGM && this.actor.limited) return "systems/wfrp4e/templates/actors/actor-limited.hbs";
    return "systems/wfrp4e/templates/actors/character/character-sheet.hbs";

  }

   /**
   * Provides the data to the template when rendering the actor sheet
   * 
   * This is called when rendering the sheet, where it calls the base actor class
   * to organize, process, and prepare all actor data for display. See ActorWfrp4e.prepare()
   * 
   * @returns {Object} sheetData    Data given to the template when rendering
   */
  async getData() {
    const sheetData = await super.getData();

    this.addCharacterData(sheetData);

    return sheetData;
  }

  addCharacterData(sheetData) {

    sheetData.career = {
      untrainedSkills: [],
      untrainedTalents: [],
      currentClass: "",
      currentCareer: "",
      currentCareerGroup: "",
      status: "",
      hasCurrentCareer: false
    };

    // For each career, find the current one, and set the details accordingly (top of the character sheet)
    // Additionally, set available characteristics, skills, and talents to advance (advancement indicator)
    for (let career of sheetData.actor.getItemTypes("career")) {
      if (career.current.value) {
        sheetData.career.hasCurrentCareer = true; // Used to remove indicators if no current career

        // Setup Character detail values
        sheetData.career.currentClass = career.class.value;
        sheetData.career.currentCareer = career.name;
        sheetData.career.currentCareerGroup = career.careergroup.value;

        if (!sheetData.actor.details.status.value) // backwards compatible with moving this to the career change handler
          sheetData.career.status = game.wfrp4e.config.statusTiers[career.status.tier] + " " + career.status.standing;

        // Setup advancement indicators for characteristics
        let availableCharacteristics = career.characteristics;
        for (let char in sheetData.system.characteristics) {
          if (availableCharacteristics.includes(char)) {
            sheetData.system.characteristics[char].career = true;
            if (sheetData.system.characteristics[char].advances >= career.level.value * 5) {
              sheetData.system.characteristics[char].complete = true;
            }
          }
        }

        // Find skills that have been trained or haven't, add advancement indicators or greyed out options (untrainedSkills)
        for (let sk of career.skills) {
          let trainedSkill = sheetData.actor.getItemTypes("skill").find(s => s.name.toLowerCase() == sk.toLowerCase());
          if (trainedSkill) 
            trainedSkill.system._addCareerData(career);
          else 
            sheetData.career.untrainedSkills.push(sk);
          
        }

        // Find talents that have been trained or haven't, add advancement button or greyed out options (untrainedTalents)
        for (let talent of career.talents) {
          let trainedTalent = sheetData.actor.getItemTypes("talent").find(t => t.name == talent);
          if (trainedTalent) 
            trainedTalent.system._addCareerData(career);
          else 
            sheetData.career.untrainedTalents.push(talent);
          
        }
      }
    }

    sheetData.system.details.experience.log.forEach((entry, i) => { entry.index = i; });
    sheetData.experienceLog = this._condenseXPLog(sheetData);

    sheetData.system.details.experience.canEdit = game.user.isGM || game.settings.get("wfrp4e", "playerExperienceEditing");
  }



  
  _condenseXPLog(sheetData) {
    let condensed= [];
    for (
      let logIndex = 0, lastPushed, lastPushedCounter = 0;
      logIndex < sheetData.system.details.experience.log.length;
      logIndex++) {
      let condense = false;
      if ( // If last pushed exists, and is the same, type, same reason, and both are positiev or both are negative
        lastPushed &&
        lastPushed.type == sheetData.system.details.experience.log[logIndex].type &&
        lastPushed.reason == sheetData.system.details.experience.log[logIndex].reason &&
        ((lastPushed.amount >= 0 && sheetData.system.details.experience.log[logIndex].amount >= 0)
          || (lastPushed.amount <= 0 && sheetData.system.details.experience.log[logIndex].amount <= 0))) { condense = true; }

      if (condense) {
        lastPushed[lastPushed.type] = sheetData.system.details.experience.log[logIndex][lastPushed.type];
        lastPushed.amount += sheetData.system.details.experience.log[logIndex].amount;
        lastPushed.index = sheetData.system.details.experience.log[logIndex].index;
        lastPushed.spent = sheetData.system.details.experience.log[logIndex].spent;
        lastPushed.total = sheetData.system.details.experience.log[logIndex].total;
        lastPushed.counter++;
      }
      else {
        lastPushed = duplicate(sheetData.system.details.experience.log[logIndex]);
        lastPushed.counter = 1;
        condensed.push(lastPushed);
        lastPushedCounter = 0;

      }
    }
    for (let log of condensed) {
      if (log.counter && log.counter > 1)
        log.reason += ` (${log.counter})`;
    }
    return condensed.reverse()
  }


  /* --------------------------------------------------------------------------------------------------------- */
  /* ------------------------------------ Event Listeners and Handlers --------------------------------------- */
  /* --------------------------------------------------------------------------------------------------------- */
  /**
   * This list of event handlers is focused on character interactions, such has spending exp and handling careers.
   * 
   *
  /* --------------------------------------------------------------------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    // Career toggle click (current or complete)
    html.find('.career-toggle').click(this._onToggleCareer.bind(this));
    html.find(".add-career").click(ev => {new game.wfrp4e.apps.CareerSelector(this.actor).render(true);});
    html.find(".untrained-skill").mousedown(this._onUntrainedSkillClick.bind(this));
    html.find(".untrained-talent").mousedown(this._onUntrainedTalentClick.bind(this));
    html.find('.advancement-indicator').mousedown(this._onAdvancementClick.bind(this));
    html.find('.exp-delete').click(this._onExpLogDelete.bind(this));
    html.find("#input-status").mousedown(this._onStatusClick.bind(this));

  }

  async _onToggleCareer(ev) {
    let itemId = this._getId(ev);
    let type = $(ev.currentTarget).attr("toggle-type");
    let item = this.actor.items.get(itemId);

    // Only one career can be current - make all careers not current before changing selected one
    if (type == "current" && item.current.value == false) { 
      let updateCareers = this.actor.getItemTypes("career").map(i => i.toObject());
      updateCareers.map(x => x.system.current.value = false);
      await this.actor.updateEmbeddedDocuments("Item", updateCareers);
    }
    return item.update({[`system.${type}.value`] : !item[type].value})
  }

    // Grayed-out skill click - prompt to add the skill
  async _onUntrainedSkillClick(ev) {
    let skill = await WFRP_Utility$1.findSkill(event.target.text);

    // Right click - show sheet
    if (ev.button == 2) {
      skill.sheet.render(true);
    }
    else {
      try {
        new Dialog(
          {
            title: game.i18n.localize("SHEET.AddSkillTitle"),
            content: `<p>${game.i18n.localize("SHEET.AddSkillPrompt")}</p>`,
            buttons:
            {
              yes:
              {
                label: game.i18n.localize("Yes"),
                callback: dlg => {
                  this.actor.createEmbeddedDocuments("Item", [skill.toObject()]);
                }
              },
              cancel:
              {
                label: game.i18n.localize("Cancel"),
                callback: dlg => {
                  return
                }
              },
            },
            default: 'yes'
          }).render(true);
      }
      catch
      {
        console.error(error);
        ui.notifications.error(error);
      }
    }
  }

    // Grayed-out talent click - prompt to add the talent
  async _onUntrainedTalentClick(ev) {
    let talent = await WFRP_Utility$1.findTalent(event.target.text);

    // Right click - show sheet
    if (ev.button == 2) {
      talent.sheet.render(true);
    }

    else {
      try {
        new Dialog(
          {
            title: game.i18n.localize("SHEET.AddTalentTitle"),
            content: `<p>${game.i18n.localize("SHEET.AddTalentPrompt")}</p>`,
            buttons:
            {
              yes:
              {
                label: game.i18n.localize("Yes"),
                callback: dlg => {
                  try {
                    WFRP_Utility$1.checkValidAdvancement(this.actor.details.experience.total, this.actor.details.experience.spent + 100, game.i18n.localize("ACTOR.ErrorAdd"), talent.name);
                    this.actor.createEmbeddedDocuments("Item", [talent.toObject()]);
                    let expLog = duplicate(this.actor.details.experience.log || []); 
                    expLog.push({amount : 100, reason : talent.name, spent : this.actor.details.experience.spent + 100, total : this.actor.details.experience.total, type : "spent"});
                    ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : 100, reason : talent.name}));
                    this.actor.update( // Subtract experience if added
                      {
                        "system.details.experience.spent": this.actor.details.experience.spent + 100,
                        "system.details.experience.log": expLog
                      });
                  } catch(error) {
                    ui.notifications.error(error);
                  }
                }
              },
              yesNoExp:
              {
                label: game.i18n.localize("Free"),
                callback: dlg => { this.actor.createEmbeddedDocuments("Item", [talent.toObject()]); }
              },
              cancel:
              {
                label: game.i18n.localize("Cancel"),
                callback: dlg => { return }
              },
            },
            default: 'yes'
          }).render(true);
      }
      catch
      {
        console.error(error);
        ui.notifications(error);
      }
    }
  }

   // Advancement indicators appear next to characteristic, skills, and talents available to spend exp on
    // Left click spends exp - right click reverses
  async _onAdvancementClick(ev) {
    let data = this.actor.toObject().system;
    let type = $(ev.target).attr("data-target");

    // Skills
    if (type == "skill") {
      let itemId = this._getId(ev);
      let item = this.actor.items.get(itemId);

      if (ev.button == 0) {
        // Calculate the advancement cost based on the current number of advances, subtract that amount, advance by 1
        let cost = WFRP_Utility$1._calculateAdvCost(item.advances.value, type, item.advances.costModifier);
        try {
          WFRP_Utility$1.checkValidAdvancement(data.details.experience.total, data.details.experience.spent + cost, game.i18n.localize("ACTOR.ErrorImprove"), item.name);
          data.details.experience.spent = Number(data.details.experience.spent) + cost;
          await item.update({"system.advances.value" : item.advances.value + 1});

          let expLog = this.actor._addToExpLog(cost, item.name, data.details.experience.spent);
          ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : cost, reason: item.name}));
          await this.actor.update({ "system.details.experience.spent": data.details.experience.spent, "system.details.experience.log" : expLog });
        } catch(error) {
          ui.notifications.error(error);
        }
      }
      else if (ev.button = 2) {
        // Do the reverse, calculate the advancement cost (after subtracting 1 advancement), add that exp back
        if (item.advances.value == 0)
          return;
        let cost = WFRP_Utility$1._calculateAdvCost(item.advances.value - 1, type, item.advances.costModifier);
        data.details.experience.spent = Number(data.details.experience.spent) - cost;
        await item.update({"system.advances.value" : item.advances.value - 1});

        let expLog = this.actor._addToExpLog(-1 * cost, item.name, data.details.experience.spent);
        ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : -1 * cost, reason : item.name}));
        await this.actor.update({ "system.details.experience.spent": data.details.experience.spent, "system.details.experience.log" : expLog });
      }
    }
    // Talents
    else if (type == "talent") {
      if (ev.button == 0) {
        // All career talents are stored in flags, retrieve the one clicked - use to calculate exp
        let itemId = this._getId(ev);
        let item = this.actor.items.get(itemId);
        let advances = item.Advances;
        let spent = 0;
        let cost = (advances + 1) * 100;
        try {
          WFRP_Utility$1.checkValidAdvancement(this.actor.details.experience.total, this.actor.details.experience.spent + cost, game.i18n.localize("ACTOR.ErrorImprove"), item.name);
          if (advances < item.Max || item.Max == "-") {
            spent = this.actor.details.experience.spent + cost;
          }
          else
            return
          await this.actor.createEmbeddedDocuments("Item", [item.toObject()]);
          
          ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : cost, reason : item.name}));
          let expLog = this.actor._addToExpLog(cost, item.name, spent);
          await this.actor.update({"system.details.experience.spent": spent, "system.details.experience.log" : expLog});
        }  catch(error) {
          ui.notifications.error(error);
        }
      }
      // If right click, ask to refund EXP or not
      else if (ev.button == 2) {
        let itemId = this._getId(ev);
        let item = this.actor.items.get(itemId);
        let advances = item.Advances;
        let spent = 0;
        let cost = (advances) * 100;
        spent = this.actor.details.experience.spent - cost;

        new Dialog(
          {
            title: game.i18n.localize("SHEET.RefundXPTitle"),
            content: `<p>${game.i18n.localize("SHEET.RefundXPPrompt")} (${(advances) * 100})</p>`,
            buttons:
            {
              yes:
              {
                label: game.i18n.localize("Yes"),
                callback: dlg => {
                  this.actor.deleteEmbeddedDocuments("Item", [itemId]);
                  let expLog = this.actor._addToExpLog(-1 * cost, item.name, spent);
                  ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : -1 * cost, reason : item.name}));
                  this.actor.update({"system.details.experience.spent": spent, "system.details.experience.log" : expLog});
                }
              },
              no:
              {
                label: game.i18n.localize("No"),
                callback: dlg => {
                  this.actor.deleteEmbeddedDocuments("Item", [itemId]);
                },
              },
              cancel:
              {
                label: game.i18n.localize("Cancel"),
                callback: dlg => { return }
              }
            },
            default: 'yes'
          }).render(true);
        // Reverse the cost, add to exp, and remove the talent

      }

    }
    // Characteristics
    else {
      let characteristic = type;
      let currentChar = this.actor.characteristics[characteristic];

      if (ev.button == 0) {
        // Calculate the advancement cost based on the current number of advances, subtract that amount, advance by 1
        let cost = WFRP_Utility$1._calculateAdvCost(currentChar.advances, "characteristic");
        try {
          WFRP_Utility$1.checkValidAdvancement(data.details.experience.total, data.details.experience.spent + cost, game.i18n.localize("ACTOR.ErrorImprove"), game.wfrp4e.config.characteristics[characteristic]);
          data.characteristics[characteristic].advances++;
          data.details.experience.spent = Number(data.details.experience.spent) + cost;

          let expLog = this.actor._addToExpLog(cost, game.wfrp4e.config.characteristics[characteristic], data.details.experience.spent);
          ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : cost, reason : game.wfrp4e.config.characteristics[characteristic]}));
          data.details.experience.log = expLog;

          await this.actor.update({"system.characteristics": data.characteristics,"system.details.experience": data.details.experience});
        } catch(error) {
          ui.notifications.error(error);
        }
      }
      else if (ev.button == 2) {
        // Calculate the advancement cost based on advances -1, add that amount back into exp
        if (currentChar.advances == 0)
          return
        let cost = WFRP_Utility$1._calculateAdvCost(currentChar.advances - 1, "characteristic");

        data.characteristics[characteristic].advances--;
        data.details.experience.spent = Number(data.details.experience.spent) - cost;

        let expLog = this.actor._addToExpLog(-1 * cost, game.wfrp4e.config.characteristics[characteristic], data.details.experience.spent);
        ui.notifications.notify(game.i18n.format("ACTOR.SpentExp", {amount : -1 * cost, reason : game.wfrp4e.config.characteristics[characteristic]}));
        data.details.experience.log = expLog;


        await this.actor.update({"system.characteristics": data.characteristics, "system.details.experience": data.details.experience});
      }
    }
  }

  _onExpLogDelete(ev) {
    let index = parseInt($(ev.currentTarget).parents(".exp-entry").attr("data-index"));
    let experience = duplicate(this.actor.details.experience);
    let entry = experience.log[index];
    let exp = parseInt(entry.amount);
    let type = entry.type;
    experience.log.splice(index, 1);

    new Dialog({
      title: game.i18n.localize("RevertExperience"),
      content : `<p>${game.i18n.localize("DIALOG.RevertExperience")}</p>`,
      buttons : {
        yes : {
          label : game.i18n.localize("Yes"),
          callback : dlg => {
            experience[type] -= exp;
            this.actor.update({"system.details.experience" : experience});
          }
        },
        no : {
          label : game.i18n.localize("No"),
          callback : dlg => {this.actor.update({"system.details.experience" : experience});}
        }
      }
    }).render(true);
  }

  _onStatusClick(ev) {
    let modifier = ev.button == 0 ? 1 : -1; // Increment if left click, decrement if right click
    this.actor.update({"system.details.status.modifier" : (this.actor.details.status.modifier || 0) + modifier});
  }

}

/**
 * Provides the specific interaction handlers for NPC Sheets.
 *
 * ActorSheetWfrp4eNPC is assigned to NPC type actors, and the specific interactions
 * npc type actors need are defined here, specifically for careers. NPCs have the unique
 * functionality with careers where clicking "complete" automatically advances characteristics,
 * skills, and talents from that career.
 * 
 */
class ActorSheetWfrp4eNPC extends ActorSheetWfrp4e {
  static get defaultOptions() {
    const options = super.defaultOptions;
    mergeObject(options,
      {
        classes: options.classes.concat(["wfrp4e", "actor", "npc-sheet"]),
        width: 610,
        height: 740,
      });
    return options;
  }

  /**
   * Get the correct HTML template path to use for rendering this particular sheet
   * @type {String}
   */
  get template() {
    if (!game.user.isGM && this.actor.limited) return "systems/wfrp4e/templates/actors/actor-limited.hbs";
    return "systems/wfrp4e/templates/actors/npc/npc-sheet.hbs";
  }

  /* -------------------------------------------- */
  /*  Event Listeners and Handlers
  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    // Do not proceed if sheet is not editable
    if (!this.options.editable) return;

    // Roll a characteristic test by clicking on the characteristic name
    html.find('.ch-roll').click(this._onCharClick.bind(this));

    html.find(".npc-income").click(this._onNpcIncomeClick.bind(this));

    // Advance NPC if a career is marked as "complete"
    html.find('.npc-career').click(this._onNpcCareerClick.bind(this));

  }

  //TODO Review with status changes
  async _onNpcIncomeClick(event) {
    let status = this.actor.details.status.value.split(" ");
    let dieAmount = game.wfrp4e.config.earningValues[WFRP_Utility$1.findKey(status[0], game.wfrp4e.config.statusTiers)][0]; // b, s, or g maps to 2d10, 1d10, or 1 respectively (takes the first letter)
    dieAmount = Number(dieAmount) * status[1];     // Multilpy that first letter by your standing (Brass 4 = 8d10 pennies)
    let moneyEarned;
    if (WFRP_Utility$1.findKey(status[0], game.wfrp4e.config.statusTiers) != "g") // Don't roll for gold, just use standing value
    {
      dieAmount = dieAmount + "d10";
      moneyEarned = (await new Roll(dieAmount).roll()).total;
    }
    else
      moneyEarned = dieAmount;

    let paystring;
    switch (WFRP_Utility$1.findKey(status[0], game.wfrp4e.config.statusTiers)) {
      case "b":
        paystring = `${moneyEarned}${game.i18n.localize("MARKET.Abbrev.BP").toLowerCase()}.`;
        break;
      case "s":
        paystring = `${moneyEarned}${game.i18n.localize("MARKET.Abbrev.SS").toLowerCase()}.`;
        break;
      case "g":
        paystring = `${moneyEarned}${game.i18n.localize("MARKET.Abbrev.GC").toLowerCase()}.`;
        break;
    }
    let money = MarketWfrp4e.creditCommand(paystring, this.actor, { suppressMessage: true });
    WFRP_Audio.PlayContextAudio({ item: { type: "money" }, action: "gain" });
    this.actor.updateEmbeddedDocuments("Item", money);
  }

  async _onNpcCareerClick(event) {
    event.preventDefault();
    let id = $(event.currentTarget).parents(".item").attr("data-id");
    let careerItem = this.actor.items.get(id);
    await careerItem.update({"system.complete.value" : !careerItem.complete.value});

    if (careerItem.complete.value) {

      new Dialog({
        content: game.i18n.localize("CAREERAdvHint"),
        title: game.i18n.localize("CAREERAdv"),
        buttons: {
          yes: {
            label: game.i18n.localize("Yes"),
            callback: async () => {

              await this.actor.advanceNPC(careerItem);
              await this.actor.update({ "system.details.status.value": game.wfrp4e.config.statusTiers[careerItem.status.tier] + " " + careerItem.status.standing });
            }
          },
          no: {
            label: game.i18n.localize("No"),
            callback: () => { }
          }
        }
      }).render(true);
    }
  }
}

/**
 * Provides the specific interaction handlers for Creature Sheets.
 *
 * ActorSheetWfrp4eCreature is assigned to Creature type actors, which have a very 
 * different layout in their sheet compared to the others, requiring different 
 * functionality in the main tab (creature overview), as well as the notes tab, 
 * where the user excludes traits.
 * 
 */
class ActorSheetWfrp4eCreature extends ActorSheetWfrp4e {


  // V10 - Dialogs need focus for default button to work with the Enter key. Hovering over traits in the overview focuses on them (required for delete key to work)
  // This variable prevents focusing on these if a dialog is open, so that Enter will work with dialogs
  dialogOpen = false 

  static get defaultOptions() {
    const options = super.defaultOptions;
    mergeObject(options,
      {
        classes: options.classes.concat(["wfrp4e", "actor", "creature-sheet"]),
        width: 610,
        height: 740,
      });
    return options;
  }


  /**
   * Get the correct HTML template path to use for rendering this particular sheet
   * @type {String}
   */
  get template() {
    if (!game.user.isGM && this.actor.limited) return "systems/wfrp4e/templates/actors/actor-limited.hbs";
    return "systems/wfrp4e/templates/actors/creature/creature-sheet.hbs";
  }


  async getData() {
    const sheetData = await super.getData();

    this.addCreatureData(sheetData);

    return sheetData;
  }

  addCreatureData(sheetData) {
    sheetData.items.skills.trained = sheetData.actor.getItemTypes("skill").filter(i => i.advances.value > 0).sort((a, b) => a.name > b.name ? 1 : -1);
    sheetData.items.includedTraits = sheetData.items.traits.filter(i => i.included).sort((a, b) => a.name > b.name ? 1 : -1);
  }



  /**
   * Prevents a dropdown event from immediately firing - allows for double clicking items
   * in the creature overview to open the sheet.
   * 
   * @param {Object} event    event fired by clicking on a dropdown element 
   */
  _delayedDropdown(event) {

    // count clicks
    if (this.clicks)
      this.clicks++;
    else
      this.clicks = 1;

    // If first click, set a timeout value, and if it expires, reset clicks and show dropdown
    if (this.clicks === 1) {
      this.timer = setTimeout(() => {
        this._onCreatureItemSummary(event);
        this.clicks = 0; //after action performed, reset counter
      }, 250);
    } // If the timeout does not expire before another click, open the item sheet
    else {
      clearTimeout(this.timer); //prevent single-click action
      let itemId = $(event.currentTarget).attr("data-id");
      const item = this.actor.items.get(itemId);
      item.sheet.render(true);
      this.clicks = 0; //after action performed, reset counter
    }
  }

  /**
   * Handles when the user clicks on a trait in the creature overview - shows the item summary
   * as dropdown info
   * 
   * @param {Object} event    event fired from clicking on an item
   */
  async _onCreatureItemSummary(event) {
    event.preventDefault();
    let li = $(event.currentTarget).parent('.list'),
      item = this.actor.items.get($(event.currentTarget).attr("data-id")),
      // Get expansion info to place in the dropdown
      expandData = await item.getExpandData(
        {
          secrets: this.actor.isOwner
        });


    // If already has expanded class, remove it
    if (li.hasClass("expanded")) {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    }
    else {
      let div = "";
      div = $(`<div class="item-summary"><b>${item.name}:</b>${expandData.description.value}</div>`);

      let props = $(`<div class="item-properties"></div>`);
      expandData.properties.forEach(p => props.append(`<span class="tag">${p}</span>`));
      div.append(props);
      if (expandData.targetEffects.length) {
        let effectButtons = expandData.targetEffects.map(e => `<a class="apply-effect" data-id=${item.id} data-effect-id=${e.id}>${game.i18n.format("SHEET.ApplyEffect", { effect: e.name })}</a>`);
        let effects = $(`<div>${effectButtons}</div>`);
        div.append(effects);
      }
      if (expandData.invokeEffects.length) {
        let effectButtons = expandData.invokeEffects.map(e => `<a class="invoke-effect" data-id=${item.id} data-effect-id=${e.id}>${game.i18n.format("SHEET.InvokeEffect", { effect: e.name })}</a>`);
        let effects = $(`<div>${effectButtons}</div>`);
        div.append(effects);
      }
      li.append(div.hide());
      div.slideDown(200);

      this._dropdownListeners(div);

    }
    li.toggleClass("expanded");
  }


  /* -------------------------------------------- */
  /*  Event Listeners and Handlers
  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    // // div elementns need focus for the DEL key to work on them
      html.find(".content").hover(event => {
        if (!this.dialogOpen)
          $(event.currentTarget).focus();
      });

    // Can use the delete key in the creature overview to delete items
    html.find('.content').keydown(this._onContentClick.bind(this));

    // // Use delayed dropdown to allow for double clicks
    html.find(".creature-dropdown").mousedown(event => {
      this._delayedDropdown(event);
    })
      .on("dblclick", function (e) {
        e.preventDefault(); //cancel system double-click event
      });

    if (!this.options.editable) return;

    // Allow for holding shift or crtl on a skill when clicking on the main tab to advance it by 10 or 1
    html.find(".skills.name, .skills.total").mousedown(this._onCreatureSkillClick.bind(this));

    // Show a dropdown for the trait, or prompt to roll for it, depending on context
    // Right click will always display dropdown, left click will sometimes display (if the trait isn't rollable)
    html.find(".traits.content").mousedown(this._onTraitClick.bind(this));

    // Click on characteristic header to roll characteristic
    html.find('.ch-roll').click(this._onCharClick.bind(this));

    // Handler for traits in the notes tab - excluding or not excluding them
    html.find('.trait-include').mousedown(this._onTraitNameClick.bind(this));

  }

   _onContentClick(ev) {
     if (ev.keyCode == 46) {
      ev.preventDefault();
      ev.stopPropagation();
      let itemId = $(ev.currentTarget).attr("data-id");
      if (itemId)
        return this.actor.deleteEmbeddedDocuments("Item", [itemId]);
    }
  }

  _onCreatureSkillClick(event) {
    let newAdv;
    let advAmt;
    let skill = this.actor.items.get($(event.currentTarget).parents(".content").attr("data-id"));

    if (event.shiftKey || event.ctrlKey) {
      if (event.shiftKey)
        advAmt = 10;
      else if (event.ctrlKey)
        advAmt = 1;
    }

    // Add if left click
    if (event.button == 0) {
      if (advAmt) {
        skill.update({"system.advances.value" : newAdv});
      }
      else // If neither control or shift was held, roll the skill instead
        this.actor.setupSkill(skill).then(setupData => {
          this.actor.basicTest(setupData);
        });    }
    // Subtract if right click
    else if (event.button == 2) {
      if (advAmt) {
        newAdv = skill.system.advances.value - advAmt;
        if (newAdv < 0)
          newAdv = 0;
        skill.update({"system.advances.value" : newAdv});

      }
      else // If neither control or shift was held, show the item sheet
      {
        skill.sheet.render(true);
      }
    }
  }

  _onTraitClick(event) {
    event.preventDefault();
    this.dialogOpen = true;
    let trait = this.actor.items.get($(event.currentTarget).attr("data-id"));

    // If rightclick or not rollable, show dropdown
    if (event.button == 2 || !trait.rollable.value) {
      this._delayedDropdown(event);
      return;
    }

    // Otherwise, prompt to roll
    this.actor.setupTrait(trait).then(testData => {
      this.actor.traitTest(testData);
    }).finally(() => {
      this.dialogOpen = false; 
    });
  }

  _onTraitNameClick(event) {
    // Creatures have an excludedTraits array that holds the ids of the excluded traits
    // Update that array when a new trait is clicked
    event.preventDefault();
    let traitId = $(event.currentTarget).parents(".item").attr("data-id");

    if (event.button == 0) {
      let newExcludedTraits = duplicate(this.actor.excludedTraits);

      // If excludedTraits includes the clicked trait - it is excluded, so include it
      if (this.actor.excludedTraits.includes(traitId)) {
        newExcludedTraits = newExcludedTraits.filter(i => i != traitId);
      }
      // If excludedTraits does not include clicked trait, it is included, so exclude it
      else {
        newExcludedTraits.push(traitId);
      }

      return this.actor.update({"system.excludedTraits": newExcludedTraits});

    }
    // If right click, show description
    else if (event.button == 2) {
      this._onItemSummary(event);
    }
  }
}

/**
 * Provides the specific interaction handlers for Vehicle Sheets.
 * 
 */
class ActorSheetWfrp4eVehicle extends ActorSheetWfrp4e {
  static get defaultOptions() {
    const options = super.defaultOptions;
    mergeObject(options,
      {
        classes: options.classes.concat(["wfrp4e", "actor", "vehicle-sheet"]),
        width: 610,
        height: 740,
        dragDrop: [{ dragSelector: ".item-list .item", dropSelector: null }, { dragSelector: ".actor-list .actor", dropSelector: null }]
      });
    return options;
  }

  async _onDrop(event) {
    let dragData = JSON.parse(event.dataTransfer.getData("text/plain"));
    
    if (dragData?.type == "Actor")
    {
      let actor = await fromUuid(dragData.uuid);
      let passengers = duplicate(this.actor.system.passengers);
      passengers.push({ id: actor.id, count: 1 });
      this.actor.update({ "system.passengers": passengers });
    }
    else return super._onDrop(event);
  }

    /**
   * Get the correct HTML template path to use for rendering this particular sheet
   * @type {String}
   */
  get template() {
    if (!game.user.isGM && this.actor.limited) return "systems/wfrp4e/templates/actors/actor-limited.hbs";
    return "systems/wfrp4e/templates/actors/vehicle/vehicle-sheet.hbs";
  }
  


  async getData() {
    let sheetData = await super.getData();
    sheetData.system.roles.forEach(r => {
      if (r.actor) {
        r.img = game.actors.get(r.actor)?.prototypeToken.texture.src;
      }
    });

    return sheetData;
  }

  async _handleEnrichment()
  {
      let enrichment = {};
      enrichment["system.details.description.value"] = await TextEditor.enrichHTML(this.actor.system.details.description.value, {async: true});
      enrichment["system.details.gmnotes.value"] = await TextEditor.enrichHTML(this.actor.system.details.gmdescription.value, {async: true});

      return expandObject(enrichment)
  }


  _addEncumbranceData(sheetData)
  {
    sheetData.system.status.encumbrance.max = sheetData.system.status.carries.max;
    sheetData.system.status.encumbrance.pct = sheetData.system.status.encumbrance.over / sheetData.system.status.encumbrance.max * 100;
    sheetData.system.status.encumbrance.carryPct = sheetData.system.status.encumbrance.current / sheetData.system.status.carries.max * 100;
    if (sheetData.system.status.encumbrance.pct + sheetData.system.status.encumbrance.carryPct > 100) {
      sheetData.system.status.encumbrance.penalty = Math.floor(((sheetData.system.status.encumbrance.carryPct + sheetData.system.status.encumbrance.pct) - 100) / 10);
      sheetData.system.status.encumbrance.message = `Handling Tests suffer a -${sheetData.system.status.encumbrance.penalty} SL penalty.`;
      sheetData.system.status.encumbrance.overEncumbered = true;
    }
    else {
      sheetData.system.status.encumbrance.message = `Encumbrance below maximum: No Penalties`;
      if (sheetData.system.status.encumbrance.pct + sheetData.system.status.encumbrance.carryPct == 100 && sheetData.system.status.encumbrance.carryPct)
        sheetData.system.status.encumbrance.carryPct -= 1;
    }
    sheetData.system.status.encumbrance.total = sheetData.system.status.encumbrance.current + sheetData.system.status.encumbrance.over;
    sheetData.system.status.encumbrance.modMsg = game.i18n.format("VEHICLE.ModEncumbranceTT", { amt: sheetData.system.status.encumbrance.over }),
    sheetData.system.status.encumbrance.carryMsg = game.i18n.format("VEHICLE.CarryEncumbranceTT", { amt: Math.round(sheetData.system.status.encumbrance.current * 10) / 10 });
  }

  async passengerSelect(dialogMessage = game.i18n.localize("DIALOG.ActorSelection")) {
    return new Promise((resolve, reject) => {
      renderTemplate("systems/wfrp4e/templates/dialog/vehicle-weapon.hbs", { dialogMessage, actors: this.actor.passengers.map(p => p.actor) }).then(dlg => {
        new Dialog({
          content: dlg,
          title: game.i18n.localize("DIALOG.ActorSelection"),
          buttons: {
            select: {
              label: game.i18n.localize("Select"),
              callback: (dlg) => {
                let actorId = dlg.find("[name='actor']").val();
                if (actorId)
                  resolve(game.actors.get(actorId));
                reject();
              }
            }
          }
        }).render(true);
      });
    })
  }


  /* -------------------------------------------- */
  /*  Event Listeners and Handlers
  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    html.find(".passenger .name").click(this._onPassengerClick.bind(this));
    html.find(".role-skill").click(this._onRoleSkillClick.bind(this));
    html.find(".role-name").click(this._onRoleNameClick.bind(this));
    html.find('.vehicle-weapon-name').click(this._onVehicleWeaponClick.bind(this));

    // Do not proceed if sheet is not editable
    if (!this.options.editable) return;

    html.find(".passenger-qty-click").mousedown(this._onPassengerQtyClick.bind(this));
    html.find(".passenger-delete-click").click(this._onPassengerDeleteClick.bind(this));
    html.find(".role-edit").mousedown(this._onRoleEditClick.bind(this));
    html.find(".role-actor").change(this._onRoleActorChange.bind(this));
    html.find(".role-input").change(this._onRoleInputChange.bind(this));
    html.find(".role-delete").click(this._onRoleDelete.bind(this));
    html.find(".cargo .inventory-list .name").mousedown(this._onCargoClick.bind(this));

  }


  _onPassengerClick(ev) {
    ev.stopPropagation();
    let index = Number($(ev.currentTarget).parents(".item").attr("data-index"));
    game.actors.get(this.actor.passengers[index].actor.id).sheet.render(true);
  }

  async _onRoleSkillClick(ev) {
    let index = Number($(ev.currentTarget).parents(".item").attr("data-index"));
    let roles = duplicate(this.actor.roles);
    if (ev.button == 0) {
      let { actor, test, testLabel, handling } = roles[index];
      actor = game.actors.get(actor);
      if (!actor)
        return ui.notifications.error(game.i18n.localize("VEHICLE.NoActor"))
      if (!actor.isOwner)
        return ui.notifications.error(game.i18n.localize("VEHICLE.TestNotPermitted"))

      let skill = actor.getItemTypes("skill").find(s => s.name == test);
      let setupData;
      let title;

      if (!skill) {
        let char = game.wfrp4e.utility.findKey(test, game.wfrp4e.config.characteristics);
        if (!char)
          return ui.notifications.error(game.i18n.localize("VEHICLE.TestNotFound"))

        if (testLabel)
          title = testLabel + " - " + test;

        let prefill = this.actor.getPrefillData("characteristic", char, { vehicle: this.actor.id, handling });
        let penalty = this.actor.status.encumbrance.penalty || 0;
        if (handling)
          prefill.slBonus -= penalty;
        let modify = { modifier: prefill.testModifier, slBonus: prefill.slBonus, successBonus: prefill.successBonus };
        setupData = await actor.setupCharacteristic(char, { title, vehicle: this.actor.id, handling, modify });
      }
      else {
        if (testLabel)
          title = testLabel + " - " + test;

        let prefill = this.actor.getPrefillData("skill", skill, { vehicle: this.actor.id, handling });
        let penalty = this.actor.status.encumbrance.penalty || 0;
        if (handling)
          prefill.slBonus -= penalty;
        let modify = { modifier: prefill.testModifier, slBonus: prefill.slBonus, successBonus: prefill.successBonus };
        setupData = await actor.setupSkill(skill, { title, vehicle: this.actor.id, handling, modify });
      }
      actor.basicTest(setupData);
    }
  }

  _onRoleNameClick(ev) {
    let index = Number($(ev.currentTarget).parents(".item").attr("data-index"));
    let roles = duplicate(this.actor.roles);

    let actor = game.actors.get(roles[index].actor);
    if (!actor)
      return ui.notifications.error(game.i18n.localize("VEHICLE.NoActor"))
    else
      actor.sheet.render(true);
  }

  async _onVehicleWeaponClick(ev) {
    event.preventDefault();
    let itemId = $(event.currentTarget).parents(".item").attr("data-id");
    let weapon = this.actor.items.get(itemId);

    let vehicleSpeaker;
    if (this.actor.isToken)
    vehicleSpeaker = {
      token: this.actor.token.id,
      scene: this.actor.token.parent.id
    };
  else
    vehicleSpeaker = {
      actor: this.actor.id
    };


    if (!game.user.isGM && game.user.character) {
      if (this.actor.passengers.find(p => p.actor._id == game.user.character.id)) {
        game.user.character.setupWeapon(weapon, { vehicle: vehicleSpeaker, ammo: this.actor.getItemTypes("ammunition") }).then(setupData => {
          game.user.character.weaponTest(setupData);
        });
      }
    }
    else {
      let actor = await this.passengerSelect(game.i18n.localize("DIALOG.VehicleActorSelect"));
      if (!actor.isOwner)
        return ui.notifications.error(game.i18n.localize("VEHICLE.CantUseActor"))

      actor.setupWeapon(weapon, { vehicle: vehicleSpeaker, ammo: this.actor.getItemTypes("ammunition") }).then(setupData => {
        actor.weaponTest(setupData);
      });
    }
  }

  _onPassengerQtyClick(ev) {
    let multiplier = ev.button == 0 ? 1 : -1;
    multiplier = ev.ctrlKey ? multiplier * 10 : multiplier;

    let index = Number($(ev.currentTarget).parents(".item").attr("data-index"));
    let passengers = duplicate(this.actor.system.passengers);
    passengers[index].count += 1 * multiplier;
    passengers[index].count = passengers[index].count < 0 ? 0 : passengers[index].count;
    this.actor.update({ "system.passengers": passengers });
  }

  _onPassengerDeleteClick(ev) {
    let index = Number($(ev.currentTarget).parents(".item").attr("data-index"));
    let passengers = duplicate(this.actor.system.passengers);
    passengers.splice(index, 1);
    this.actor.update({ "system.passengers": passengers });
  }

  _onRoleActorChange(ev) {
    let index = Number($(ev.currentTarget).parents(".item").attr("data-index"));
    let roles = duplicate(this.actor.roles);
    roles[index].actor = ev.target.value;
    this.actor.update({"system.roles" : roles});
  }

  async _onRoleEditClick(ev) {
    let index = Number($(ev.currentTarget).parents(".item").attr("data-index"));
    let roles = duplicate(this.actor.roles);
    let actor = this.actor;
    new Dialog({
      content:
        `
        <div class="form-group">
        <label style="min-width: 110px;">${game.i18n.localize("VEHICLE.EnterRoleName")}</label>

          <input name="role-name" type="text" value="${roles[index].name}"/>
        </div>
        
        <div class="form-group">
        <label style="min-width: 110px;">${game.i18n.localize("VEHICLE.RoleTest")}</label>
          <input name="role-test" type="text" placeholder="Skill or Characteristic" value="${roles[index].test}"/>
        </div>
        <div class="form-group">
        <label style="min-width: 110px;">${game.i18n.localize("VEHICLE.RoleTestLabel")}</label>
          <input name="role-test-label" type="text" value="${roles[index].testLabel}"/>
        </div>

        <div class="form-group">
        <label style="min-width: 110px;">${game.i18n.localize("VEHICLE.Handling")}</label>
          <input name="handling" type="checkbox" ${roles[index].handling ? "checked" : ""}/>
        </div>
        `,
      title: game.i18n.localize("VEHICLE.EnterRoleName"),
      buttons: {
        enter: {
          label: game.i18n.localize("Confirm"),
          callback: dlg => {
            let newName = dlg.find('[name="role-name"]').val();
            let newTest = dlg.find('[name="role-test"]').val();
            let newTestLabel = dlg.find('[name="role-test-label"]').val();
            let handling = dlg.find('[name="handling"]').is(':checked');
            roles[index].name = newName;
            roles[index].test = newTest;
            roles[index].testLabel = newTestLabel;
            roles[index].handling = handling;
            actor.update({ "system.roles": roles });
          }
        }
      },
      default: "enter"
    }).render(true);
  }

  _onRoleInputChange(ev) {
    let index = Number($(ev.currentTarget).parents(".item").attr("data-index"));
    let roles = duplicate(this.actor.roles);
    roles[index].test = ev.target.value;
    this.actor.update({ "system.roles": roles });
  }

  _onRoleDelete(ev) {
    let index = Number($(ev.currentTarget).parents(".item").attr("data-index"));
    let roles = duplicate(this.actor.roles);
    roles.splice(index, 1);
    this.actor.update({ "system.roles": roles });
  }

  _onCargoClick(ev) {
    if (ev.button != 2) return;
    new Dialog({
      title: game.i18n.localize("SHEET.SplitTitle"),
      content: `<p>${game.i18n.localize("SHEET.SplitPrompt")}</p><div class="form-group"><input name="split-amt" type="text" /></div>`,
      buttons: {
        split: {
          label: "Split",
          callback: (dlg) => {
            let amt = Number(dlg.find('[name="split-amt"]').val());
            if (isNaN(amt)) return
            this.splitItem(this._getItemId(ev), amt);
          }
        }
      }
    }).render(true);
  }
}

// Register NPC Sheet
Actors.registerSheet("wfrp4e", ActorSheetWfrp4eVehicle,
  {
    types: ["vehicle"],
    makeDefault: true
  });

class ScriptConfig extends FormApplication
{
    static get defaultOptions() 
    {
        const options = super.defaultOptions;
        options.classes = options.classes.concat(["wfrp4e", "script-config"]);
        options.title = game.i18n.localize("SCRIPT.Config");
        options.resizable = true;
        options.width = 600;
        options.height = 400;
        options.template = "systems/wfrp4e/templates/apps/script-config.hbs";
        return options;
    }

    constructor(...args)
    {
        super(...args);
    }

    async getData() 
    {
        let data = await super.getData();
        this.aceActive = game.modules.get("acelib")?.active;
        data.aceActive = this.aceActive;
        data.script = this._getScript();
        return data;
    }


    _getScript()
    {
        return getProperty(this.object, this.options.path);
    }

    _updateObject(ev, formData)
    {
        let script = this.aceActive ? this.editor.getValue() : formData.script; 
        return this.object.update({[this.options.path] : script});
    }

    activateListeners(html)
    {
        super.activateListeners(html);

        if (this.aceActive)
        {
            this.editor = ace.edit(html.find(".ace-editor")[0]);
            this.editor.setValue(this._getScript() || "");
            this.editor.setOptions(mergeObject(ace.userSettings, {
                theme : "ace/theme/solarized_dark", 
                mode : "ace/mode/js", 
                keyboardHandler : "ace/mode/vscode",
                printMargin : 0,
                maxLines: Infinity,
                indentedSoftWrap: false
            }));
            this.editor.session.setUseWrapMode(false);
            this.editor.clearSelection();
        }

        // Prevent tab from changing focus, instead add a tab to the textarea
        html.find("textarea.no-ace").keydown(ev => 
        {
            if (ev.key == "Tab")
            {
                ev.preventDefault();
                let target = ev.target;
                var start = target.selectionStart;
                var end = target.selectionEnd;

                target.value = target.value.substring(0, start) + "\t" + target.value.substring(end);

                target.selectionStart = target.selectionEnd = start + 1;
            }
        });
        this.setTextboxHeight();
    }

    setTextboxHeight()
    {
        let scriptBox = this.element.find("[name='script']")[0] || this.element.find(".ace-editor")[0];
        // I think this is the only way to get the textbox height correct with dynamic elements
        let height = 0;                                                                                                                                 // 2 * parseInt(computedStyle(element).margin) => 
        this.element.find(".form-group").each((index, element) => height += (element.clientHeight + 2 * parseInt(getComputedStyle(element).margin)));   // 2 * parseInt(3px 0px) => 
        scriptBox.style.height = `calc(100% - ${height}px`;                                                                                             // 2 * 3px = 6px per element
    }

}

/**
 * Provides the data and general interaction with Item Sheets
 *
 * The main purpose of this sheet class is to provide the correct
 * data to the template when rendering depending on what type
 * of item the sheet belongs too. Additionally, item sheet
 * interactivity and events are handled here.
 */


class ItemSheetWfrp4e extends WFRP4eSheetMixin$1(ItemSheet) 
{
  constructor(item, options) {
    super(item, options);
    this.mce = null;
  }


  static get defaultOptions() {
    const options = super.defaultOptions;
    options.tabs = [{ navSelector: ".tabs", contentSelector: ".content", initial: "description" }];
    options.dragDrop = [{dragSelector: ".effect-list .effect", dropSelector: "form"}],
    options.scrollY = [".details"];
    return options;
  }


  /**
   * Override header buttons to add custom ones.
   */
  _getHeaderButtons() {
    let buttons = super._getHeaderButtons();
    // Add "Post to chat" button
    // We previously restricted this to GM and editable items only. If you ever find this comment because it broke something: eh, sorry!
    buttons.unshift(
      {
        class: "post",
        icon: "fas fa-comment",
        onclick: ev => this.item.postItem()
      });
    return buttons
  }

  // Add tooltips to header buttons
  async _render(force = false, options = {}) {
    await super._render(force, options);
   this.element.find(".close").attr({"data-tooltip" : game.i18n.localize("SHEET.Close"), "data-tooltip-direction" : "UP"});
   this.element.find(".configure-sheet").attr({"data-tooltip" : game.i18n.localize("SHEET.Configure"), "data-tooltip-direction" : "UP"});
   this.element.find(".post").attr({"data-tooltip" : game.i18n.localize("SHEET.Post"), "data-tooltip-direction" : "UP"});
   this.element.find(".import").attr({"data-tooltip" : game.i18n.localize("SHEET.Import"), "data-tooltip-direction" : "UP"});
   let idLink = this.element.find(".document-id-link");
   this.element.find(".window-title").after(idLink);
   WFRP_Utility$1.addLinkSources(this.element);
  }


  /**
   * Use a type-specific template for each different item type
   */
  get template() {
    let type = this.item.type;
    return `systems/wfrp4e/templates/items/item-${type}-sheet.hbs`;
  }

  /* -------------------------------------------- */

  /**
   * Prepare item sheet data.
   * 
   * Start with the base item data and extending with additional properties for rendering.
   * Each item type has specific data (typically from config constants) that needs to be rendered
   * 
   * Example: A weapon sheet needs all different weapon types to list in the weaponGroup dropdown (`data['weaponGroups'] =  game.wfrp4e.config.weaponGroups;`)
   */
  async getData() {
    const data = await super.getData();
    data.system = data.item._source.system; // Use source data to avoid modifications being applied

    if (this.item.type == "spell") 
    {
      if (game.wfrp4e.config.magicLores[this.item.lore.value]) {
        data["loreValue"] = game.wfrp4e.config.magicLores[this.item.lore.value];
      }
      else {
        data["loreValue"] = this.item.lore.value;
      }
    }

    //@HOUSE
    if (this.item.type == "weapon" && game.settings.get("wfrp4e", "mooRangeBands"))
    {
      game.wfrp4e.utility.logHomebrew("mooRangeBands");
      data.showOptimal = true;
    }
    //@/HOUSE

    else if (this.item.type == "career") {
      data['skills'] = this.item.system.skills.join(", ").toString();
      data['earningSkills'] = this.item.system.incomeSkill.map(skillIndex => this.item.system.skills[skillIndex]);
      data['talents'] = this.item.system.talents.toString();
      data['trappings'] = this.item.system.trappings.toString();
      let characteristicList = duplicate(game.wfrp4e.config.characteristicsAbbrev);
      for (let char in characteristicList) {
        if (this.item.system.characteristics.includes(char))
          characteristicList[char] = {
            abrev: game.wfrp4e.config.characteristicsAbbrev[char],
            checked: true
          };
        else
          characteristicList[char] = {
            abrev: game.wfrp4e.config.characteristicsAbbrev[char],
            checked: false
          };
      }
      data['characteristicList'] = characteristicList;
    }

    else if (this.item.type == "cargo") {
      data.cargoTypes = game.wfrp4e.config.trade.cargoTypes;
      data.qualities = game.wfrp4e.config.trade.qualities;
      data["dotrActive"] = (game.modules.get("wfrp4e-dotr") && game.modules.get("wfrp4e-dotr").active);
    }

    if (this.item.type == "critical" || this.item.type == "injury" || this.item.type == "disease" || this.item.type == "mutation")
      this.addConditionData(data);
    data.showBorder = data.item.img == "systems/wfrp4e/icons/blank.png" || !data.item.img;
    data.isOwned = this.item.isOwned;

    data.enrichment = await this._handleEnrichment();

    return data;
  }

  async _handleEnrichment()
  {
    let enrichment = {};
    enrichment["system.description.value"] = await TextEditor.enrichHTML(this.item.system.description.value, { async: true, secrets: this.item.isOwner, relativeTo: this.item});
    enrichment["system.gmdescription.value"] = await TextEditor.enrichHTML(this.item.system.gmdescription.value, { async: true, secrets: this.item.isOwner, relativeTo: this.item });

    return expandObject(enrichment)
  }

  addConditionData(data) {
    data.conditions = duplicate(game.wfrp4e.config.statusEffects).filter(i => !["fear", "grappling", "engaged"].includes(i.id)).map(e => new EffectWfrp4e(e));
    delete data.conditions.splice(data.conditions.length - 1, 1);
    for (let condition of data.conditions) {
      let existing = this.item.effects.find(e => e.conditionId == condition.conditionId);
      if (existing) {
        condition.value = existing.flags.wfrp4e.value;
        condition.flags.wfrp4e.value = existing.conditionValue;
      }
      else if (condition.isNumberedCondition) {
        condition.flags.wfrp4e.value = 0;
      }

      if (condition.flags.wfrp4e.value == null)
        condition.boolean = true;

    }
  }

    /** @inheritdoc */
    _onDragStart(event) {
      // Create drag data
      let dragData;

      let li = event.currentTarget;
      if ( li.dataset.effectId ) {
        const effect = this.item.effects.get(li.dataset.effectId);
        dragData = effect.toDragData();
      }
      if ( !dragData ) return;

      // Set data transfer
      event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
    }

    async _onDrop(event)
    {
      let data = JSON.parse(event.dataTransfer.getData("text/plain"));
      if (data.type == "ActiveEffect")
      {
        const effect = await ActiveEffect.implementation.fromDropData(data);
        if ( !this.item.isOwner || !effect ) 
        {
          return false
        }        if ( this.item.uuid === effect.parent?.uuid ) 
        {
          return false;
        }
        return ActiveEffect.create(effect.toObject(), {parent: this.item});
      }

    }

  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    html.find('input[type="checkbox"]').change(event => this._onSubmit(event));
    html.find('.lore-input').change(this._onLoreChange.bind(this));
    html.find('.char-checkbox').click(this._onCharCheckboxClick.bind(this));
    html.find(".item-checkbox").click(this._onCheckboxClick.bind(this));
    html.find('.csv-input').change(this._onCSVInput.bind(this));
    html.find('.symptom-input').change(this._onSymptomChange.bind(this));
    html.find('.effect-create').click(this._onEffectCreate.bind(this));
    html.find('.effect-title').click(this._onEffectTitleClick.bind(this));
    html.find('.effect-delete').click(this._onEffectDelete.bind(this));
    html.find(".condition-value").mousedown(this._onConditionClick.bind(this));
    html.find(".condition-toggle").mousedown(this._onConditionToggle.bind(this));


    html.find(".edit-item-properties").click(ev => {
      new game.wfrp4e.apps.ItemProperties(this.item).render(true);
    });
    html.find(".cargo-sell").click(ev => {
      game.wfrp4e.apps.Wfrp4eTradeManager.processTradeSell(this.item);
    });

    // Support custom entity links
    html.on("click", ".chat-roll", WFRP_Utility$1.handleRollClick.bind(WFRP_Utility$1));
    html.on("click", ".symptom-tag", WFRP_Utility$1.handleSymptomClick.bind(WFRP_Utility$1));
    html.on("click", ".condition-chat", WFRP_Utility$1.handleConditionClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.table-click', WFRP_Utility$1.handleTableClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.pay-link', WFRP_Utility$1.handlePayClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.credit-link', WFRP_Utility$1.handleCreditClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.corruption-link', WFRP_Utility$1.handleCorruptionClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.fear-link', WFRP_Utility$1.handleFearClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.terror-link', WFRP_Utility$1.handleTerrorClick.bind(WFRP_Utility$1));
    html.on('mousedown', '.exp-link', WFRP_Utility$1.handleExpClick.bind(WFRP_Utility$1));

  }

  // Lore input is tricky because we need to choose from a set of defined choices, but it isn't a dropdown
  async _onLoreChange(event) {
    let inputLore = event.target.value;
    // Go through each lore name
    for (let lore in game.wfrp4e.config.magicLores) {
      // If lore value matches config, use that (Update the actor with the "key" value)
      if (inputLore == game.wfrp4e.config.magicLores[lore]) {
        return this.item.update({ 'system.lore.value': lore });
      }
    }
    // Otherwise, if the input isn't recognized, store user input directly as a custom lore
    return this.item.update({ 'system.lore.value': inputLore });
  }


  // For a career, when characteristic checkbox is changed, ensure list of
  // characteristics for that career remains valid.
  _onCharCheckboxClick(event) {
    this._onSubmit(event);
    let charChanged = $(event.currentTarget).attr("name");

    let characteristicList = duplicate(this.item.characteristics);

    // If the charChanged is already in the list, remove it
    if (characteristicList.includes(charChanged))
      characteristicList.splice(characteristicList.findIndex(c => c == charChanged));
    else // If it isn't in the list, add it
      characteristicList.push(charChanged);

    this.item.update({ 'data.characteristics': characteristicList });
  }

  _onCheckboxClick(event) {
    let target = $(event.currentTarget).attr("data-target");
    this.item.update({[target] : !getProperty(this.item, target)});
  }

  // This listener converts comma separated lists in the career section to arrays,
  // placing them in the correct location using update
  async _onCSVInput(event) {
    this._onSubmit(event);
    let list = event.target.value.split(",").map(function (item) {
      return item.trim();
    });

    switch (event.target.attributes["data-dest"].value) {
      case 'skills':
        {
          await this.item.update({ 'data.skills': list });
        }
        break;

      // find the indices of the skills that match the earning skill input, send those
      // values to data.incomeSkill
      case 'earning':
        {
          this.item.update({ 'data.incomeSkill': [] });
          let earningSkills = [];
          for (let sk in list) {
            let skillIndex = this.item.skills.indexOf(list[Number(sk)]);

            if (skillIndex == -1)
              continue;
            else
              earningSkills.push(skillIndex);

          }
          await this.item.update({ 'data.incomeSkill': earningSkills });
        }
        break;
      case 'talents':
        {
          await this.item.update({ 'data.talents': list });
        }
        break;

      case 'trappings':
        {
          await this.item.update({ 'data.trappings': list });
        }
        break;

    }
  }

  async _onSymptomChange(event) {
    // Alright get ready for some shit

    // Get all symptoms user inputted
    let symptoms = event.target.value.split(",").map(i => i.trim());

    // Extract just the name (with no severity)
    let symtomNames = symptoms.map(s => {
      if (s.includes("("))
        return s.substring(0, s.indexOf("(") - 1)
      else return s
    });

    // take those names and lookup the associated symptom key
    let symptomKeys = symtomNames.map(s => game.wfrp4e.utility.findKey(s, game.wfrp4e.config.symptoms));

    // Remove anything not found
    symptomKeys = symptomKeys.filter(s => !!s);

    // Map those symptom keys into effects, renaming the effects to the user input
    let symptomEffects = symptomKeys.map((s, i) => {
      if (game.wfrp4e.config.symptomEffects[s]) {
        let effect = duplicate(game.wfrp4e.config.symptomEffects[s]);
        effect.name = symptoms[i];
        return effect

      }
    }).filter(i => !!i);

    // Remove all previous symptoms from the item
    let effects = this.item.effects.map(i => i.toObject()).filter(e => getProperty(e, "flags.wfrp4e.symptom"));

    // Delete previous symptoms
    await this.item.deleteEmbeddedDocuments("ActiveEffect", effects.map(i => i._id));

    // Add symptoms from input
    await this.item.createEmbeddedDocuments("ActiveEffect", symptomEffects);

    this.item.update({ "system.symptoms.value": symptoms.join(", ") });
  } 
  
  _onEffectTitleClick(ev) {
    let id = this._getId(ev);
    const effect = this.item.effects.find(i => i.id == id);
    effect.sheet.render(true);
  }

  _onEffectDelete(ev) {
    let id = this._getId(ev);
    this.item.deleteEmbeddedDocuments("ActiveEffect", [id]);
  }

  _onConditionClick(ev) {
    let condKey = $(ev.currentTarget).parents(".sheet-condition").attr("data-cond-id");
    if (ev.button == 0)
      this.item.addCondition(condKey);
    else if (ev.button == 2)
      this.item.removeCondition(condKey);
  }

  _onConditionToggle(ev) {
    let condKey = $(ev.currentTarget).parents(".sheet-condition").attr("data-cond-id");

    if (game.wfrp4e.config.statusEffects.find(e => e.id == condKey).flags.wfrp4e.value == null) {
      if (this.item.hasCondition(condKey))
        this.item.removeCondition(condKey);
      else
        this.item.addCondition(condKey);
      return
    }

    if (ev.button == 0)
      this.item.addCondition(condKey);
    else if (ev.button == 2)
      this.item.removeCondition(condKey);
  }
      
  _onScriptConfig(ev)
  {
      new ScriptConfig(this.object, {path : this._getPath(ev)}).render(true);
  }

}

function passengerRender(token) {
    if (!token.document?.flags.wfrp4e?.hidePassengers && token.actor && token.actor.type == "vehicle")
    {
      if (token.passengers)
      {
        token.passengers.destroy();
      }
      let passengerIconSize = canvas.dimensions.size / 3.3333;
      let rowSize = 3;
      let colSize = 3;
      let container = new PIXI.Container();
      let imgCount = 0;
      if (token.actor.passengers.length > 9)
      {
        passengerIconSize = canvas.dimensions.size / 4;
        rowSize = 4;
        colSize = 4;
      }
      passengerIconSize *= token.document.width;
      for (let img of token.actor.passengers.map(p => p.img))
      {
        if (!img)
        continue
        let sp = PIXI.Sprite.from(img);
        sp.width = passengerIconSize;
        sp.height = passengerIconSize;
        sp.x = passengerIconSize * (imgCount % rowSize);
        sp.y = passengerIconSize * Math.floor(imgCount / colSize);
        container.addChild(sp);
        imgCount++;
        if (imgCount > 9)
        break;
        token.passengers = token.addChild(container);
      }
    }
}

class WFRPTokenHUD extends TokenHUD {


    activateListeners(html)
    {

        html.find(".status-effects")
        .off("click", ".effect-control", this._onToggleEffect.bind(this))
        .off("contextmenu", ".effect-control", event => this._onToggleEffect(event, {overlay: true}));

    }
}

function canvas$1() {
  Hooks.on("canvasInit", (canvas) => {

    /**
     * Double every other diagonal movement
     */
    SquareGrid.prototype.measureDistances = function (segments, options = {}) {
      if (!options.gridSpaces) return BaseGrid.prototype.measureDistances(segments, options);

      // Track the total number of diagonals
      let nDiagonal = 0;
      this.parent.diagonalRule;
      const d = canvas.dimensions;

      // Iterate over measured segments
      return segments.map(s => {
        let r = s.ray;

        // Determine the total distance traveled
        let nx = Math.abs(Math.ceil(r.dx / d.size));
        let ny = Math.abs(Math.ceil(r.dy / d.size));

        // Determine the number of straight and diagonal moves
        let nd = Math.min(nx, ny);
        let ns = Math.abs(ny - nx);
        nDiagonal += nd;
        let nd10 = Math.floor(nDiagonal / 2) - Math.floor((nDiagonal - nd) / 2);
        let spaces = (nd10 * 2) + (nd - nd10) + ns;
        return spaces * canvas.dimensions.distance;

      });
    };
  });


  Hooks.on("canvasReady", (canvas) => {

    if (!(game.modules.get("fxmaster") && game.modules.get("fxmaster").active)) {
      let morrsliebActive = canvas.scene.getFlag("wfrp4e", "morrslieb");
      if (morrsliebActive) {
        if (!canvas.primary.filters)
          canvas.primary.filters = [];
        canvas.primary.filters.push(CONFIG.Morrslieb);
      } 
      else if (canvas.primary.filters?.length)
      {
        // If morrslieb is not active, remove any morrslieb filters
        canvas.primary.filters = canvas.primary.filters.filter(i => !i.morrslieb);
      }
    }
    //canvas.hud.token = new WFRPTokenHUD();
  });
}

function controlButtons() {
  /**
   * Add Status right click option for combat tracker combatants
   */
  Hooks.on("getSceneControlButtons", (buttons) => {
    if (!game.canvas || !game.canvas.scene)
      return
    let group = buttons.find(b => b.name == "lighting");
    group.tools.push({
      button: true,
      icon: "fas fa-circle",
      name: "morrslieb",
      title: game.canvas.scene.getFlag("wfrp4e", "morrslieb") ? "Morrslieb - Currently On " : "Morrslieb - Currently Off",
      onClick: WFRP_Utility$1.toggleMorrslieb
    });
  });
}

function keepId() {

  Hooks.on("preCreateScene", keepId);
  Hooks.on("preCreateJournalEntry", keepId);
  Hooks.on("preCreateRollTable", keepId);



  function keepId(document, data, options) {
    if (data._id)
      options.keepId = WFRP_Utility$1._keepID(data._id, document);
  }
}

function settings() {
    Hooks.on("updateSetting", (setting) => {
        // Centralized handling of group advantage updates
        // If group advantage is updated, update advantage of all combatants in the current combat
        // Then, make sure that change is reflected in the counter on the combat tracker (if the update was made by a different user)
        if (setting.key == "wfrp4e.groupAdvantageValues")
        {
            ui.notifications.notify(game.i18n.format("GroupAdvantageUpdated", {players : setting.value.players, enemies : setting.value.enemies}));
            
            $(".advantage-group input").each((index, input) => {
                let group = input.dataset.group;
                input.value = setting.value[group];
            });
        }
    });  
}

function notes () {
    Hooks.on("activateNote", (note, options) => {
        options.anchor = note.document.flags.anchor?.slug;
    });
}

function i18n () {
    Hooks.on("i18nInit", () => {
        // Localize strings in the  game.wfrp4e.config.object
        for (let obj of game.wfrp4e.config.toTranslate) {
                for (let el in game.wfrp4e.config[obj]) {
                    if (typeof game.wfrp4e.config[obj][el] === "string") {
                        game.wfrp4e.config[obj][el] = game.i18n.localize(game.wfrp4e.config[obj][el]);
                    }
                }
        }
    });
}

class HomebrewSettings extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "homebrew-settings";
        options.template = "systems/wfrp4e/templates/apps/homebrew-settings.hbs";
        options.width = 600;
        options.minimizable = true;
        options.resizable = true;
        options.title = "Homebrew Settings";
        return options;
    }

    getData() {
        let data = super.getData();

        data.settings = Array.from(game.settings.settings).filter(s => s[1].homebrew).map(i => i[1]);
        data.settings = data.settings.filter(s => !s.key.includes("moo"));
        data.mooSettings = Array.from(game.settings.settings).filter(s => s[1].homebrew).map(i => i[1]).filter(s => s.key.includes("moo"));

        data.settings.forEach(s => s.inputType = s.type == Boolean ? "checkbox" : "text");
        data.mooSettings.forEach(s => s.inputType = s.type == Boolean ? "checkbox" : "text");

        data.settings.forEach(s => s.value = game.settings.get(s.namespace, s.key));
        data.mooSettings.forEach(s => s.value = game.settings.get(s.namespace, s.key));
        return data
    }


    async _updateObject(event, formData) {
        for(let setting in formData)
            game.settings.set("wfrp4e", setting, formData[setting]);
    }

  

}

class TableSettings extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "table-settings";
        options.template = "systems/wfrp4e/templates/apps/table-settings.hbs";
        options.width = 600;
        options.minimizable = true;
        options.resizable = true;
        options.title = "Table Settings";
        return options;
    }

    getData() {
        let data = super.getData();
        let settings = game.settings.get("wfrp4e", "tableSettings");
        data.settings = {};

        for (let setting in settings)
        {
            data.settings[setting] = {
                label : "SETTINGS.TABLE_" + setting,
                choices : this.getTableChoices(setting),
                selected : settings[setting]
            };
        }

        return data
    }

    getTableChoices(key)
    {
        let choices = {};
        let tables = game.tables.filter(i => i.getFlag("wfrp4e", "key") == key);


        // Add tables without a column 
        for(let t of tables.filter(i => !i.getFlag("wfrp4e", "column")))
        {
            choices[t.id] = t.name;
        }

        let columns = tables.filter(i => i.getFlag("wfrp4e", "column"));
        if (columns.length)
        {
            choices[columns.map(i => i.id).join(",")] = columns[0].name.split("-")[0];
        }
        return choices
    }


    async _updateObject(event, formData) {
        return game.settings.set("wfrp4e", "tableSettings", formData)
    }

  

}

const debouncedReload = foundry.utils.debounce(() => {
  window.location.reload();
}, 100);

function init() {
  /**
   * Init function loads tables, registers settings, and loads templates
   */
  Hooks.once("init", () => {

    TravelDistanceWfrp4e.loadTravelData();

    game.settings.register("wfrp4e", "systemMigrationVersion", {
      name: "System Migration Version",
      scope: "world",
      config: false,
      type: String,
      default: 0
    });

    game.settings.registerMenu("wfrp4e", "homebrew", {
      name: "WFRP4e House Rules",
      label: "WFRP4e Homebrew",
      hint: "Settings for common homebrew/house rules",
      type: HomebrewSettings,
      restricted: true
  });

  game.settings.registerMenu("wfrp4e", "tableSettings", {
    name: "WFRP4e Table Settings",
    label: "WFRP4e Table Settings",
    hint: "Configure which tables to roll on when multiple of the same key exist.",
    type: TableSettings,
    restricted: true
});

    // Register initiative rule
    game.settings.register("wfrp4e", "initiativeRule", {
      name: "SETTINGS.InitRule",
      hint: "SETTINGS.InitHint",
      scope: "world",
      config: true,
      default: "default",
      type: String,
      choices: {
        "default": "SETTINGS.InitDefault",
        "sl": "SETTINGS.InitSL",
        "d10Init": "SETTINGS.InitD10",
        "d10InitAgi": "SETTINGS.InitD10Agi"
      },
      onChange: rule => _setWfrp4eInitiative(rule)
    });
    _setWfrp4eInitiative(game.settings.get("wfrp4e", "initiativeRule"));


    function _setWfrp4eInitiative(initMethod) {
      let formula;
      switch (initMethod) {
        case "default":
          formula = "@characteristics.i.value + @characteristics.ag.value/100";
          break;

        case "sl":
          formula = "(floor(@characteristics.i.value / 10) - floor(1d100/10))";
          break;

        case "d10Init":
          formula = "1d10 + @characteristics.i.value";
          break;

        case "d10InitAgi":
          formula = "1d10 + @characteristics.i.bonus + @characteristics.ag.bonus";
          break;
      }

      let decimals = (initMethod == "default") ? 2 : 0;
      CONFIG.Combat.initiative = {
        formula: formula,
        decimals: decimals
      };
    }


    // Register Advantage cap
    game.settings.register("wfrp4e", "capAdvantageIB", {
      name: "SETTINGS.CapAdvIB",
      hint: "SETTINGS.CapAdvIBHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Automatic Success threshold
    game.settings.register("wfrp4e", "automaticSuccess", {
      name: "SETTINGS.AutomaticSuccess",
      hint: "SETTINGS.AutomaticSuccessHint",
      scope: "world",
      config: true,
      default: 5,
      type: Number
    });

    // Register Automatic Success threshold
    game.settings.register("wfrp4e", "automaticFailure", {
      name: "SETTINGS.AutomaticFailure",
      hint: "SETTINGS.AutomaticFailureHint",
      scope: "world",
      config: true,
      default: 96,
      type: Number
    });

    // Register Fast SL rule
    game.settings.register("wfrp4e", "fastSL", {
      name: "SETTINGS.FastSL",
      hint: "SETTINGS.FastSLHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Tests above 100% Rule
    game.settings.register("wfrp4e", "testAbove100", {
      name: "SETTINGS.TestsAbove100",
      hint: "SETTINGS.TestsAbove100Hint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Criticals/Fumbles on all tests
    game.settings.register("wfrp4e", "criticalsFumblesOnAllTests", {
      name: "SETTINGS.CriticalsFumblesAllTests",
      hint: "SETTINGS.CriticalsFumblesAllTestsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });


    // Register Extended Tests
    game.settings.register("wfrp4e", "extendedTests", {
      name: "SETTINGS.ExtendedTests",
      hint: "SETTINGS.ExtendedTestsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "channelingNegativeSLTests", {
      name: "SETTINGS.ChannelingNegativeSL",
      hint: "SETTINGS.ChannelingNegativeSLHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    // Limit Equipped Items
    game.settings.register("wfrp4e", "limitEquippedWeapons", {
      name: "SETTINGS.LimitEquippedWeapons",
      hint: "SETTINGS.LimitEquippedWeaponsHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register Test auto-fill
    game.settings.register("wfrp4e", "autoFillAdvantage", {
      name: "SETTINGS.AutoFillAdv",
      hint: "SETTINGS.AutoFillAdvHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register default test difficulty
    game.settings.register("wfrp4e", "testDefaultDifficulty", {
      name: "SETTINGS.TestDialogDefaultDifficulty",
      hint: "SETTINGS.TestDialogDefaultDifficultyHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Round Summary
    game.settings.register("wfrp4e", "displayRoundSummary", {
      name: "SETTINGS.RoundSummary",
      hint: "SETTINGS.RoundSummaryHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register Status on Turn Start
    game.settings.register("wfrp4e", "statusOnTurnStart", {
      name: "SETTINGS.StatusTurnStart",
      hint: "SETTINGS.StatusTurnStartHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });


    // Register Focus on Turn Start
    game.settings.register("wfrp4e", "focusOnTurnStart", {
      name: "SETTINGS.FocusTurnStart",
      hint: "SETTINGS.FocusTurnStartHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register Hiding Test Data
    game.settings.register("wfrp4e", "hideTestData", {
      name: "SETTINGS.HideTestData",
      hint: "SETTINGS.HideTestDataHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register Manual Chat Cards
    game.settings.register("wfrp4e", "manualChatCards", {
      name: "SETTINGS.ManualChatCards",
      hint: "SETTINGS.ManualChatCardsHint",
      scope: "client",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "weaponLength", {
      name: "SETTINGS.WeaponLength",
      hint: "SETTINGS.WeaponLengthHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    game.settings.register("wfrp4e", "rangeAutoCalculation", {
      name: "SETTINGS.RangeAutoCalculation",
      hint: "SETTINGS.RangeAutoCalculationHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });


    game.settings.register("wfrp4e", "playerBrowser", {
      name: "SETTINGS.PlayerBrowser",
      hint: "SETTINGS.PlayerBrowserHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "playerExperienceEditing", {
      name: "SETTINGS.PlayerExperienceEditing",
      hint: "SETTINGS.PlayerExperienceEditingHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });


    // Register Advantage cap
    game.settings.register("wfrp4e", "soundPath", {
      name: "SETTINGS.SoundEffects",
      hint: "SETTINGS.SoundEffectsHint",
      scope: "world",
      config: true,
      default: "systems/wfrp4e/sounds/",
      type: String
    });

    game.settings.register("wfrp4e", "customCursor", {
      name: "SETTINGS.CustomCursor",
      hint: "SETTINGS.CustomCursorHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });


    game.settings.register("wfrp4e", "throwMoney", {
      name: "SETTINGS.ThrowMoney",
      hint: "SETTINGS.ThrowMoneyHint",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    game.settings.register("wfrp4e", "advantageBonus", {
      name: "SETTINGS.AdvantageBonus",
      hint: "SETTINGS.AdvantageBonusHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: 10,
      type: Number
    });

    game.settings.register("wfrp4e", "uiaCrits", {
      name: "SETTINGS.UIACrits",
      hint: "SETTINGS.UIACritsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "uiaCritsMod", {
      name: "SETTINGS.UIACritsMod",
      hint: "SETTINGS.UIACritsModHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: 10,
      type: Number
    });

    game.settings.register("wfrp4e", "uiaShields", {
      name: "SETTINGS.UIAShields",
      hint: "SETTINGS.UIAShieldsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "tables", {
      scope: "world",
      config: false,
      default: {},
      type: Object
    });

    game.settings.register("wfrp4e", "bugReportName", {
      scope: "world",
      config: false,
      default: "",
      type: String
    });

    game.settings.register("wfrp4e", "tableVisibility", {
      scope: "world",
      config: false,
      default: {},
      type: Object
    });

    
    game.settings.register("wfrp4e", "tableRollMode", {
      scope: "client",
      config: false,
      default: {},
      type: Object
    });

    game.settings.register("wfrp4e", "useGroupAdvantage", {
      name: "SETTINGS.UseGroupAdvantage",
      hint: "SETTINGS.UseGroupAdvantageHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean, 
      onChange: debouncedReload,
    });

    game.settings.register("wfrp4e", "groupAdvantageValues", {
      scope: "world",
      config: false,
      default: {players: 0, enemies : 0},
      type: Object
    });

    game.settings.register("wfrp4e", "mooAdvantage", {
      name: "SETTINGS.MooAdvantage",
      hint: "SETTINGS.MooAdvantageHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });



    game.settings.register("wfrp4e", "mooDifficulty", {
      name: "SETTINGS.MooDifficulty",
      hint: "SETTINGS.MooDifficultyHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });


    
    // game.settings.register("wfrp4e", "mooCritsFumbles", {
    //   name: "SETTINGS.MooCritsFumbles",
    //   hint: "SETTINGS.MooCritsFumblesHint",
    //   scope: "world",
    //   config: false,
    //   homebrew: true,
    //   default: false,
    //   type: Boolean
    // });


    game.settings.register("wfrp4e", "mooConditions", {
      name: "SETTINGS.MooConditions",
      hint: "SETTINGS.MooConditionsHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooConditionTriggers", {
      name: "SETTINGS.MooConditionTriggers",
      hint: "SETTINGS.MooConditionTriggersHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooCritModifiers", {
      name: "SETTINGS.MooCritModifiers",
      hint: "SETTINGS.MooCritMOdifiersHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });


    game.settings.register("wfrp4e", "mooSLDamage", {
      name: "SETTINGS.MooSLDamage",
      hint: "SETTINGS.MooSLDamageHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooRangedDamage", {
      name: "SETTINGS.MooRangedDamage",
      hint: "SETTINGS.MooRangedDamageHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });


    game.settings.register("wfrp4e", "mooMagicAdvantage", {
      name: "SETTINGS.MooMagicAdvantage",
      hint: "SETTINGS.MooMagicAdvantageHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooOvercasting", {
      name: "SETTINGS.MooOvercasting",
      hint: "SETTINGS.MooOvercastingHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooCatastrophicMiscasts", {
      name: "SETTINGS.MooCatastrophicMiscasts",
      hint: "SETTINGS.MooCatastrophicMiscastsHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

      
    game.settings.register("wfrp4e", "partialChannelling", {
      name: "SETTINGS.PartialChannelling",
      hint: "SETTINGS.PartialChannellingHint",
      scope: "world",
      homebrew: true,
      config: false,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "channellingIngredients", {
      name: "SETTINGS.ChannellingIngredients",
      hint: "SETTINGS.ChannellingIngredientsHint",
      scope: "world",
      homebrew: true,
      config: false,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooCriticalChannelling", {
      name: "SETTINGS.MooCriticalChannelling",
      hint: "SETTINGS.MooCriticalChannellingHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooCastAfterChannelling", {
      name: "SETTINGS.MooCastAfterChannelling",
      hint: "SETTINGS.MooCastAfterChannellingHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooPenetrating", {
      name: "SETTINGS.MooPenetrating",
      hint: "SETTINGS.MooPenetratingHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooQualities", {
      name: "SETTINGS.MooQualities",
      hint: "SETTINGS.MooQualitiesHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooShieldAP", {
      name: "SETTINGS.MooShieldAP",
      hint: "SETTINGS.MooShieldAPHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooCriticalMitigation", {
      name: "SETTINGS.MooCriticalMitigation",
      hint: "SETTINGS.MooCriticalMitigationHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });


    game.settings.register("wfrp4e", "mooRangeBands", {
      name: "SETTINGS.MooRangeBands",
      hint: "SETTINGS.MooRangeBandsHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "mooSizeDamage", {
      name: "SETTINGS.MooSizeDamage",
      hint: "SETTINGS.MooSizeDamageHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });

    
    game.settings.register("wfrp4e", "mooHomebrewItemChanges", {
      name: "SETTINGS.MooHomebrewItems",
      hint: "SETTINGS.MooHomebrewItemHint",
      scope: "world",
      config: false,
      homebrew: true,
      default: false,
      type: Boolean
    });
    
    // Register Unofficial Grimoire
    game.settings.register("wfrp4e", "unofficialgrimoire", {
      name: "SETTINGS.UnofficialGrimoire",
      hint: "SETTINGS.UnofficialGrimoireHint",
      scope: "world",
      homebrew: true,
      config: false,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "useWoMOvercast", {
      name: "SETTINGS.useWoMOvercast",
      hint: "SETTINGS.useWoMOvercastHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "useWoMChannelling", {
      name: "SETTINGS.useWoMChannelling",
      hint: "SETTINGS.useWoMChannellingHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "useWoMInfluences", {
      name: "SETTINGS.useWoMInfluences",
      hint: "SETTINGS.useWoMInfluencesHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "useSocketTests", {
      name: "SETTINGS.useSocketTests",
      hint: "SETTINGS.useSocketTestsHint",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    game.settings.register("wfrp4e", "grudges", {
      name: "Grudges",
      scope: "world",
      config: false,
      default: [],
      type: Array
    });

    game.settings.register("wfrp4e", "tableSettings", {
      name: "SETTINGS.TableSettings",
      hint: "SETTINGS.TableSettings",
      scope: "world",
      config: false,
      default: {
        species : "FM6ASUoNX21MHuWa",
        minormis : "iPVwX0ul6lHVbKSX",
        majormis : "we8Vo5GC3ZsDI7aA",
        mutatephys : "YQ5XdjikeSiwo8fn",
        mutatemental : "5HKnpyOk4XDPdZ7V",
        oops : "MWkeER1iuwAJASNo",
        wrath : "CcKYnmbQyRzGkrFy",
        doom : "led1vSPKcqMpS6jp",
        critarm : "JYX8E8WgNb2em8g3",
        critleg : "j2joGAVBNJgS1G1g",
        crithead : "7KReueNRjaI6dVLk",
        critbody : "CUIX4e2hiHdSoJ64",
      },
      type: Object
    });




    // Pre-load templates
    loadTemplates([
      "systems/wfrp4e/templates/actors/character/character-main.hbs",
      "systems/wfrp4e/templates/actors/actor-combat.hbs",
      "systems/wfrp4e/templates/actors/actor-effects.hbs",
      "systems/wfrp4e/templates/actors/actor-biography.hbs",
      "systems/wfrp4e/templates/actors/actor-inventory.hbs",
      "systems/wfrp4e/templates/actors/actor-skills.hbs",
      "systems/wfrp4e/templates/actors/actor-magic.hbs",
      "systems/wfrp4e/templates/actors/actor-religion.hbs",
      "systems/wfrp4e/templates/actors/actor-talents.hbs",
      "systems/wfrp4e/templates/actors/actor-notes.hbs",
      "systems/wfrp4e/templates/actors/npc/npc-careers.hbs",
      "systems/wfrp4e/templates/actors/creature/creature-main.hbs",
      "systems/wfrp4e/templates/actors/creature/creature-notes.hbs",
      "systems/wfrp4e/templates/actors/creature/creature-main.hbs",
      "systems/wfrp4e/templates/actors/vehicle/vehicle-main.hbs",
      "systems/wfrp4e/templates/actors/vehicle/vehicle-cargo.hbs",
      "systems/wfrp4e/templates/actors/vehicle/vehicle-description.hbs",
      "systems/wfrp4e/templates/actors/vehicle/vehicle-effects.hbs",
      "systems/wfrp4e/templates/partials/armour-location.hbs",
      "systems/wfrp4e/templates/partials/item-container.hbs",
      "systems/wfrp4e/templates/partials/qualities-flaws.hbs",
      "systems/wfrp4e/templates/partials/overcasts.hbs",
      "systems/wfrp4e/templates/partials/wom-overcasts.hbs",
      "systems/wfrp4e/templates/dialog/dialog-constant.hbs",
      "systems/wfrp4e/templates/chat/roll/test-card.hbs",
      "systems/wfrp4e/templates/chat/help/chat-command-display-info.hbs",
      "systems/wfrp4e/templates/items/item-header.hbs",
      "systems/wfrp4e/templates/items/item-description.hbs",
      "systems/wfrp4e/templates/items/item-effects.hbs"
    ]);

    // Load name construction from files
    NameGenWfrp._loadNames();

      CONFIG.Morrslieb = new PIXI.filters.AdjustmentFilter({ green: 0.5, red: 0.25, blue: 0.25, morrslieb: true });
      CONFIG.MorrsliebObject = {
        color: { value:"#4cb53a", apply: true },
        gamma: 1.0,
        contrast: 1.0,
        brightness: 1.0,
        saturation: 0.2
    };

    CONFIG.fontDefinitions.CaslonAntique = {editor : true, fonts : []};

    CONFIG.canvasTextStyle = new PIXI.TextStyle({
      fontFamily: "CaslonAntique",
      fontSize: 36,
      fill: "#FFFFFF",
      stroke: '#111111',
      strokeThickness: 1,
      dropShadow: true,
      dropShadowColor: "#000000",
      dropShadowBlur: 4,
      dropShadowAngle: 0,
      dropShadowDistance: 0,
      align: "center",
      wordWrap: false
    });

    // Keep a list of actors that need to prepareData after 'ready' (generally those that rely on other actor data - passengers/mounts)
    game.wfrp4e.postReadyPrepare = [];
  });
}

function FoundryOverrides () {


  // Convert functions that move data between world and compendium to retain ID
  Actors.prototype.fromCompendium = keepID(Actors.prototype.fromCompendium);
  Items.prototype.fromCompendium = keepID(Items.prototype.fromCompendium);
  Journal.prototype.fromCompendium = keepID(Journal.prototype.fromCompendium);
  Scenes.prototype.fromCompendium = keepID(Scenes.prototype.fromCompendium);
  RollTables.prototype.fromCompendium = keepID(RollTables.prototype.fromCompendium);

  Actor.implementation.prototype.toCompendium = keepID(Actor.implementation.prototype.toCompendium);
  Item.implementation.prototype.toCompendium = keepID(Item.implementation.prototype.toCompendium);
  JournalEntry.implementation.prototype.toCompendium = keepID(JournalEntry.implementation.prototype.toCompendium);
  Scene.implementation.prototype.toCompendium = keepID(Scene.implementation.prototype.toCompendium);
  RollTable.implementation.prototype.toCompendium = keepID(RollTable.implementation.prototype.toCompendium);



  function keepID(orig)
  {
    return function(...args)
    {
      try {
        args[1].keepId = true;
      }
      catch(e)
      {
        console.error("Error setting keepId: " + e);
      }
      return orig.bind(this)(...args);
    }
  }

  // Modify the initiative formula depending on whether the actor has ranks in the Combat Reflexes talent
  Combatant.prototype._getInitiativeFormula = function () {
    const actor = this.actor;
    let initiativeFormula = CONFIG.Combat.initiative.formula || game.system.initiative;

    if (!actor) return initiativeFormula;



    let args = { initiative: initiativeFormula };
    actor.runScripts("getInitiativeFormula", args);

    return args.initiative;
  };

    /**
   * Draw the active effects and overlay effect icons which are present upon the Token
   */
     Token.prototype.drawEffects = async function() 
     {
         const wasVisible = this.effects.visible;
         this.effects.visible = false;
         this.effects.removeChildren().forEach(c => c.destroy());
         this.effects.bg = this.effects.addChild(new PIXI.Graphics());
         this.effects.bg.visible = false;
         this.effects.overlay = null;
     
         // Categorize new effects
         const tokenEffects = this.document.effects;
         const actorEffects = this.actor?.temporaryEffects || [];
         let overlay = {
           src: this.document.overlayEffect,
           tint: null
         };
     
         // Draw status effects
         if ( tokenEffects.length || actorEffects.length ) {
           const promises = [];
     
           // Draw actor effects first
           for ( let f of actorEffects ) {
             if ( !f.icon ) continue;
             const tint = Color.from(f.tint ?? null);
             if ( f.getFlag("core", "overlay") ) {
               if ( overlay ) promises.push(this._drawEffect(overlay.src, overlay.tint));
               overlay = {src: f.icon, tint};
               continue;
             }
             promises.push(this._drawEffect(f.icon, tint,  getProperty(f, "flags.wfrp4e.value")));
           }
     
           // Next draw token effects
           for ( let f of tokenEffects ) promises.push(this._drawEffect(f, null));
           await Promise.all(promises);
         }
     
         // Draw overlay effect
         this.effects.overlay = await this._drawOverlay(overlay.src, overlay.tint);
         this.effects.bg.visible = true;
         this.effects.visible = wasVisible;
         this._refreshEffects();
       };
    
    /* -------------------------------------------- */

    /**
     * Draw a status effect icon
     * @param {string} src
     * @param {number|null} tint
     * @returns {Promise<PIXI.Sprite|undefined>}
     * @protected
     */
    Token.prototype._drawEffect = async function(src, tint, value) {
      if ( !src ) return;
      let tex = await loadTexture(src, {fallback: "icons/svg/hazard.svg"});
      let scalex = 512 / tex.width;
      let scaley = 512 / tex.height;
      let icon = new PIXI.Sprite(tex);
      if ( tint ) icon.tint = tint;

      // Add WFRPE Counter
      if(value)
      {
        let text = new PreciseText(value, game.wfrp4e.config.effectTextStyle);
        text.scale.x = 20 / scalex;
        text.scale.y = 20 / scaley;
        icon.addChild(text);
      }
      
      return this.effects.addChild(icon);
    };


//   /**
// * Handle toggling a token status effect icon
// * @private
// */
  TokenHUD.prototype._onToggleEffect = function (event, { overlay = false } = {}) {
    event.preventDefault();
    event.stopPropagation();
    let img = event.currentTarget;
    const effect = (img.dataset.statusId && this.object.actor) ?
      CONFIG.statusEffects.find(e => e.id === img.dataset.statusId) :
      img.getAttribute("src");

    if (event.button == 0)
      return this.object.incrementCondition(effect)
    if (event.button == 2)
      return this.object.decrementCondition(effect)
    //return this.object.toggleEffect(effect, {overlay});
  };


  Token.prototype.incrementCondition = async function (effect, { active, overlay = false } = {}) {
    const existing = this.actor.actorEffects.find(e => e.conditionKey === effect.id);
    if (!existing || Number.isNumeric(getProperty(existing, "flags.wfrp4e.value")))
      await this.actor.addCondition(effect.id);
    else if (existing) // Not numeric, toggle if existing
      await this.actor.removeCondition(effect.id);

    // Update the Token HUD
    if (this.hasActiveHUD) canvas.tokens.hud.refreshStatusIcons();
    return active;
  };

  Token.prototype.decrementCondition = async function (effect, { active, overlay = false } = {}) {
    await this.actor.removeCondition(effect.id);

    // Update the Token HUD
    if (this.hasActiveHUD) canvas.tokens.hud.refreshStatusIcons();
    return active;
  };
  
  /**
   * Handle JournalEntry document drop data
   * @param {DragEvent} event   The drag drop event
   * @param {object} data       The dropped data transfer data
   * @protected
   */
  NotesLayer.prototype._onDropData = async function(event, data) {
    let entry;
    const coords = this._canvasCoordinatesFromDrop(event);
    if ( !coords ) return false;
    const noteData = {x: coords[0], y: coords[1]};
    if ( data.type === "JournalEntry" ) entry = await JournalEntry.implementation.fromDropData(data);
    if ( data.type === "JournalEntryPage" ) {
      const page = await JournalEntryPage.implementation.fromDropData(data);
      entry = page.parent;
      noteData.pageId = page.id;
      noteData.flags = {anchor : data.anchor };
    }
    if ( entry?.compendium ) {
      const journalData = game.journal.fromCompendium(entry);
      entry = await JournalEntry.implementation.create(journalData);
    }
    noteData.entryId = entry?.id;
    return this._createPreview(noteData, {top: event.clientY - 20, left: event.clientX + 40});
  };

 let _NoteConfigSubmitData = NoteConfig.prototype._getSubmitData;
  
  NoteConfig.prototype._getSubmitData = function(updateData={})
  {
    let data = _NoteConfigSubmitData.bind(this)(updateData);

    data["flags.anchor"] = this.object.flags.anchor;
    return data
  }; 
}

function MooHouseRules () {

  let config = game.wfrp4e.config;


  if (game.settings.get("wfrp4e", "mooDifficulty")) {

    config.difficultyModifiers["veasy"] = 40;
    config.difficultyModifiers["easy"] = 30;
    config.difficultyModifiers["average"] = 20;
    config.difficultyModifiers["challenging"] = 0;
    config.difficultyModifiers["difficult"] = -20;
    config.difficultyModifiers["hard"] = -30;
    config.difficultyModifiers["vhard"] = -40;

    config.difficultyLabels["veasy"] = game.i18n.localize ("DIFFICULTY.MooVEasy");
    config.difficultyLabels["easy"] = game.i18n.localize ("DIFFICULTY.MooEasy");
    config.difficultyLabels["average"] = game.i18n.localize ("DIFFICULTY.Average");
    config.difficultyLabels["challenging"] = game.i18n.localize ("DIFFICULTY.Challenging");
    config.difficultyLabels["difficult"] = game.i18n.localize ("DIFFICULTY.MooDifficult");
    config.difficultyLabels["hard"] = game.i18n.localize ("DIFFICULTY.MooHard");
    config.difficultyLabels["vhard"] = game.i18n.localize ("DIFFICULTY.MooVHard");

    if (config.difficultyModifiers["futile"]) {
      config.difficultyLabels["futile"] = game.i18n.localize ("DIFFICULTY.MooFutile");
      config.difficultyModifiers["futile"] = -50;

      config.difficultyLabels["impossible"] = game.i18n.localize ("DIFFICULTY.MooImpossible");
      config.difficultyModifiers["impossible"] = -60;
    }
  }

  if (game.settings.get("wfrp4e", "mooConditions"))
  {
    config.conditionDescriptions["prone"] += game.i18n.localize ("MOO.Prone");
    config.conditionDescriptions["broken"] = game.i18n.localize ("MOO.Broken");
    config.conditionDescriptions["bleeding"] = game.i18n.localize ("MOO.Bleeding");
  }

  if (game.settings.get("wfrp4e", "mooConditionTriggers"))
  {
    config.statusEffects.forEach(e => {
      if (e.flags.wfrp4e.trigger == "endRound")
        e.flags.wfrp4e.trigger = "endTurn";
    });

    config.conditionDescriptions.bleeding = config.conditionDescriptions.bleeding.replace("Round", "Turn");
    config.conditionDescriptions.bleeding = config.conditionDescriptions.bleeding.replace("Round", "Turn");
    config.conditionDescriptions.poisoned = config.conditionDescriptions.poisoned.replace("Round", "Turn");
    config.conditionDescriptions.ablaze = config.conditionDescriptions.ablaze.replace("Round", "Turn");

  }

  if (game.settings.get("wfrp4e", "mooPenetrating"))
  {
    config.propertyHasValue.penetrating = true;
    config.qualityDescriptions.penetrating = game.i18n.localize ("MOO.Penetrating");
  }

  if (game.settings.get("wfrp4e", "mooQualities"))
  {
    config.weaponQualities.simple = game.i18n.localize ("Simple");
    config.qualityDescriptions.simple = game.i18n.localize ("MOO.Simple");
    config.propertyHasValue.simple = false;

    config.weaponQualities.momentum = game.i18n.localize ("Momentum");
    config.qualityDescriptions.momentum = game.i18n.localize ("MOO.Momentum");
    config.propertyHasValue.momentum = true;
  }

  if (game.settings.get("wfrp4e", "mooHomebrewItemChanges"))
  {
    fetch("systems/wfrp4e/moo/items.json").then(r => r.json()).then(async records => {
      for (let id in records)
      {
        let data = records[id];
        try {
          let item = await fromUuid(id);
          if (item)
          {
            item.updateSource(data);
            game.wfrp4e.utility.logHomebrew("mooHomebrewItemChanges: " + id + ` (${item.name})`);
          }
        }
        catch {
          game.wfrp4e.utility.log("Could not find item " + id);
        }
      }
      game.wfrp4e.utility.log("Compendium changes will revert if homebrew items is deactivated and the game is refreshed");
    });
    if (game.user.isGM)
    {
      ui.notifications.notify(game.i18n.localize ("MOO.Items"));
    }
  }

}

function ready () {
  Hooks.on("ready", async () => {


    Object.defineProperty(game.user, "isUniqueGM", {
      get: function () { return game.user.id == game.users.find(u => u.active && u.isGM)?.id }
    });

    CONFIG.ChatMessage.documentClass.prototype.getTest = function () {
      if (hasProperty(this, "flags.testData"))
        return game.wfrp4e.rolls.TestWFRP.recreate(this.flags.testData)   
    };
    CONFIG.ChatMessage.documentClass.prototype.getOppose = function () {
      if (hasProperty(this, "flags.wfrp4e.opposeData"))
        return new OpposedWFRP(getProperty(this, "flags.wfrp4e.opposeData"))
    };

    CONFIG.ChatMessage.documentClass.prototype.getOpposedTest = function () {
      if (hasProperty(this, "flags.wfrp4e.opposeTestData"))
        return OpposedTest.recreate(getProperty(this, "flags.wfrp4e.opposeTestData"))
    };

    CONFIG.MeasuredTemplate.documentClass.prototype.areaEffect = function () {
      if (this.getFlag("wfrp4e", "effectUuid"))
      {
        let effect = fromUuidSync(this.getFlag("wfrp4e", "effectUuid"));
        if (effect)
        {
          effect.updateSource({"flags.wfrp4e.fromMessage" : this.getFlag("wfrp4e", "messageId")});
          effect.updateSource({"flags.wfrp4e.fromArea" : this.uuid});
          return effect;
        }
      }
    };

    // Automatically disable Auto Fill Advantage if group advantage is enabled
    if (game.settings.get("wfrp4e", "useGroupAdvantage", true) && 
      game.user.isGM && 
      game.settings.get("wfrp4e", "autoFillAdvantage", true))
    {
      ui.notifications.notify(game.i18n.localize("AutoFillAdvantageDisabled"), {permanent : true});
      game.settings.set("wfrp4e", "autoFillAdvantage", false);
    }

    SocketHandlers.register();
    const doc = $(document);
    doc.on("keydown", WFRP_Utility$1._setSocketTests);
    doc.on("keyup", WFRP_Utility$1._resetSocketTests);

    const body = $("body");
    body.on("dragstart", "a.condition-chat", WFRP_Utility$1._onDragConditionLink);

    const MIGRATION_VERSION = 8;
    let needMigration = isNewerVersion(MIGRATION_VERSION, game.settings.get("wfrp4e", "systemMigrationVersion"));
    if (needMigration && game.user.isGM) {
      game.wfrp4e.migration.migrateWorld();
    }
    game.settings.set("wfrp4e", "systemMigrationVersion", MIGRATION_VERSION);

    // Some entities require other entities to be loaded to prepare correctly (vehicles and mounts)
    for (let e of game.wfrp4e.postReadyPrepare)
      e.prepareData();

    game.wfrp4e.config.PrepareSystemItems();
    CONFIG.statusEffects = game.wfrp4e.config.statusEffects;

    FoundryOverrides();
    MooHouseRules();
    canvas.tokens.placeables.forEach(t => t.drawEffects());

    game.wfrp4e.tags.createTags();

    //***** Change cursor styles if the setting is enabled *****

    if (game.settings.get('wfrp4e', 'customCursor')) {
      WFRP_Utility$1.log('Using custom cursor', true);
      if (await srcExists("systems/wfrp4e/ui/cursors/pointer.png")) {
        let link = document.createElement('link');
        link.setAttribute('rel', 'stylesheet');
        link.type = 'text/css';
        link.href = '/systems/wfrp4e/css/cursor.css';

        document.head.appendChild(link);
      }
      else {
        WFRP_Utility$1.log('No custom cursor found', true);
      }
    }
  });



}

class ChargenStage extends FormApplication {
  active = false;
  html = "";
  data = {};
  context = {};
  journalId = ""

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.id = "chargen-stage";
    options.classes = options.classes.concat("wfrp4e", "chargen");
    options.width = 1000;
    options.height = 600;
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.Title");
    options.scrollY = [".chargen-content"];
    options.cannotResubmit = false;
    return options;
  }

  
  _getHeaderButtons() {
    let buttons = super._getHeaderButtons();
      buttons.unshift(
        {
          class: "help",
          icon: "fa-solid fa-circle-question",
          onclick: async ev => this.renderJournalPage()
        });
    return buttons
  }

  async renderJournalPage()
  {
    let journalPage = await fromUuid(this.journalId);

    if (journalPage)
    {
      await journalPage.parent.sheet._render(true);
      journalPage.parent.sheet.goToPage(journalPage.id);
    }
  }

  constructor(object, options) {
    super(object, options);
    this.data = object;
  }

  async getData() {
    return { data: this.data, context: this.context };
  }

  async validate() {

    let valid = !this.options.cannotResubmit || !this.options.isCompleted; 
    if (!valid)
    {
      this.showError("StageAlreadySubmitted");
    }
    return valid
  }

  showError(key, args)
  {
    ui.notifications.error(game.i18n.format("CHARGEN.ERROR." + key, args));
  }


  updateMessage(key, args={}, string = null)
  {
    args.user = game.user.name;
    if (this.options.message)
    {
      let content = this.options.message.content;

      if (string)
        content += string;
      else
        content += game.i18n.format("CHARGEN.Message." + key, args);

     return this.options.message.update({content})
    }

  }



  // HTML to add to the char gen application
  async addToDisplay() {
    return null
  }

  static stageData() 
  {
    return {
      class: this,
      key: "stage",
      dependantOn: [],
      app: null,
      complete: false
    }
  }

  _updateObject(event, formData) {
    this.options.complete(this.options.index);
  }

   async _onSubmit(...args) {
    args[0].preventDefault();
    if (await this.validate())
    {
      this.options.isCompleted = true;
      super._onSubmit(...args);
    }
  }

  activateListeners(html) {
    super.activateListeners(html);
    html.on("click", '.chargen-button, .chargen-button-nostyle', this.onButtonClick.bind(this));
    html.on("click", '.item-lookup', this._onItemLookupClicked.bind(this));

    // Autoselect entire text 
    html.find("input").on("focusin", ev => {
      ev.target.select();
    });
  }


  onButtonClick(ev) {
    let type = ev.currentTarget.dataset.button;
    if (typeof this[type] == "function") {
      this[type](ev);
    }
  }

  async _onItemLookupClicked(ev) {
    let itemType = $(ev.currentTarget).attr("data-type");
    let openMethod = $(ev.currentTarget).attr("data-open") || "sheet"; // post or sheet
    let name = $(ev.currentTarget).attr("data-name") || ev.currentTarget.text; // Use name attribute if available, otherwis, use text clicked.
    let item;
    if (name)
      item = await WFRP_Utility$1.find(name, itemType);

    if (item) {
      if (openMethod == "sheet")
        item.sheet.render(true);

      else
        item.postItem();
    }
  }



}

class SpeciesStage extends ChargenStage {

  journalId = "Compendium.wfrp4e-core.journal-entries.IQ0PgoJihQltCBUU.JournalEntryPage.l0f11ypRjH9sR48Q"

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 450;
    options.height = 550;
    options.classes.push("species");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageSpecies");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageSpecies"); }


  get template() {
    return "systems/wfrp4e/templates/apps/chargen/species.hbs";
  }


  context = {
    species: "",
    subspecies: "",
    exp: 0
  };


  async getData() {
    let data = await super.getData();

    data.context = this.context;

    let speciesTable = game.wfrp4e.tables.findTable("species");

    if (!speciesTable)
    {
      ui.notifications.error(game.i18n.localize("CHARGEN.ERROR.SpeciesTable"));
      throw new Error (game.i18n.localize("CHARGEN.ERROR.SpeciesTable"))
    }

    data.species = {};

    for (let result of speciesTable.results)
    {
      let speciesKey = game.wfrp4e.utility.findKey(result.text, game.wfrp4e.config.species);
      if (speciesKey)
      {
        data.species[speciesKey] = result.text;
      }
    }

    data.speciesDisplay = game.wfrp4e.config.species[this.context.species];

    if (this.context.species && game.wfrp4e.config.subspecies[this.context.species]) {
      data.subspeciesChoices = game.wfrp4e.config.subspecies[this.context.species];
    }

    if (this.context.subspecies) {
      data.speciesDisplay += ` (${game.wfrp4e.config.subspecies[this.context.species][this.context.subspecies]?.name})`;
    }

    return data;
  }


  async validate() {
    let valid = super.validate();
    if (!this.context.species)
    {
      this.showError("SpeciesSubmit");
      valid = false;
    }
    return valid
  }


  /**
   * The user is allowed to freely click and choose species, but can only roll for it one time.
   * After species is rolled, user can click and choose a different species, but cannot go back and roll again
   */
  activateListeners(html) {
    super.activateListeners(html);
    html.on("click", '.species-select', this.onSelectSpecies.bind(this));
    html.on("click", '.subspecies-select', this.onSelectSubspecies.bind(this));
  }


  // Set roll, unselect whatever user has chosen
  async onRollSpecies(event) {
    event.stopPropagation();
    this.context.exp = 20;
    this.context.roll = await game.wfrp4e.tables.rollTable("species");
    this.context.choose = false;
    this.updateMessage("Rolled", {rolled : this.context.roll.result});
    this.setSpecies(this.context.roll.species);
  }

  // Set chosen species, but don't unset "roll" (prevents users from rolling again after they've rolled once)
  onSelectSpecies(event) {
    this.context.exp = 0;
    this.context.choose = event.currentTarget.dataset.species;
    this.updateMessage("Chosen", {chosen : game.wfrp4e.config.species[this.context.choose]});
    this.setSpecies(this.context.choose);
  }


  onSelectSubspecies(event) {
    this.setSpecies(this.context.species, event.currentTarget.dataset.subspecies);
  }


  _updateObject(event, formData) {
    this.data.species = this.context.species;
    this.data.subspecies = this.context.subspecies;
    this.data.exp.species = this.context.exp;
    super._updateObject(event, formData);

  }


  setSpecies(species, subspecies) {
    this.context.species = species;
    if (subspecies) {
      this.context.subspecies = subspecies;
    }
    else if (Object.keys(game.wfrp4e.config.subspecies[species] || {})?.length == 1) {
      this.context.subspecies = Object.keys(game.wfrp4e.config.subspecies[species])[0];
    }
    else {
      this.context.subspecies = "";
    }
    this.render(true);
  }
}

class CareerStage extends ChargenStage {
  journalId = "Compendium.wfrp4e-core.journal-entries.IQ0PgoJihQltCBUU.JournalEntryPage.bS2sxusEp1FEqmRk"
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 400;
    options.height = 670;
    options.classes.push("career");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageCareer");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageCareer"); }

  constructor(...args) {
    super(...args);
    this.careers = this.loadCareers();
    this.context.step = 0;
    this.context.careers = [];
    this.context.replacements = [];
    this.context.career = null;
    this.context.exp = 0;
  }


  get template() {
    return "systems/wfrp4e/templates/apps/chargen/career.hbs";
  }


  async rollCareers(event) {
    this.context.step++;

    // First step, roll 1 career
    if (this.context.step == 1) {
      this.context.exp = 50;
      await this.addCareerChoice();
      // QoL: Upon the first career roll, automatically set the selected career to it
      this.context.career = this.context.careers[0];
    }
    // Second step, Roll 2 more careers
    if (this.context.step == 2) {
      this.context.exp = 25;
      await this.addCareerChoice(2);
    }
    // Third step, keep rolling careers
    if (this.context.step >= 3) {
      this.context.exp = 0;
      await this.addCareerChoice();
    }
  }

  _updateObject(event, formData) {
    this.data.items.career = this.context.career.toObject();
    this.data.exp.career = this.context.exp;

    this.data.items.career.system.current.value = true;
    super._updateObject(event, formData);

  }

  async getData() {
    let data = await super.getData();
    for (let c of this.context.careers.concat(this.context.replacements)) {
      c.enriched = await TextEditor.enrichHTML(c.system.description.value, { async: true });
    }
    data.showChooseButton = this.context.replacements.length + this.context.careers.length > 1;
    return data
  }


  async _onDrop(ev) {
    let dragData = JSON.parse(ev.dataTransfer.getData("text/plain"));

    if (dragData.type == "Item") {
      let career = await Item.implementation.fromDropData(dragData);

      if (career.type != "career")
        return

      // If career level is not T1, find the T1 career and use that instead
      else if (career.system.level.value > 1)
      {
        let careerT1 = await this.findT1Careers(career.system.careergroup.value);
        if (careerT1[0])
          career = careerT1[0];
      }

      this.context.step = 4;
      this.context.exp = 0;
      this.context.careers.push(career);
      this.context.career = career;
      this.updateMessage("Chosen", {chosen : career.name});
    }
    this.render(true);
  }

  async validate() {
    let valid = super.validate();
    if (!this.context.career)
    {
      this.showError("CareerSubmit");
      valid = false;
    }
    return valid
  }

  async addCareerChoice(number = 1) {
    let rollSpecies = this.data.species;

    // If subspecies table is found, use that
    if (this.data.subspecies && game.wfrp4e.tables.findTable("career", rollSpecies + "-" + this.data.subspecies))
      rollSpecies += "-" + this.data.subspecies;
    

    // If Human (no subspecies) and no "human" career table exists, use `human-reiklander` if it exists
    // This is backwards compatibility (human-reiklander table changed to just human)
    if (this.data.species == "human" && !game.wfrp4e.tables.findTable("career", "human") && game.wfrp4e.tables.findTable("career", "human-reiklander"))
    {
      rollSpecies = "human-reiklander";
    }

    for (let i = 0; i < number; i++) {
      let newCareerRolled = await game.wfrp4e.tables.rollTable("career", {}, rollSpecies);
      let newCareerName = newCareerRolled.text;

      // Some books that add careers define replacement options, such as (If you roll career X you can use this new career Y (e.g. Soldier to Ironbreaker))
      // If there's a replacement option for a given career, add that replacement career too
      let replacementOptions = game.wfrp4e.config.speciesCareerReplacements[this.data.species]?.[newCareerName] || [];
      replacementOptions = replacementOptions.concat(game.wfrp4e.config.speciesCareerReplacements[`${this.data.species}-${this.data.subspecies}`]?.[newCareerName] || []);

      let t1Careers = await this.findT1Careers(newCareerName);
      
      this.context.careers = this.context.careers.concat(t1Careers);
      if (replacementOptions.length > 0)
      {
        let replacements = await this.findT1Careers(replacementOptions);
        this.context.replacements = this.context.replacements.concat(replacements);
      }

      this.updateMessage("Rolled", {rolled : t1Careers.map(i => i.name).join(", ")});
    }
    this.render(true);
  }

  // Career selected, move on to the next step
  async selectCareer(ev) {
    let careerItem = await this.findT1Careers(ev.currentTarget.dataset.career);
    if (careerItem) {
      this.context.career = careerItem[0];
      this.updateMessage("Chosen", {chosen : this.context.career.name});

    }
    else {
      throw new Error(gam.i18n.format("CHARGEN.ERROR.CareerItem", {career : ev.currentTarget.dataset.career}));
    }
    this.render(true);
  }

  /**
   * Given a career name, find the T1 item for that career
   * "Witch Hunter" -> Interrogator Item
   *
   * @param {String} careerName Name of career to be posted
   */
  async findT1Careers(careerNames) {

    let careers = await this.careers;
    let careersFound = [];
    
    if (typeof careerNames == "string")
      careerNames = [careerNames];

    // Find the tier 1 rank that corresponds with the career name
    for (let c of careers) {
      if (careerNames.includes(c.system.careergroup.value) && c.system.level.value == 1)
        careersFound.push(c);
      if (careersFound.length == careerNames.length)
        break;
    }

    if (careerNames.length != careersFound.length)
      this.showError("CareerItems", {num : careerNames.length - careersFound.length, careers : careerNames.toString()});
    return careersFound;
  }

  async loadCareers()
  {
    let packs = game.wfrp4e.tags.getPacksWithTag("career");
    let careers = game.items.filter(i => i.type == "career");

    let counter = 1;
    let num = packs.length;
    for (let pack of packs)
    {
      SceneNavigation.displayProgressBar({label: game.i18n.localize("CHARGEN.Career.LoadingCareers"), pct: Math.round((counter / num) * 100) });
      counter++;
      careers = careers.concat((await pack.getDocuments()).filter(i => i.type == "career"));
    }

    return careers;
  }

  
  activateListeners(html) {
    super.activateListeners(html);
    const dragDrop = new DragDrop({
      dropSelector: '.chargen-content',
      permissions: { drop: () => true },
      callbacks: { drop: this._onDrop.bind(this) },
    });

    dragDrop.bind(html[0]);
  }
}

const Step = {NOT_STARTED : 0, FIRST_ROLL : 1, SWAPPING : 2, REROLL : 3, ALLOCATING : 4};

class AttributesStage extends ChargenStage {

  journalId = "Compendium.wfrp4e-core.journal-entries.IQ0PgoJihQltCBUU.JournalEntryPage.GaZa9sU4KjKDswMr"
  static get defaultOptions() {
  const options = super.defaultOptions;
    options.resizable = true;
    options.width = 400;
    options.height = 785;
    options.classes.push("career");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageAttributes");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageAttributes"); }
  get template() { return "systems/wfrp4e/templates/apps/chargen/attributes.hbs"; }



  constructor(...args) {
    super(...args);

    // Step 1: First roll, Step 2: Swapping, Step 3: Reroll, Step 4: Allocating 
    this.context.step = Step.NOT_STARTED;
    this.context.characteristics = {
      ws: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      bs: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      s: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      t: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      i: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      ag: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      dex: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      int: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      wp: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
      fel: { formula: "", roll: 0, add: 0, total: 0, allocated: 0, advances: 0 },
    },
      this.context.allocation = {
        total: 100,
        spent: 0
      };
    this.context.meta = {
      fate: { base: 0, allotted: 0, total: 0 },
      resilience: { base: 0, allotted: 0, total: 0 },
      extra: 0,
      left: 0
    };
    this.context.move = 4;
    this.context.exp = 50;
  }

  async getData() {
    let data = await super.getData();
    this.calculateTotals();

    if (this.context.step <= Step.FIRST_ROLL) {
      this.context.exp = 50;
    }
    else if (this.context.step == Step.SWAPPING && !this.context.hasRerolled) {
      this.context.exp = 25;
    }

    else
      this.context.exp = 0;

    return data;
  }

  async rollAttributes(ev, step) {
    if (step)
      this.context.step = step;
    else
      this.context.step++;

    if (this.context.step == Step.FIRST_ROLL)
    {
      await this.updateMessage("RolledCharacteristics");
    }
    else if (this.context.step == Step.REROLL)
    {
      await this.updateMessage("ReRolledCharacteristics");
    }

    let species = this.data.species;
    let subspecies = this.data.subspecies;

    let characteristicFormulae = game.wfrp4e.config.speciesCharacteristics[species];
    if (subspecies && game.wfrp4e.config.subspecies[species][subspecies].characteristics)
      characteristicFormulae = game.wfrp4e.config.subspecies[species][subspecies].characteristics;

    for (let ch in this.context.characteristics) {
      let [roll, bonus] = characteristicFormulae[ch].split("+").map(i => i.trim());
      roll = roll || "2d10";
      bonus = bonus || 0;
      this.context.characteristics[ch].formula = characteristicFormulae[ch];
      this.context.characteristics[ch].roll = (await new Roll(roll).roll({async : true})).total;
      this.context.characteristics[ch].add = bonus;
      this.context.characteristics[ch].allocated = 0;
    }

    this.context.rolledCharacteristics = duplicate(this.context.characteristics); // Used to restore roll if user goes back a step

    this.context.movement = game.wfrp4e.config.speciesMovement[species],
      this.context.meta.fate.base = game.wfrp4e.config.speciesFate[species],
      this.context.meta.resilience.base = game.wfrp4e.config.speciesRes[species],
      this.context.meta.extra = game.wfrp4e.config.speciesExtra[species];


    this.calculateTotals();

    this.updateMessage(undefined, undefined, `
    <div class="flexcol" style="text-align: center">
      <div class="flexrow">
        <div>
          ${Object.keys(this.context.characteristics)
            .map(i => game.wfrp4e.config.characteristicsAbbrev[i])
            .join("</div><div>")
          }
        </div>
      </div>
      <div class="flexrow">
        <div>
        ${Object.values(this.context.characteristics)
          .map(i => i.total)
          .join("</div><div>")
        }
        </div>
      </div>
    </div>
    `);

    this.render();
  }

  calculateTotals() {
    this.context.allocation.spent = 0;
    this.context.advances = 0;
    for (let ch in this.context.characteristics) {
      let characteristic = this.context.characteristics[ch];
      let base = this.context.step == Step.ALLOCATING ? characteristic.allocated : characteristic.roll;
      characteristic.initial = base + Number(characteristic.add);
      characteristic.total = characteristic.initial + Number(characteristic.advances);
      this.context.allocation.spent += characteristic.allocated;
      this.context.advances += Number(characteristic.advances); // Used for validation, cannot be above 5
    }
    let fate = this.context.meta.fate;
    let resilience = this.context.meta.resilience;
    fate.total = fate.base + fate.allotted;
    resilience.total = resilience.base + resilience.allotted;
    this.context.meta.left = this.context.meta.extra - (resilience.allotted + fate.allotted);
  }

  validateTotals() {
    this.calculateTotals();
    let valid = true;
    if (this.context.meta.left < 0)
    {
      this.showError("MetaAllocation");
      valid = false;
    }
    if (this.context.allocation.spent > 100)
    {
      this.showError("CharacteristicAllocation");
      valid = false;
    }

    if (this.context.advances > 5)
    {
      this.showError("CharacteristicAdvances");
      valid = false;
    }

    if (this.context.step == Step.ALLOCATING)
    {
      let inBounds = true;
      for (let ch in this.context.characteristics) {
        let characteristic = this.context.characteristics[ch];
        if (characteristic.allocated < 4 || characteristic.allocated > 18)
          inBounds = false;
      }

      if(!inBounds)
      {
        this.showError("CharacteristicAllocationBounds");
        valid = false;
      }
    }


    return valid
  }

  validate() {
    return super.validate() && this.validateTotals();
  }

  swap(ch1, ch2) {
    if (this.context.step < Step.SWAPPING)
      this.context.step = Step.SWAPPING;

    let ch1Roll = duplicate(this.context.characteristics[ch1].roll);
    let ch2Roll = duplicate(this.context.characteristics[ch2].roll);

    this.context.characteristics[ch1].roll = ch2Roll;
    this.context.characteristics[ch2].roll = ch1Roll;

    this.updateMessage("SwappedCharacteristics", {ch1 : game.wfrp4e.config.characteristics[ch1], ch2: game.wfrp4e.config.characteristics[ch2]});

    this.render(true);
  }

  activateListeners(html) {
    super.activateListeners(html);
    const dragDrop = new DragDrop({
      dragSelector: '.ch-drag',
      dropSelector: '.ch-drag',
      permissions: { dragstart: () => true, drop: () => true },
      callbacks: { drop: this.onDropCharacteristic.bind(this), dragstart: this.onDragCharacteristic.bind(this) },
    });

    dragDrop.bind(html[0]);


    html.find(".meta input").on("change", (ev) => {
      // Bind value to be nonnegative
      ev.currentTarget.value = Math.max(0, Number(ev.currentTarget.value));
      this.context.meta[ev.currentTarget.dataset.meta].allotted = Number(ev.currentTarget.value);
      this.render(true);
    });

    html.find(".ch-allocate").on("change", (ev) => {
      // Bind value to be nonnegative
      ev.currentTarget.value = Math.max(0, Number(ev.currentTarget.value));
      if (ev.currentTarget.value > 18 || ev.currentTarget.value < 4)
      {
        this.showError("CharacteristicAllocationBounds");
        ev.currentTarget.value = 0;
        return 
      }
      this.context.characteristics[ev.currentTarget.dataset.ch].allocated = Number(ev.currentTarget.value);
      this.render(true);
    });

    html.find(".ch-advance").on("change", ev => {
      // Bind value to be nonnegative
      ev.currentTarget.value = Math.max(0, Number(ev.currentTarget.value));
      this.context.characteristics[ev.currentTarget.dataset.ch].advances = Number(ev.currentTarget.value);
      this.render(true);
    });
  }

  reroll(ev) {
    this.context.hasRerolled = true;
    // Set to step 3
    this.rollAttributes(ev, 3);
  }

  allocate(ev) {
    this.context.step = Step.ALLOCATING;
    this.updateMessage("AllocateCharacteristics");

    this.render(true);
  }

  rearrange(ev)
  {
    this.context.step = Step.SWAPPING;
    this.render(true);
  }

  // Cancel allocation or swapping, restore to the last rolled characteristic
  cancel(ev)
  {
    if (this.context.hasRerolled)
    this.context.step = Step.REROLL;
    else 
      this.context.step = Step.FIRST_ROLL;
    this.context.characteristics = duplicate(this.context.rolledCharacteristics);
    this.render(true);
  }

  _updateObject(ev, formData) {
    for (let ch in this.context.characteristics) {
      this.data.characteristics[ch] = { initial: this.context.characteristics[ch].initial, advances: this.context.characteristics[ch].advances };
    }
    this.data.fate.base = this.context.meta.fate.base;
    this.data.fate.allotted = this.context.meta.fate.allotted;
    this.data.resilience.base = this.context.meta.resilience.base;
    this.data.resilience.allotted = this.context.meta.resilience.allotted;
    this.data.move = game.wfrp4e.config.speciesMovement[this.data.species];
    this.data.exp.characteristics = this.context.exp;
    super._updateObject(ev, formData);
  }

  onDragCharacteristic(ev) {
    ev.dataTransfer.setData("text/plain", JSON.stringify({ ch: ev.currentTarget.dataset.ch }));
  }

  onDropCharacteristic(ev) {
    if (ev.currentTarget.dataset.ch) {
      let ch = JSON.parse(ev.dataTransfer.getData("text/plain")).ch;
      this.swap(ev.currentTarget.dataset.ch, ch);
    }
  }
}

class SkillsTalentsStage extends ChargenStage {
  journalId = "Compendium.wfrp4e-core.journal-entries.IQ0PgoJihQltCBUU.JournalEntryPage.f5Y4XenZVtDU2GUo"
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 450;
    options.height = 800;
    options.classes.push("skills-talents");
    options.minimizable = true;
    options.cannotResubmit = true;
    options.title = game.i18n.localize("CHARGEN.StageSkillsTalents");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageSkillsTalents"); }


  constructor(...args) {
    super(...args);
    let { skills, talents } = WFRP_Utility$1.speciesSkillsTalents(this.data.species, this.data.subspecies);

    for (let skill of skills) {
      this.context.speciesSkills[skill] = 0;
    }

    for (let talent of talents) {

      // Set random talent count
      if (Number.isNumeric(talent)) {
        this.context.speciesTalents.randomCount = Number(talent);
      }


      // Comma means it's a choice
      else if (talent.includes(",")) {
        this.context.speciesTalents.choices.push(talent);
        this.context.speciesTalents.chosen.push("");
      }

      else
        this.context.speciesTalents.normal.push(talent);
    }


    for (let skill of this.data.items.career.system.skills) {
      this.context.careerSkills[skill] = 0;
    }

    for (let talent of this.data.items.career.system.talents) {
      this.context.careerTalents[talent] = false;
    }
  }


  get template() {
    return "systems/wfrp4e/templates/apps/chargen/skills-talents.hbs";
  }


  context = {
    speciesSkills: {},
    speciesTalents: {
      normal: [],
      chosen: [],
      random: [],
      rolled: false,
      randomCount: 0,
      choices: [],
    },
    careerSkills: {},
    careerTalents: {}
  };

  async getData() {
    let data = await super.getData();
    data.speciesSkillAllocation = {
      0: [],
      3: [],
      5: []
    };

    data.randomCount = this.context.speciesTalents.randomCount - this.context.speciesTalents.random.length;

    // Sort into arrays
    for (let skill in this.context.speciesSkills) {
      data.speciesSkillAllocation[this.context.speciesSkills[skill]].push(skill);
    }

    data.talents = {
      normal: this.context.speciesTalents.normal,

      // Separate choices ("Savvy,Suave") into {name : Suave, chosen : true/false}, {name : Savvy, chosen : true/false}
      choices: this.context.speciesTalents.choices.map((choice, index) => {
        return choice.split(",").map(i => {
          let name = i.trim();
          let regex = /random\[(\d)\]/gm;
          let match = Array.from(name.matchAll(regex))[0];
          let chosen = this.context.speciesTalents.chosen[index] == name;

          // Check if talent is an additional random (syntax => random[x] where x is the number of random talents to roll)
          if (match) {
            if (match[1] == "1")
              name = game.i18n.localize("CHARGEN.AdditionalRandomTalent");
            else
              name = game.i18n.format("CHARGEN.XAdditionalRandomTalents", { X: match[1] });

            chosen = this.context.speciesTalents.chosen[index] == name;

            // If random is selected, add number to random talents to roll
            if (chosen) {
              data.randomCount += Number(match[1]);
            }
          }
          return {
            name,
            chosen: this.context.speciesTalents.chosen[index] == name
          };
        });
      }),
      // Determine duplicates later
      random: this.context.speciesTalents.random.map(i => {
        return {
          name : i,
          duplicate: false
        }
      }),
      chosen: this.context.speciesTalents.chosen
    };


    // If talent is found in chosen talents or random talents more than once, mark as duplicate
    data.talents.duplicates = 
    data.talents.random.filter(talent => data.talents.random.filter(dup => dup.name == talent.name).length >= 2) // Check random talents
      .concat(data.talents.random.filter(talent => data.talents.chosen.filter(chosen => chosen == talent.name).length > 0)); // Check chosen talents

    data.talents.duplicates.forEach(dupTalent => dupTalent.duplicate = true);

    // This case happens when user chose to roll an additional random talent, then changed their mind. Remove the extra talents
    if (data.randomCount < 0) {
      let spliceIndex = this.context.speciesTalents.random.length - Math.abs(data.randomCount);
      this.context.speciesTalents.random.splice(spliceIndex); // Remove talents in context
      data.talents.random.splice(spliceIndex);                // Reflect removed talents in template data
      data.randomCount = this.context.speciesTalents.randomCount - this.context.speciesTalents.random.length; // Should be 0
    }

    data.careerSkills = this.context.careerSkills;
    data.careerTalents = this.context.careerTalents;
    data.pointsAllocated = 40 - Object.values(this.context.careerSkills).reduce((prev, current) => prev + current, 0);

    return data;
  }

  async _updateObject(ev, formData) {
    // Merge career/species skill advances into data
    for (let skill in this.context.speciesSkills) {
      if (isNaN(this.data.skillAdvances[skill]))
        this.data.skillAdvances[skill] = 0;
      this.data.skillAdvances[skill] += this.context.speciesSkills[skill];
    }
    for (let skill in this.context.careerSkills) {
      if (isNaN(this.data.skillAdvances[skill]))
        this.data.skillAdvances[skill] = 0;
      this.data.skillAdvances[skill] += this.context.careerSkills[skill];
    }
    let careerTalent;
    for (let talent in this.context.careerTalents) {
      if (this.context.careerTalents[talent])
        careerTalent = talent;
    }

    let talents = await Promise.all((this.context.speciesTalents.normal.concat(this.context.speciesTalents.chosen, this.context.speciesTalents.random, careerTalent)).map(async i => {
      try {
        return await WFRP_Utility$1.findTalent(i);
      }
      catch(e)
      {
        // Ignore not found.
        // This is mainly important because when a user chooses "Additional Random Talent" as a talent, it won't be found
      }
    }));
    this.data.items.talents = talents.filter(i => i);
    super._updateObject(ev, formData);

  }


  async validate() {
    let valid = super.validate();

    if (!this.validateSkills())
      valid = false;

    if (this.context.speciesTalents.randomCount > 0 && !this.context.speciesTalents.rolled) {
      this.showError("SpeciesTalentsNotRolled");
      valid = false;
    }

    if (this.context.speciesTalents.chosen.filter(i => i).length < this.context.speciesTalents.choices.length) {
      this.showError("SpeciesTalentsNotChosen");
      valid = false;
    }

    if (Object.values(this.context.careerTalents).every(i => i == false)) {
      this.showError("CareerTalentNotChosen");
      valid = false;
    }

    if (Object.values(this.context.careerSkills).reduce((prev, current) => prev + current, 0) > 40) {
      this.showError("CareerSkillAllocation");
      valid = false;
    }

    return valid
  }

  validateSkills() {
    let skills = Object.values(this.context.speciesSkills);
    let threes = skills.filter(i => i == 3).length;
    let fives = skills.filter(i => i == 5).length;

    if (threes > 3 || fives > 3) {
      this.showError("SpeciesSkillAdvancements");
      return false
    }
    else return true
  }



  activateListeners(html) {
    super.activateListeners(html);
    const dragDrop = new DragDrop({
      dragSelector: '.drag-skill',
      dropSelector: '.drag-area',
      permissions: { dragstart: () => true, drop: () => true },
      callbacks: { drop: this.onDropSkill.bind(this), dragstart: this.onDragSkill.bind(this) },
    });

    dragDrop.bind(html[0]);


    html.find(".talent-choice input").click(ev => {
      let target = ev.currentTarget.name?.split("-")[1];

      if (target == "career") {
        for (let talent of this.data.items.career.system.talents) {
          this.context.careerTalents[talent] = (talent == ev.currentTarget.value);
        }
      }
      else {
        this.context.speciesTalents.chosen[target] = ev.currentTarget.value;
      }

      this.render(true);

    });

    html.find(".career-skills input").change(ev => {
      ev.currentTarget.value = Math.max(0, Number(ev.currentTarget.value));
      if (ev.currentTarget.value > 10) {
        ev.currentTarget.value = 0;
        this.showError("CareerSkillAllocationBounds");
      }
      this.context.careerSkills[ev.currentTarget.dataset.skill] = Number(ev.currentTarget.value);
      this.render(true);
    });

    html.find(".reroll-duplicate").click(async ev => {
      ev.stopPropagation();
      let index = Number(ev.currentTarget.dataset.index);
      let talent = await game.wfrp4e.tables.rollTable("talents");
      this.context.speciesTalents.random[index] = talent.text;
      this.updateMessage("RerolledDuplicateTalent", { rolled: talent.text });
      this.render(true);
    });
  }


  onDropSkill(ev) {
    let skill = JSON.parse(ev.dataTransfer.getData("text/plain")).skill;
    this.context.speciesSkills[skill] = Number(ev.currentTarget.dataset.advance);
    if (!this.validateSkills()) {
      this.context.speciesSkills[skill] = 0;
    }

    this.render(true);
  }

  onDragSkill(ev) {
    ev.dataTransfer.setData("text/plain", JSON.stringify({ skill: ev.currentTarget.textContent.trim() }));
  }

  async rollRandomTalents(ev) {
    this.context.speciesTalents.rolled = true;
    let number = Number(ev.currentTarget.dataset.number) || 0;
    for (let i = 0; i < number; i++) {
      let talent = await game.wfrp4e.tables.rollTable("talents");
      this.context.speciesTalents.random.push(talent.text);
    }
    this.updateMessage("Rolled", { rolled: this.context.speciesTalents.random.join(", ") });
    this.render(true);
  }
}

class TrappingStage extends ChargenStage {
  journalId = "Compendium.wfrp4e-core.journal-entries.IQ0PgoJihQltCBUU.JournalEntryPage.hQipqLYlbBEjJEWL"
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 450;
    options.height = 600;
    options.classes.push("trappings");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageTrappings");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageTrappings"); }

  get template() {
    return "systems/wfrp4e/templates/apps/chargen/trappings.hbs";
  }

  constructor(...args) {
    super(...args);

    this.context.classStrings = game.wfrp4e.config.classTrappings[this.data.items.career.system.class.value]?.split(",") || [];
    this.context.careerStrings = this.data.items.career.system.trappings;

    if (this.context.classStrings.length == 0) {
      this.showError("ClassTrappingsNotFound", { class: this.data.items.career.system.class.value });
    }

    this.context.class = Promise.all(this.context.classStrings.map(i => WFRP_Utility$1.find(i.trim(), game.wfrp4e.config.trappingItems)));
    this.context.career = Promise.all(this.context.careerStrings.map(i => WFRP_Utility$1.find(i, game.wfrp4e.config.trappingItems)));
  }

  context = {
    items: [],
    class: [],
    career: [],
    missing: null,
    added: []
  };

  async getData() {
    let data = await super.getData();
    this.context.class = await this.context.class;
    this.context.career = await this.context.career;

    if (!this.context.missing) {
      this.context.missing = [];

      this.context.class.forEach((trapping, i) => {
        if (!trapping) {
          this.context.missing.push({
            string: this.context.classStrings[i],
            choice: "keep"
          });
        }
      });

      this.context.career.forEach((trapping, i) => {
        if (!trapping) {
          this.context.missing.push({
            string: this.context.careerStrings[i],
            choice: "keep"
          });
        }
      });
    }

    this.context.class = this.context.class.filter(i => i);
    this.context.career = this.context.career.filter(i => i);
    return data;
  }

  activateListeners(html) {
    super.activateListeners(html);
    const dragDrop = new DragDrop({
      dropSelector: '.chargen-content',
      permissions: { drop: () => true },
      callbacks: { drop: this._onDrop.bind(this) },
    });

    dragDrop.bind(html[0]);

    html.find(".missing-trapping-choice input").click(ev => {
      let name = ev.currentTarget.name;
      let index = Number(name.split("-")[1]);
      this.context.missing[index].choice = ev.currentTarget.value;
      this.render(true);
    });

    html.find(".remove-trapping").click(ev => {
      let index = Number(ev.currentTarget.dataset.index);
      this.context.added.splice(index, 1);
      this.render(true);

    });

  }

  async _onDrop(ev) {
    let dragData = JSON.parse(ev.dataTransfer.getData("text/plain"));

    if (dragData.type == "Item") {
      this.context.added.push(await Item.implementation.fromDropData(dragData));
    }
    this.render(true);
  }

  _updateObject(ev, formData) {

    // Of the trappings not found, only keep the ones that are marked as "keep", and create a new miscellaneous trapping item for them
    let missing = this.context.missing.filter(i => i.choice == "keep").map(i => new ItemWfrp4e({ name: i.string, type: "trapping", system: { "trappingType.value": "misc" } }));

    this.data.items.trappings = missing.concat(this.context.class, this.context.career, this.context.added);
    super._updateObject(ev, formData);
  }
}

class DetailsStage extends ChargenStage {
  journalId = "Compendium.wfrp4e-core.journal-entries.IQ0PgoJihQltCBUU.JournalEntryPage.Q4C9uANCqPzlRKFD"
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.resizable = true;
    options.width = 500;
    options.height = 700;
    options.classes.push("details");
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.StageDetails");
    return options;
  }

  static get title() { return game.i18n.localize("CHARGEN.StageDetails"); }

  get template() {
    return "systems/wfrp4e/templates/apps/chargen/details.hbs";
  }

  constructor(...args) {
    super(...args);
  }
  context = {
    gender: ""
  };


  async getData() {
    let data = await super.getData();
    return data;
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find(".roll-details").click(async (ev) => {
      let type = ev.currentTarget.dataset.type;
      if (this[type]) {
        let value = await this[type]();
        let input = $(ev.target).parents(".detail-form").find("input")[0];
        input.value = value;
      }
    });

    html.find("input[name='gender']").change(ev => {
      this.context.gender = ev.currentTarget.value; // Need to store gender to pass to name generation
    });
  }

  _updateObject(ev, formData) {
    this.data.details.name = formData.name;
    this.data.details.gender = formData.gender;
    this.data.details.age = formData.age;
    this.data.details.height = formData.height;
    this.data.details.eyes = formData.eyes;
    this.data.details.hair = formData.hair;
    this.data.details.motivation = formData.motivation;
    this.data.details.short = formData.short;
    this.data.details.long = formData.long;
    super._updateObject(ev, formData);
  }

  rollName() {
    return NameGenWfrp.generateName({ species: this.data.species, gender: this.context.gender });
  }
  async rollAge() {
    return (await new Roll(game.wfrp4e.config.speciesAge[this.data.species]).roll({async: true})).total;
  }
  async rollHeight() {
    let heightRoll = (await new Roll(game.wfrp4e.config.speciesHeight[this.data.species].die).roll({async : true})).total;
    let hFeet = game.wfrp4e.config.speciesHeight[this.data.species].feet;
    let hInches = game.wfrp4e.config.speciesHeight[this.data.species].inches + heightRoll;
    hFeet += Math.floor(hInches / 12);
    hInches = hInches % 12;
    return `${hFeet}'${hInches}`;
  }
  async rollEyes() {
    return (await game.wfrp4e.tables.rollTable("eyes", {}, this.data.species)).result;
  }
  async rollHair() {
    return (await game.wfrp4e.tables.rollTable("hair", {}, this.data.species)).result;
  }
  async rollMotivation() {
    return (await game.wfrp4e.tables.rollTable("motivation")).result;
  }
}

/**
 * This class is the center of character generation through the chat prompts (started with /char)
 */
class CharGenWfrp4e extends FormApplication {
  constructor(...args) {
    super(...args);
    this.data = {
      species: null,
      subspecies: null,
      exp: {
        species: 0,
        characteristics: 0,
        career: 0
      },
      items: {
        career: null,
      },
      skillAdvances: {

      },
      characteristics: {
        ws: {initial: 0, advances : 0},
        bs: {initial: 0, advances : 0},
        s: {initial: 0, advances : 0},
        t: {initial: 0, advances : 0},
        i: {initial: 0, advances : 0},
        ag: {initial: 0, advances : 0},
        dex: {initial: 0, advances : 0},
        int: {initial: 0, advances : 0},
        wp: {initial: 0, advances : 0},
        fel: {initial: 0, advances : 0}
      },
      fate: { base: 0, allotted: 0 },
      resilience: { base: 0, allotted: 0 },
      move: 4,
      details : {
        gender : "",
        name : "",
        age : null,
        height : "",
        hair : "",
        eyes : "",
        short : "",
        long : "",
      },
      misc : {
        // Object for stages to add whatever data they wish to be merged into actor data
        // e.g. "system.details.motivation.value" : "Courage"
      }
    };
    this.stages = [
      {
        class: SpeciesStage,
        key: "species",
        dependantOn: [],
        app: null,
        complete: false
      },
      {
        class: CareerStage,
        key: "career",
        dependantOn: ["species"],
        app: null,
        complete: false
      },
      {
        class: AttributesStage,
        key: "attributes",
        dependantOn: ["career"],
        app: null,
        complete: false
      },
      {
        class: SkillsTalentsStage,
        key: "skills-talents",
        dependantOn: ["career"],
        app: null,
        complete: false
      },
      {
        class: TrappingStage,
        app: null,
        key: "trappings",
        dependantOn: ["career"],
        complete: false
      },
      {
        class: DetailsStage,
        app: null,
        key: "details",
        dependantOn: ["species"],
        complete: false
      }
    ];
    this.actor = {type: "character", system: foundry.utils.deepClone(game.system.model.Actor.character), items: [] };

    if (!game.user.isGM)
    {
      ChatMessage.create({content : game.i18n.format("CHARGEN.Message.Start", {user : game.user.name})}).then(msg => this.message = msg);
    }

    // Warn user if they won't be able to create a character
    if (!game.user.isGM && !game.settings.get("core", "permissions").ACTOR_CREATE.includes(game.user.role) && !game.users.find(u => u.isGM && u.active))
    {
      ui.notifications.warn(game.i18n.localize("CHARGEN.NoGMWarning"), {permanent : true});
    }


    Hooks.call("wfrp4e:chargen", this);
  }


  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "chargen";
    options.template = "systems/wfrp4e/templates/apps/chargen/chargen.hbs";
    options.classes = options.classes.concat("wfrp4e", "chargen");
    options.resizable = true;
    options.width = 1000;
    options.height = 600;
    options.minimizable = true;
    options.title = game.i18n.localize("CHARGEN.Title");
    return options;
  }


  async getData() {

    let skills = [];


    let allItems = [];
    for(let key in this.data.items)
    {
      allItems = allItems.concat(this.data.items[key]);
    }


    let allChanges = allItems
    .filter(i => i)
    .reduce((prev, current) => prev.concat(Array.from(current.effects)), []) // reduce items to effects
    .reduce((prev, current) => prev.concat(current.changes), [])      // reduce effects to changes
    .filter(c => c.key.includes("characteristics"));                   // filter changes to characteristics

    let characteristics = duplicate(this.data.characteristics);

    for (let ch in characteristics)
    {
      // Apply modifiers from item effects
      let changes = allChanges.filter(c => c.key.includes(`characteristics.${ch}`));
      let initialChanges = changes.filter(c => c.key.includes(`characteristics.${ch}.initial`));
      let modifierChanges = changes.filter(c => c.key.includes(`characteristics.${ch}.modifier`));

      let initialSum = initialChanges.reduce((prev, current) => prev += Number(current.value), 0);
      let modifierSum = modifierChanges.reduce((prev, current) => prev += Number(current.value), 0);

      characteristics[ch].initial += initialSum;
      characteristics[ch].total = characteristics[ch].initial + characteristics[ch].advances + modifierSum;
    }



    for(let key in this.data.skillAdvances)
    {
      let skill = await WFRP_Utility$1.findSkill(key);
      if (skill)
      {
        let ch = characteristics[skill.system.characteristic.value];
        if (ch && this.data.skillAdvances[key] > 0)
        {
          skills.push(`${key} (+${this.data.skillAdvances[key]}) ${ch.initial + ch.advances + this.data.skillAdvances[key]}`);
        }
      }
    }

    let exp = 0;
    for(let key in this.data.exp)
    {
      exp += this.data.exp[key];
    }

    this.data.fate.total = this.data.fate.allotted + this.data.fate.base;
    this.data.resilience.total = this.data.resilience.allotted + this.data.resilience.base;

    return {
      characteristics,
      speciesDisplay : this.data.subspecies ? `${game.wfrp4e.config.species[this.data.species]} (${game.wfrp4e.config.subspecies[this.data.species]?.[this.data.subspecies].name})` :  game.wfrp4e.config.species[this.data.species],
      stages: this.stages,
      data : this.data,
      stageHTML :  await this._getStageHTML(),
      skills : skills.join(", "),
      talents : this.data.items.talents?.map(i => i.name).join(", "),
      trappings : this.data.items.trappings?.map(i => i.name).join(", "),
      exp
    }
  }


  async _getStageHTML()
  {
    let html = [];

    for(let stage of this.stages)
    {
      html.push(await stage.app?.addToDisplay());
    }

    return html.filter(i => i).join("")
  }

  async _updateObject(ev, formData)
  {
    try {

      if (this.message)
        this.message.update({content : this.message.content + game.i18n.format("CHARGEN.Message.Created", {name : this.data.details.name})});

      this.actor.system.details.species.value = this.data.species;
      this.actor.system.details.species.subspecies = this.data.subspecies;

      for(let exp in this.data.exp)
      {
        if (Number.isNumeric(this.data.exp[exp]))
          this.actor.system.details.experience.total += Number(this.data.exp[exp]);
      }

      for(let key in this.data.items)
      {
        let items = this.data.items[key];
        if (!(items instanceof Array))
        {
          items = [items];
        }
        this.actor.items = this.actor.items.concat(items);
      }

      let money = await WFRP_Utility$1.allMoneyItems();

      money.forEach(m => m.system.quantity.value = 0);

      this.actor.items = this.actor.items.concat(money);

      // Get basic skills, add advancements (if skill advanced and isn't basic, find and add it)
      let skills = await WFRP_Utility$1.allBasicSkills();
      for(let skill in this.data.skillAdvances)
      {
        let adv = this.data.skillAdvances[skill];
        if (Number.isNumeric(adv))
        {
          let existing = skills.find(s => s.name == skill);

          if (!existing)
          {
            existing = await WFRP_Utility$1.findSkill(skill);
            existing = existing.toObject();
            skills.push(existing);
          }
          existing.system.advances.value += Number(adv);
        }
      }
      this.actor.items = this.actor.items.concat(skills);

      mergeObject(this.actor.system.characteristics, this.data.characteristics, {overwrite : true});
      this.actor.system.status.fate.value = this.data.fate.base + this.data.fate.allotted;
      this.actor.system.status.resilience.value = this.data.resilience.base + this.data.resilience.allotted;

      this.actor.system.status.fortune.value =  this.actor.system.status.fate.value;
      this.actor.system.status.resolve.value =  this.actor.system.status.resilience.value;

      this.actor.system.details.move.value = this.data.move;

      this.actor.name = this.data.details.name || "New Character";
      this.actor.system.details.gender.value = this.data.details.gender;
      this.actor.system.details.age.value = this.data.details.age;
      this.actor.system.details.height.value = this.data.details.height;
      this.actor.system.details.haircolour.value = this.data.details.hair;
      this.actor.system.details.eyecolour.value = this.data.details.eyes;
      this.actor.system.details.motivation.value = this.data.details.motivation;
      this.actor.system.details["personal-ambitions"] = {
        "short-term" : this.data.details.short,
        "long-term" : this.data.details.long
      };

      mergeObject(this.actor, expandObject(this.data.misc), {overwrite : true});


      // Don't add items inline, as that will not create active effects
      // Except skills, as new characters without items create blank skills
      // We want to add ours to prevent duplicates
      let items = this.actor.items;
      this.actor.items = this.actor.items.filter(i => i.type == "skill");
      this.actor.items = this.actor.items.filter(i => i.system.advances.value > 0 || // Don't add advanced skills that don't have advancements,
        (i.system.advanced.value == "bsc" && i.system.grouped.value == "noSpec") || // Don't add specialisations that don't have advancements
        (i.system.advanced.value == "bsc" && i.system.grouped.value == "isSpec" && !i.name.includes("(") && !i.name.includes(")")));

      items = items.filter(i => i.type != "skill");

      if (game.user.isGM || game.settings.get("core", "permissions").ACTOR_CREATE.includes(game.user.role))
      {
        let document = await Actor.create(this.actor);
        document.createEmbeddedDocuments("Item", items);
        document.sheet.render(true);
      }
      else {
        const payload =  {id : game.user.id, data : this.actor, items : items.map(i => i instanceof Item ? i.toObject() : i)};
        let id = await SocketHandlers.executeOnUserAndWait("GM", "createActor", payload);
        let actor = game.actors.get(id);
        if (actor && actor.isOwner) {
          actor.sheet.render(true);
        }
      }
    }
    catch(e)
    {
      ui.notifications.error(game.i18n.format("CHARGEN.ERROR.Create", {error: e}));
    }
  }

  complete(stageIndex) {
    this.stages[stageIndex].complete = true;
    this.render(true);
  }

  canStartStage(stage)
  {
    if (!stage)
      return false

    let dependancies = stage.dependantOn.map(i => this.stages.find(s => s.key == i));
    return dependancies.every(stage => stage.complete)

  }

  addStage(stage, index)
  {
    let stageObj = stage.stageData();
    if (index == undefined)
    {
      this.stages.push(stageObj);
    }
    else { // Insert new stage in specified index
      let newStages = [];
      newStages = this.stages.slice(0, index);
      newStages.push(stageObj);
      newStages = newStages.concat(this.stages.slice(index));
      this.stages = newStages;
    }
  }


  activateListeners(html) {
    super.activateListeners(html);

    html.find(".chargen-button").on("click", ev => {
      let stage = this.stages[Number(ev.currentTarget.dataset.stage)];

      if (!this.canStartStage(stage))
      {
        return ui.notifications.error(game.i18n.format("CHARGEN.ERROR.StageStart", {stage : stage.dependantOn.toString()}))
      }

      if (stage.app)
        stage.app.render(true);
      else {
        stage.app = new stage.class(
          this.data,
          {
            complete : this.complete.bind(this), // Function used by the stage to complete itself
            index : Number(ev.currentTarget.dataset.stage),
            message : this.message
          });
        stage.app.render(true);
      }
    });
  }
}

function chat() {

  // Activate chat listeners defined in chat-wfrp4e.js
  Hooks.on('renderChatLog', (log, html, data) => {
    ChatWFRP.chatListeners(html);
  });


  // Add Apply Condition buttons
  Hooks.on("preCreateChatMessage", (msg) => {
    msg.updateSource({"content" : ChatWFRP.addEffectButtons(msg.content)});
  });



  /**
   * Primary use of this hook is to intercept chat commands.
   * /char  - Begin character generation
   * /table - Roll on a table
   * /cond  - Lookup a condition
   * /name  - Generate a name
   * /avail - Start an item availability test
   * /pay - Player: Remove money from character. GM: Start a payment request
   * /credit - Player: Not allowed. GM: Start a credit request to send money to players
   * /help - display a help message on all the commands above
   */
  Hooks.on("chatMessage", (html, content, msg) => {
    // Setup new message's visibility
    let rollMode = game.settings.get("core", "rollMode");
    if (["gmroll", "blindroll"].includes(rollMode)) msg["whisper"] = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
    if (rollMode === "blindroll") msg["blind"] = true;

    let regExp;
    regExp = /(\S+)/g;
    let commands = content.match(regExp);
    let command = commands[0];

    // Roll on a table
    if (command === "/table") {
      // If no argument, display help menu
      if (commands.length === 1)
      {
        game.wfrp4e.tables.formatChatRoll("menu").then(text => {
          if (!text)
            return
          msg.content = text;
          msg.speaker = {alias: "Table Menu"};
          ChatMessage.create(msg);
        });
      }
      else {
        // [0]: /table [1]: <table-name> [2]: argument1 [3]: argument2
        let modifier, column; // Possible arguments
        // If argument 1 is a number use it as the modifier
        if (!isNaN(commands[2])) {
          modifier = parseInt(commands[2]);
          column = commands[3];
        } else // if argument 1 is not a number, use it as column
        {
          modifier = parseInt(commands[3]),
            column = commands[2];
        }
        // Call tables class to roll and return html
        game.wfrp4e.tables.formatChatRoll(commands[1], { modifier: modifier, showRoll : true }, column).then(text => {          
          if (!text)
            return
          msg.content = text;
          ChatMessage.create(msg);
        });
      }
      return false;
    }
    // Lookup a condition
    else if (command === "/cond") {
      // Only one argument possible [1]: condition to lookup
      let conditionInput = commands[1].toLowerCase();
      // Don't require spelling, match the closest condition to the input
      let closest = WFRP_Utility$1.matchClosest( game.wfrp4e.config.conditions, conditionInput);
      if (! game.wfrp4e.config.conditionDescriptions) {
        ui.notifications.error("No content found");
        return false
      }
      let description =  game.wfrp4e.config.conditionDescriptions[closest];
      let name =  game.wfrp4e.config.conditions[closest];

      // Create message and return false to not display user input of `/cond`
      msg.content = `<b>${name}</b><br>${description}`;
      ChatMessage.create(msg);
      return false;
    }
    // Lookup an item property
    else if (command === "/prop")
    {
      let propertyInput = commands[1].toLowerCase();
      let allProperties = game.wfrp4e.utility.allProperties();
      let closest = WFRP_Utility$1.matchClosest( game.wfrp4e.utility.allProperties(), propertyInput);

      let description = game.wfrp4e.config.qualityDescriptions[closest] || game.wfrp4e.config.flawDescriptions[closest];
      let name =  allProperties[closest];

      msg.content = `<b>${name}</b><br>${description}`;
      ChatMessage.create(msg);
      return false;
    }

    // Character generation
    else if (command === "/char") {
      new CharGenWfrp4e().render(true);
      return false;
    }
    // Name generation
    else if (command === "/name") {
      // Possible arguments - [2]: gender, [1]: species
      let gender = (commands[2] || "").toLowerCase();
      let species = (commands[1] || "").toLowerCase();
      // Call generator class to create name, create message, return false to not display user input of `/name`
      let name = NameGenWfrp.generateName({ species, gender });
      ChatMessage.create(WFRP_Utility$1.chatDataSetup(name));
      return false;
    }
    // Availability test
    else if (command === "/avail") {
      let modifier = 0;
      // Possible arguments - [1]: settlement size, [2]: item rarity [3*]: modifier

      let settlement = (commands[1] || "").toLowerCase();
      let rarity = (commands[2] || "").toLowerCase();
      if (!isNaN(commands[3])) {
        modifier = commands[3];
      }

      // Call generator class to start the test, create message, send to chat, return false to not display user input of `/avail`
      MarketWfrp4e.testForAvailability({ settlement, rarity, modifier });
      return false;
    }
    // Pay commands
    else if (command === "/pay") {
      //The parameter is a string that will be exploded by a regular expression
      let amount = commands[1];
      let playerOrActor = commands.slice(2, commands.length).join(" ");
      //If the user isnt a GM, he pays a price
      if (!game.user.isGM) {
        let actor = WFRP_Utility$1.getSpeaker(msg.speaker);
        let money = MarketWfrp4e.payCommand(amount, actor);
        if (money)
          actor.updateEmbeddedDocuments("Item", money);
      } else {
        if ( playerOrActor.length > 0) {  // Valid actor/option
          let actor = game.actors.find(a => a.name.toLowerCase().includes(playerOrActor.toLowerCase() ) );
          if ( actor ) {
            let p = game.users.players.find(p => p.character.id == actor.id && p.active);
            if (actor.hasPlayerOwner && p ) { 
                playerOrActor = p.name; // In this case, replace the actor by the player name for chat card, as usual
              } else {
                MarketWfrp4e.directPayCommand(amount,actor); // No player/Not active -> substract money
                return false;
              }
          }
        }
        // Default choice, display chat card
        MarketWfrp4e.generatePayCard(amount, playerOrActor);
      }
      return false;
    }

    // Credit commands
    else if (command === "/credit") {
      let amount = commands[1];
      let playerOrActorOrCommand = commands.slice(2, commands.length).join(" ");

      // If hes a gm, it generate a "Credit" card for all the player.
      if (game.user.isGM) {
        MarketWfrp4e.processCredit(amount, playerOrActorOrCommand);
      } else {
        //If the user isnt a GM, he can't use the command (for now)
        message = `<p>${game.i18n.localize("MARKET.CreditCommandNotAllowed")}</p>`;
        ChatMessage.create(WFRP_Utility$1.chatDataSetup(message, "roll"));
      }
      return false;
    }

    else if (command === "/corruption") {
      WFRP_Utility$1.postCorruptionTest(commands[1]);
      return false;
    }


    else if (command === "/fear") {
      WFRP_Utility$1.postFear(commands[1], commands.slice(2).join(" "));
      return false;
    }

    else if (command === "/terror") {
      WFRP_Utility$1.postTerror(commands[1], commands.slice(2).join(" "));
      return false;
    }


    else if (command === "/exp") {
      WFRP_Utility$1.postExp(commands[1], commands.slice(2).join(" "));
      return false;
    }

    // Travel commands
    else if (command === "/travel") {
      TravelDistanceWfrp4e.displayTravelDistance( commands[1], commands[2] );
      return false;
    }

    //Help commands
    else if (command === "/help") {
      let rawCommands = game.i18n.localize("CHAT.CommandLine.Help.Commands");

      let commandElements = rawCommands.split(",").map(function (item) {
        return {
          title: game.i18n.localize(`CHAT.CommandLine.Help.${item}.Title`),
          command: game.i18n.localize(`CHAT.CommandLine.Help.${item}.Usage.Command`),
          commandLabel: game.i18n.localize(`CHAT.CommandLine.Help.Label.Command`),
          example: game.i18n.localize(`CHAT.CommandLine.Help.${item}.Usage.Example`),
          exampleLabel: game.i18n.localize(`CHAT.CommandLine.Help.Label.Example`),
          note: game.i18n.localize(`CHAT.CommandLine.Help.${item}.Usage.Note`),
          noteLabel: game.i18n.localize(`CHAT.CommandLine.Help.Label.Note`),
        };
      });

      let link = game.i18n.format("CHAT.CommandLine.Help.Link", { link: "https://github.com/moo-man/WFRP4e-FoundryVTT/wiki" });

      renderTemplate("systems/wfrp4e/templates/chat/help/chat-help-command.hbs", {
        commands: commandElements,
        link: link
      }).then(html => {
        let chatData = WFRP_Utility$1.chatDataSetup(html, "selfroll");
        ChatMessage.create(chatData);
      });
      return false;
    }
  });


  /**
 * Searches each message and adds drag and drop functionality and hides certain things from players
 */

  Hooks.on("renderChatMessage", async (app, html, msg) => {

    WFRP_Utility$1.addLinkSources(html);
    // Hide test data from players (35 vs 50) so they don't know the enemy stats
    if (game.settings.get("wfrp4e", "hideTestData") && !game.user.isGM && html.find(".chat-card").attr("data-hide") === "true") {
      html.find(".hide-option").remove();
    }
    // Hide chat card edit buttons from non-gms
    if (!game.user.isGM) {
      html.find(".chat-button-gm").remove();
      html.find(".unopposed-button").remove();
      html.find(".haggle-buttons").remove();
      html.find(".hide-spellcn").remove();
      //hide tooltip contextuamneu if not their roll
      if (msg.message.speaker.actor && game.actors.get(msg.message.speaker.actor).ownership != 3)
        html.find(".chat-button-player").remove();
    }
    else {
      html.find(".chat-button-player").remove();
    }

    // Do not display "Blind" chat cards to non-gm
    if (html.hasClass("blind") && !game.user.isGM) {
      html.find(".message-header").remove(); // Remove header so Foundry does not attempt to update its timestamp
      html.html("").css("display", "none");
    }

    // Add drag and drop functonality to posted items
    let postedItem = html.find(".post-item")[0];
    if (postedItem) {
      postedItem.setAttribute("draggable", true);
      postedItem.classList.add("draggable");

      postedItem.addEventListener('dragstart', ev => {
        if (app.flags.postQuantity == "inf" || app.flags.postQuantity == undefined)
          return ev.dataTransfer.setData("text/plain", app.flags.transfer);

        if (game.user.isGM)
        {
          ev.dataTransfer.setData("text/plain", app.flags.transfer);
          let newQuantity = app.flags.postQuantity - 1;
          let recreateData = app.flags.recreationData;
          recreateData.postQuantity = newQuantity;
          renderTemplate("systems/wfrp4e/templates/chat/post-item.hbs", recreateData).then(html => {
            app.update({ "flags.postQuantity": newQuantity, content : TextEditor.enrichHTML(html) });
            if (newQuantity <= 0)
              app.delete();
          });

        }
        else
        {
          let newQuantity = app.flags.postQuantity - 1;

          if (app.flags.postQuantity)
            ev.dataTransfer.setData("text/plain", app.flags.transfer);


          if (newQuantity == 0) {
            game.socket.emit("system.wfrp4e", {
              type: "deleteMsg",
              payload: {
                "id": app.id
              }
            });
            return false
          }
          else {
            ev.dataTransfer.setData("text/plain", app.flags.transfer);
            let recreateData = app.flags.recreationData;
            recreateData.postQuantity = newQuantity;
            renderTemplate("systems/wfrp4e/templates/chat/post-item.hbs", recreateData).then(html => {

              game.socket.emit("system.wfrp4e", {
                type: "updateMsg",
                payload: {
                  "id": app.id,
                  "updateData": { "flags.postQuantity": newQuantity, content: TextEditor.enrichHTML(html) }
                }
              });
            });
          }
        }
      });
    }

    // Add drag and drop to character generation results
    let woundsHealed = html.find(".wounds-healed-drag")[0];
    if (woundsHealed) {
      woundsHealed.setAttribute("draggable", true);
      woundsHealed.addEventListener('dragstart', ev => {
        let dataTransfer = {
          type : "wounds",
          payload : app.flags.testData.result.woundsHealed
        };
        ev.dataTransfer.setData("text/plain", JSON.stringify(dataTransfer));
      });
    }

    // Add drag and drop to character generation results
    let generation = html.find(".char-gen")[0];
    if (generation) {
      generation.setAttribute("draggable", true);
      generation.addEventListener('dragstart', ev => {
        ev.dataTransfer.setData("text/plain", app.flags.transfer);
      });
    }


    // Add drag and drop to money from income rolls
    html.find(".money-drag").each(function () {
      let amount = $(this)[0];
      amount.setAttribute("draggable", true);
      amount.addEventListener('dragstart', ev => {
        let dataTransfer = {
          type : "money",
          payload: $(amount).attr("data-amt")
        };
        ev.dataTransfer.setData("text/plain", JSON.stringify(dataTransfer));
      });
    });

    WFRP_Utility$1.replacePopoutTokens(html);

  });

  Hooks.on("deleteChatMessage", async (message) => {
    let targeted = message.flags.unopposeData; // targeted opposed test
    let manual = message.flags.opposedStartMessage; // manual opposed test
    if (!targeted && !manual)
      return;

    if (targeted) {
      let target = canvas.tokens.get(message.flags.unopposeData.targetSpeaker.token);
      await target.actor.clearOpposed();
    }
    if (manual && !message.flags.opposeResult && OpposedWFRP.attackerMessage) {
      await OpposedWFRP.attackerMessage.update(
        {
          "flags.data.isOpposedTest": false
        });
      await OpposedWFRP.attacker.clearOpposed();
    }
    ui.notifications.notify(game.i18n.localize("ROLL.CancelOppose"));
  });

}

class CombatHelpers {


    static scripts = {
        startCombat: [CombatHelpers.checkFearTerror],
        endCombat: [CombatHelpers.clearCombatantAdvantage, CombatHelpers.checkCorruption, CombatHelpers.checkInfection, CombatHelpers.checkDiseases],
        startTurn: [CombatHelpers.checkStartTurnConditions],
        endTurn: [CombatHelpers.checkEndTurnConditions],
        endRound: [CombatHelpers.checkEndRoundConditions, CombatHelpers.fearReminders]
    }

    static async preUpdateCombat(combat, updateData, context) {
        const previousId = combat.combatant?.id;
        const path = "wfrp4e.previousCombatant";
        foundry.utils.setProperty(context, path, previousId);
    
        const prevPath = "wfrp4e.previousTR";
        const prevTR = { T: combat.turn, R: combat.round };
        foundry.utils.setProperty(context, prevPath, prevTR);
    
        const startedPath = "wfrp4e.started";
        const prevStarted = combat.started;
        foundry.utils.setProperty(context, startedPath, prevStarted);
    }

    static async updateCombatStart(combat, _, context) {
        const was = foundry.utils.getProperty(context, `wfrp4e.started`);
        const is = combat.started;
        if (was || !is) return;

        for (let script of CombatHelpers.scripts.startCombat) {
            await script(combat);
        }
        await Promise.all(turn.actor.runScripts("startCombat", combat, currentCombatant));
    }

    static async updateCombat(combat, changes, context) {
        if(getProperty(context, "wfrp4e-pl-addons.shouldReroll")) return;

        let cTurn = combat.current.turn;
        let pTurn = foundry.utils.getProperty(context, `wfrp4e.previousTR.T`);
        let cRound = combat.current.round;
        let pRound = foundry.utils.getProperty(context, `wfrp4e.previousTR.R`);
    
        if (changes?.flags && changes?.flags['wfrp4e-pl-addons'] && changes.flags['wfrp4e-pl-addons'].reroll) {
            pRound -= 1;
            changes.turn = cTurn;
            changes.round = cRound;
        }

        // no change in turns nor rounds.
        if (changes.turn === undefined && changes.round === undefined) return;
        // combat not started or not active.
        if (!combat.started || !combat.isActive) return;
        // we went back.
        if (cRound < pRound || (cTurn < pTurn && cRound === pRound)) return;
    
        // retrieve combatants.
        const currentCombatant = combat.combatant;
        const previousId = foundry.utils.getProperty(context, `wfrp4e.previousCombatant`);
        const wasStarted = foundry.utils.getProperty(context, `wfrp4e.started`);
        const previousCombatant = wasStarted ? combat.combatants.get(previousId) : null;

        if (combat.round != 1 && combat.turns && combat.active) {
            if (cRound > 1 && combat.current.turn == 0) {
                for (let script of CombatHelpers.scripts.endRound) {
                    await script(combat);
                }
                await Promise.all(turn.actor.runScripts("endRound", combat));
            }
        }
        
        if (previousCombatant) {
            for (let script of CombatHelpers.scripts.endTurn) {
                await script(combat, previousCombatant);
            }
            await Promise.all(turn.actor.runScripts("endTurn", combat, previousCombatant));
        }
        if (currentCombatant) {
            for (let script of CombatHelpers.scripts.startTurn) {
                await script(combat, currentCombatant);
            }
            await Promise.all(turn.actor.runScripts("startTurn", combat, currentCombatant));
        }
    }

    static async checkStartTurnConditions(combat, combatant) {
        if (!game.user.isUniqueGM)
            return

        if (combatant) {
            if (combatant.actor.hasSystemEffect("dualwielder")) {
                await combatant.actor.removeSystemEffect("dualwielder");
            }

            if (game.settings.get("wfrp4e", "statusOnTurnStart")) {
                let nameOverride =  combat.combatant.hidden ? "???" : combatant.name;
                combatant.actor.displayStatus(combat.round, nameOverride);
            }

            if (game.settings.get("wfrp4e", "focusOnTurnStart")) {
                canvas.tokens.get(combatant.token.id).control();
                canvas.tokens.cycleTokens(1, true);
            }

            let msgContent = "";
            let startTurnConditions = combatant.actor.actorEffects.filter(e => e.conditionTrigger == "startTurn");
            for (let cond of startTurnConditions) {
                if (game.wfrp4e.config.conditionScripts[cond.conditionId]) {
                    let conditionName = game.i18n.localize(game.wfrp4e.config.conditions[cond.conditionId]);
                    if (Number.isNumeric(cond.flags.wfrp4e.value))
                        conditionName += ` ${cond.flags.wfrp4e.value}`;
                    msgContent = `
                <h2>${conditionName}</h2>
                <a class="condition-script" data-combatant-id="${combatant.id}" data-cond-id="${cond.conditionId}">${game.i18n.format("CONDITION.Apply", { condition: conditionName })}</a>`;
                    await ChatMessage.create({ content: msgContent, speaker: { alias: combatant.token.name } });
                }
            }

        }
        WFRP_Audio.PlayContextAudio({ item: { type: 'round' }, action: "change" });
    }

    static async checkEndTurnConditions(combat, combatant) {
        if (!game.user.isUniqueGM)
            return

        if (combatant) {
            let msgContent = "";
            let endTurnConditions = combatant.actor.actorEffects.filter(e => e.conditionTrigger == "endTurn");
            for (let cond of endTurnConditions) {
                if (game.wfrp4e.config.conditionScripts[cond.conditionId]) {
                    let conditionName = game.i18n.localize(game.wfrp4e.config.conditions[cond.conditionId]);
                    if (Number.isNumeric(cond.flags.wfrp4e.value))
                        conditionName += ` ${cond.flags.wfrp4e.value}`;
                    msgContent = `
                <h2>${conditionName}</h2>
                <a class="condition-script" data-combatant-id="${combatant.id}" data-cond-id="${cond.conditionId}">${game.i18n.format("CONDITION.Apply", { condition: conditionName })}</a>`;
                    await ChatMessage.create({ content: msgContent, speaker: { alias: combatant.token.name } });
                }
            }
        }
    }

    static async endCombat(combat) {
        if (!game.user.isUniqueGM)
            return

        let content = "";
        let scriptResult = "";
        for (let script of CombatHelpers.scripts.endCombat) {
            scriptResult = await script(combat);
            if (scriptResult) {
                content += scriptResult + "<br><br>";
            }
        }
        if (content) {
            content = `<h2>${game.i18n.localize("CHAT.EndCombat")}</h3>` + content;
            ChatMessage.create({ content, whisper: ChatMessage.getWhisperRecipients("GM") });
        }
        await Promise.all(turn.actor.runScripts("endCombat", combat));
    }

    static async checkFearTerror(combat) {
        if (!game.user.isUniqueGM)
            return

        let fearCounters = [];
        let terrorCounters = [];
        for (let turn of combat.turns) {
            try {

            let fear = turn.actor.has(game.i18n.localize("CHAT.Fear"));
            if (fear)
                fearCounters.push({ name: turn.name, value: `@Fear[${fear.specification.value},${turn.name}]` });

            let terror = turn.actor.has(game.i18n.localize("CHAT.Terror"));
            if (terror)
                terrorCounters.push({ name: turn.name, value: `@Terror[${terror.specification.value},${turn.name}]` });

            }
            catch (e) {
                console.log(e);
            }
        }
        let msg = "";
        if (fearCounters.length || terrorCounters.length) {
            if (fearCounters.length)
                msg += `<h2>${game.i18n.localize("CHAT.Fear")}</h2>${fearCounters.map(f => `<b>${f.name}</b> - ${f.value}`).join("<br>")}`;
            if (terrorCounters.length)
                msg += `<h2>${game.i18n.localize("CHAT.Terror")}</h2>${terrorCounters.map(t => `<b>${t.name}</b> - ${t.value}`).join("<br>")}`;

        }

        msg += CombatHelpers.checkSizeFearTerror(combat);

        if (msg)
            await ChatMessage.create({ content: msg });
    }

    static checkSizeFearTerror(combat) {
        let sizeMap = {};
        let msg = "";
        for (let turn of combat.turns) {
            sizeMap[turn.name] = turn.actor.sizeNum;
        }
        for (let actor in sizeMap) {
            let size = sizeMap[actor];
            let smallerBy = {
                1: [],
                2: [],
                3: [],
                4: [],
                5: [],
                6: []
            };

            for (let otherActor in sizeMap) {
                if (otherActor == actor)
                    continue
                try {
                    if (size > sizeMap[otherActor])
                        smallerBy[size - sizeMap[otherActor]].push(otherActor);
                }
                catch (e) {

                }
            }

            if (smallerBy[1].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Fear[${1}, ${actor}]`, actor: actor, target: smallerBy[1].join(", ")});

            if (smallerBy[2].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${2}, ${actor}]`, actor: actor, target: smallerBy[2].join(", ")});

            if (smallerBy[3].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${3}, ${actor}]`, actor: actor, target: smallerBy[3].join(", ")});

            if (smallerBy[4].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${4}, ${actor}]`, actor: actor, target: smallerBy[4].join(", ")});

            if (smallerBy[5].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${5}, ${actor}]`, actor: actor, target: smallerBy[5].join(", ")});

            if (smallerBy[6].length)
                msg += game.i18n.format("CHAT.CausesFear", { fear: `@Terror[${6}, ${actor}]`, actor: actor, target: smallerBy[6].join(", ")});

            if (Object.values(smallerBy).some(list => list.length)) {
                msg += "<br>";
            }
        }
        if (msg) {
            msg = `<br><h2>${game.i18n.localize("Size")}</h2>${msg}`;
        }
        return msg
    }

    static async checkCorruption(combat) {
        if (!game.user.isUniqueGM)
            return

        let corruptionCounters = [];

        for (let turn of combat.turns) {
            let corruption = turn.actor.has(game.i18n.localize("NAME.Corruption"));
            if (corruption) {
                let existing = corruptionCounters.find(c => c.type == corruption.specification.value);
                if (existing)
                    existing.counter++;
                else
                    corruptionCounters.push({ counter: 1, type: corruption.specification.value });
            }
        }

        let content = "";

        if (corruptionCounters.length) {
            content += `<h3><b>${game.i18n.localize("Corruption")}</b></h3>`;
            for (let corruption of corruptionCounters) {
                content += `${corruption.counter} ${corruption.type}<br>`;
            }
            content += game.i18n.localize("CHAT.CorruptionTest");
            content += `<br>@Corruption[Minor]<br>@Corruption[Moderate]<br>@Corruption[Major]`;
        }
        return content
    }

    static async checkInfection(combat) {
        if (!game.user.isUniqueGM)
            return

        let minorInfections = combat.getFlag("wfrp4e", "minorInfections") || [];
        let content = "";
        if (minorInfections.length) {
            content += `<h3><b>${game.i18n.localize("Minor Infections")}</b></h3>${game.i18n.localize("CHAT.InfectionReminder")}<br>`;
            for (let actor of minorInfections) {
                content += `<br><b>${actor}</b>`;
            }
        }
        return content
    }

    static async checkDiseases(combat) {
        if (!game.user.isUniqueGM)
            return

        let diseaseCounters = [];

        for (let turn of combat.turns) {
            let disease = turn.actor.has(game.i18n.localize("NAME.Disease"));
            if (disease) {
                let existing = diseaseCounters.find(d => d.type == disease.specification.value);
                if (existing)
                    existing.counter++;
                else
                    diseaseCounters.push({ counter: 1, type: disease.specification.value });
            }
        }
        let content = "";

        if (diseaseCounters.length) {
            content += `<h3><b>${game.i18n.localize("Diseases")}</b></h3>`;
            for (let disease of diseaseCounters)
                content += `${disease.counter} <a class="item-lookup" data-type="disease" data-open="sheet">${disease.type}</a><br>`;

            content += game.i18n.localize("CHAT.DiseasesRules");
        }
        return content
    }

    static async checkEndRoundConditions(combat) {
        if (!game.user.isUniqueGM)
            return

        let removedConditions = [];
        let msgContent = "";
        for (let turn of combat.turns) {
            if (turn.actor.status.wounds.value == 0) {
                if (turn.actor.status.roundsToPassOut.value < turn.actor.status.roundsToPassOut.max) {
                    turn.actor.status.roundsToPassOut.value++;
                    await turn.actor.update({ "system.status.roundsToPassOut.value": turn.actor.status.roundsToPassOut.value });
                    if (turn.actor.status.roundsToPassOut.value == turn.actor.status.roundsToPassOut.max) {
                        await turn.actor.addCondition("unconscious");
                    }
                }
            } else {
                turn.actor.status.roundsToPassOut.value = 0;
                await turn.actor.update({ "system.status.roundsToPassOut.value": 0 });
            }
        }

        for (let turn of combat.turns) {
            let endRoundConditions = turn.actor.actorEffects.filter(e => e.conditionTrigger == "endRound");
            for (let cond of endRoundConditions) {
                if (game.wfrp4e.config.conditionScripts[cond.conditionId]) {
                    let conditionName = game.i18n.localize(game.wfrp4e.config.conditions[cond.conditionId]);
                    if (Number.isNumeric(cond.flags.wfrp4e.value))
                        conditionName += ` ${cond.flags.wfrp4e.value}`;
                    msgContent = `
              <h2>${conditionName}</h2>
              <a class="condition-script" data-combatant-id="${turn.id}" data-cond-id="${cond.conditionId}">${game.i18n.format("CONDITION.Apply", { condition: conditionName })}</a>`;
                    await ChatMessage.create({ content: msgContent, speaker: { alias: turn.token.name } });
                }
            }

            let conditions = turn.actor.actorEffects.filter(e => e.isCondition);
            for (let cond of conditions) {
                // I swear to god whoever thought it was a good idea for these conditions to reduce every *other* round...
                if (cond.conditionId == "deafened" || cond.conditionId == "blinded" && Number.isNumeric(cond.flags.wfrp4e.roundReceived)) {
                    if ((combat.round - 1) % 2 == cond.flags.wfrp4e.roundReceived % 2) {
                        await turn.actor.removeCondition(cond.conditionId);
                        removedConditions.push(
                            game.i18n.format("CHAT.RemovedConditions", {
                                condition: game.i18n.localize(game.wfrp4e.config.conditions[cond.conditionId]),
                                name: turn.actor.token?.name || turn.actor.prototypeToken.name
                            }));
                    }
                }
            }
            await Promise.all(turn.actor.runScripts("endRound", combat));

        }
        if (removedConditions.length)
            await ChatMessage.create({ content: removedConditions.join("<br>") });
    }

    static async fearReminders(combat) {
        let chatData = { content: game.i18n.localize("CHAT.FearReminder") + "<br><br>", speaker: { alias: game.i18n.localize("CHAT.Fear") } };
        let fearedCombatants = combat.turns.filter(t => t.actor.hasCondition("fear"));
        if (!fearedCombatants.length)
            return

        fearedCombatants.forEach(c => {
            let fear = c.actor.hasCondition("fear");
            chatData.content += `<b>${c.name}</b>`;
            if (fear.flags.wfrp4e.fearName)
                chatData.content += ` (${fear.flags.wfrp4e.fearName})`;
            chatData.content += "<br>";
        });
        await ChatMessage.create(chatData);
    }

    static async clearCombatantAdvantage(combat) {
        if (!game.user.isUniqueGM)
            return

        if (game.settings.get("wfrp4e","useGroupAdvantage")) {
            await WFRP_Utility$1.updateGroupAdvantage({players : 0, enemies : 0});
        } 

        for (let turn of combat.turns) {
            if (!game.settings.get("wfrp4e","useGroupAdvantage")) {
                await turn.actor.update({ "system.status.advantage.value": 0 }, {skipGroupAdvantage: true});
            }
        }
    }
}

function combat() {
  Hooks.on("updateCombat", CombatHelpers.updateCombat);
  Hooks.on("updateCombat", CombatHelpers.updateCombatStart);
  Hooks.on("preUpdateCombat", CombatHelpers.preUpdateCombat);
  Hooks.on("deleteCombat", CombatHelpers.endCombat);


  Hooks.on("preCreateCombatant", (combatant, data) => {
    combatant.updateSource({img : WFRP_Utility$1.replacePopoutPath(combatant.token.texture.src)});
  });

  Hooks.on("createCombatant", async combatant => {
    let mask = combatant.token.hidden;
    if (mask && game.user.isGM) {
      let data = {};
      data.img = "systems/wfrp4e/tokens/unknown.png";
      data.name = "???";
      await combatant.update(data);
    }
  });

  Hooks.on("updateToken", async function(scene, tokenData, diffData, options, userId) {
    if (game.combat?.active && game.user.isGM) {
      let combatant = game.combat.turns.find(x => x.tokenId == tokenData._id);
      let token = game.canvas.tokens.getDocuments().find(x => x._id == tokenData._id);
      if(!token || !combatant) return;
      let mask = token.hidden;
      let data = null;
      if (combatant && mask && !combatant.hidden && combatant.name != "???") {
        data = {};
        data.img = "systems/wfrp4e/tokens/unknown.png";
        data.name = "???";
      }
      else if (combatant && !mask && !combatant.hidden && combatant.name == "???") {
        data = {};
        data.img = token.texture.src;
        data.name = token.name;
      }
      if (data) {
        await combatant.update(data);
      }
    }
  });


  /* Custom Combat Carousel */
  Hooks.on('renderCombatCarousel', () => {
    addClassByQuerySelector("wfrp4e", "#combat-carousel");
    let carouselSize = game.settings.get('combat-carousel', 'carouselSize');
    if (carouselSize !== "") {
      addClassByQuerySelector(carouselSize, "#combat-carousel");
    }
  });
  
  function addClassByQuerySelector(className, selector) {
    let navigation = document.querySelector(selector);
    navigation.classList.add(className);
  }

  Hooks.on("renderCombatTracker", (app, html, options) => {
    WFRP_Utility$1.replacePopoutTokens(app.element); // Combat tracker shows tokens, replace popout versions with normal

    if (game.settings.get("wfrp4e", "useGroupAdvantage"))
    {
      let advantage = game.settings.get("wfrp4e", "groupAdvantageValues");
      let element = 
      $(`
      <div class="advantage-groups">
      <div class="advantage-group">
      <label>${game.i18n.localize("Players")}</label>
      <input data-group="players" type="number" value=${advantage.players}>
      </div>

      <div class="advantage-group">
      <label>${game.i18n.localize("Enemies")}</label>
      <input data-group="enemies" ${game.user.isGM ? "" : "disabled"} type="number" value=${advantage.enemies}>
      </div>
      </div>
      `);


      element.find("input").on("focus", ev => {
        ev.target.select();
      });

      element.find("input").on("change", async ev => {
        let group = ev.currentTarget.dataset.group;
        let value = Number(ev.currentTarget.value || 0);
        WFRP_Utility$1.updateGroupAdvantage({[`${group}`] : value});
      });

      element.insertAfter(html.find(".combat-tracker-header"));
    }
  });
}

function hotbarDrop() {
  // Needs to be syncrhonous to return false
  Hooks.on("hotbarDrop", (bar, data, slot) => {
    if (data.type == "Item" || data.type == "Actor") {
      handleMacroCreation(bar, data,slot);
      return false;
    }  });
}

async function handleMacroCreation(bar, data, slot)
{
  let document = await fromUuid(data.uuid);

  if (!document)  
    return

  let macro;
  if (document.documentName == "Item")
  {
    if (document.type != "weapon" && document.type != "spell" && document.type != "prayer" && document.type != "trait" && document.type != "skill")
    return
  if (!document)
    return false;

  let command = `game.wfrp4e.utility.rollItemMacro("${document.name}", "${document.type}");`;
  macro = game.macros.contents.find(m => (m.name === document.name) && (m.command === command));
  if (!macro) {
    macro = await Macro.create({
      name: document.name,
      type: "script",
      img: document.img,
      command: command
    }, { displaySheet: false });
  }
  }
  else if (document.documentName == "Actor")
  {
    let command = `Hotbar.toggleDocumentSheet("${document.uuid}")`;
    macro = game.macros.contents.find(m => (m.name === document.name) && (m.command === command));
    if (!macro) {
      macro = await Macro.create({
        name: "Display " + document.name,
        type: "script",
        img: document.prototypeToken.texture.src,
        command: command
      }, { displaySheet: false });
    }
  }

  game.user.assignHotbarMacro(macro, slot);
}

function journal() {

  Hooks.on("getJournalSheetHeaderButtons", (sheet, buttons) => {
    if (sheet.document.sceneNote)
      buttons.unshift(
        {
          class: "pin",
          icon: "fas fa-map-pin",
          onclick: async ev => sheet.document.panToNote()
        });
  });

  /**
   * Adds tooltips to journal sheet buttons and adds listeners for pseudo entities
   */
  Hooks.on("renderJournalPageSheet", (obj, html, data) => {
    $(html).find(".close").attr("title", game.i18n.localize("Close"));
    $(html).find(".entry-image").attr("title", game.i18n.localize("JOURNAL.ModeImage"));
    $(html).find(".entry-text").attr("title", game.i18n.localize("JOURNAL.ModeText"));
    $(html).find(".share-image").attr("title", game.i18n.localize("JOURNAL.ActionShow"));
    
    html.find(".secret.hook .reveal").remove(); // Remove button to reveal hooks, there isn't really a need for that and it messes up the css

    // ---- Listen for custom entity links -----
    html.find(".chat-roll").click(WFRP_Utility$1.handleRollClick.bind(WFRP_Utility$1));
    html.find(".symptom-tag").click(WFRP_Utility$1.handleSymptomClick.bind(WFRP_Utility$1));
    html.find(".condition-chat").click(WFRP_Utility$1.handleConditionClick.bind(WFRP_Utility$1));
    html.find('.table-click').mousedown(WFRP_Utility$1.handleTableClick.bind(WFRP_Utility$1));
    html.find('.pay-link').mousedown(WFRP_Utility$1.handlePayClick.bind(WFRP_Utility$1));
    html.find('.credit-link').mousedown(WFRP_Utility$1.handleCreditClick.bind(WFRP_Utility$1));
    html.find('.corruption-link').mousedown(WFRP_Utility$1.handleCorruptionClick.bind(WFRP_Utility$1));
    html.find('.fear-link').mousedown(WFRP_Utility$1.handleFearClick.bind(WFRP_Utility$1));
    html.find('.terror-link').mousedown(WFRP_Utility$1.handleTerrorClick.bind(WFRP_Utility$1));
    html.find('.exp-link').mousedown(WFRP_Utility$1.handleExpClick.bind(WFRP_Utility$1));

    WFRP_Utility$1.addLinkSources(html);

  });
}

class BugReportFormWfrp4e extends Application {

    
    static issues = []; // Keep issues in static to avoid API limit
    static apiLimitReached = false;

    constructor(app) {
        super(app);

        this.endpoint = "https://aa5qja71ih.execute-api.us-east-2.amazonaws.com/Prod/grievance";
        this.github = "https://api.github.com/repos/moo-man/WFRP4e-FoundryVTT/";

        this.domainKeysToLabel = {
            "wfrp4e": "system",
            "wfrp4e-core": "core",
            "wfrp4e-starter-set": "starter-set",
            "wfrp4e-rnhd": "rnhd",
            "wfrp4e-eis": "eis",
            "wfrp4e-ua1": "ua1",
            "wfrp4e-dotr": "dotr",
            "wfrp4e-middenheim": "middenheim",
            "wfrp4e-archives1": "archives1",
            "wfrp4e-pbtt": "pbtt",
            "wfrp4e-altdorf": "altdorf",
            "wfrp4e-ua2": "ua2",
            "wfrp4e-owb1": "owb1",
            "wfrp4e-horned-rat": "horned-rat",
            "wfrp4e-empire-ruins": "empire-ruins",
            "wfrp4e-archives2" : "archives2",
            "wfrp4e-up-in-arms" : "up-in-arms",
            "wfrp4e-wom" : "wom",
            "wfrp4e-zoo" : "zoo",
            "wfrp4e-salzenmund" : "salzenmund"
        };

        this.loadingIssues = this.loadIssues();
        this.latest = this.checkVersions();
    }

    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "bug-report";
        options.template = "systems/wfrp4e/templates/apps/bug-report.hbs";
        options.classes.push("wfrp4e", "wfrp-bug-report");
        options.resizable = true;
        options.width = 600;
        options.minimizable = true;
        options.title = "Enter Your Grudge";
        options.tabs = [{ navSelector: ".tabs", contentSelector: ".content", initial: "submit" }];
        return options;
    }


    async _render(...args)
    {
        await super._render(...args);
        this.latest = await this.latest;
        this.element.find(".module-check").replaceWith(this.formatVersionWarnings());
    }

    async getData() {
        let data = await super.getData();
        await this.loadingIssues;
        data.domains = game.wfrp4e.config.premiumModules;
        data.name = game.settings.get("wfrp4e", "bugReportName");
        data.record = await this.buildRecord();
        if (this.constructor.apiLimitReached)
        {
            ui.notifications.error(game.i18n.localize("BUGREPORT.ApiLimitReached"), {permanent : true});
        }
        return data;
    }

    formatVersionWarnings() {

        if (!this.latest || this.latest instanceof Promise)
        {
            return "<div></div>"
        }


        let allUpdated = true;
        let outdatedList = "";

        for (let key in this.latest) {
            if (!this.latest[key]) {
                allUpdated = false;
                outdatedList += `<li>${game.wfrp4e.config.premiumModules[key]}</li>`;
            }
        }

        let element = `<div class='notification ${allUpdated ? "stable" : "warning"}'>`;

        if (allUpdated) {
            element += game.i18n.localize("BUGREPORT.Updated");
        }
        else {
            element += game.i18n.localize("BUGREPORT.NotUpdated");
            element += "<ul>";
            element += outdatedList;
            element += "</ul>";
        }

        element += "</div>";

        return element;
    }

    submit(data) {
        fetch(this.endpoint, {
            method: "POST",
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                title: data.title,
                body: data.description,
                assignees: ["moo-man"],
                labels: data.labels
            })
        })
            .then(res => {
                if (res.status == 201) {
                    ui.notifications.notify(game.i18n.localize("GrudgePost"));
                    res.json().then(json => {
                        console.log("%c%s%c%s", 'color: lightblue', `DAMMAZ KRON:`, 'color: unset', ` The longbeards hear you, thank you for your submission into the Dammaz Kron, these wrongs must be righted! If you wish to monitor or follow up with additional details like screenshots, you can find your issue here: ${json.html_url}.`);
                        this.recordIssue(json.number);
                    });
                }
                else {
                    ui.notifications.error(game.i18n.localize("GrudgePostError"));
                    console.error(res);
                }

            })
            .catch(err => {
                ui.notifications.error(game.i18n.localize("Something went wrong"));
                console.error(err);
            });
    }

    recordIssue(number)
    {
        let grudges = foundry.utils.deepClone(game.settings.get("wfrp4e", "grudges"));
        grudges.push(number);
        game.settings.set("wfrp4e", "grudges", grudges).then(() => {
            this.refreshIssues();
        });
    }


    async loadIssues() {
        WFRP_Utility$1.log("Loading GitHub Issues...");
        if (this.constructor.issues.length == 0)
        {

            for(let i = 1; i <= 10; i++)
            {
                SceneNavigation.displayProgressBar({label: game.i18n.localize("BUGREPORT.LoadingIssues"), pct: Math.round((i / 10) * 100) });

                this.constructor.issues = this.constructor.issues.concat((await fetch(this.github + `issues?per_page=100&page=${i}&state=all`)
                .then(r => r.json())
                .catch(error => {
                    if (error.status == 403)
                    {
                        this.constructor.apiLimitReached = true;
                    }
                    console.error(error);
                    this.constructor.issues = [];
                    return [];
                    
                })).map(this.trimIssue));
            }
        }
        else 
        {
            WFRP_Utility$1.log("Skipping requests, issues already loaded");
        }
        WFRP_Utility$1.log("Issues: ", undefined, this.constructor.issues);
        return this.constructor.issues;
    }

    // Issues are big objects, no need to keep everything, so just take what's needed
    trimIssue(issue)
    {
        return {
            number: issue.number,
            title : issue.title,
            html_url : issue.html_url,
            labels : issue.labels,
            state : issue.state
        }
    }

    async refreshIssues()
    {
        // Request a new page of issues, only keep issues we don't have
        let newIssues = (await fetch(this.github + `issues?per_page=100&state=all`).then(r => r.json()).catch(error => console.error(error))).map(this.trimIssue);
        this.constructor.issues = this.constructor.issues.concat(newIssues.filter(newIssue => !this.constructor.issues.find(i => i.number == newIssue.number)));
    }

    async buildRecord()
    {
        let numbersSubmitted = game.settings.get("wfrp4e", "grudges");

        let issuesSubmitted = this.constructor.issues.filter(i => numbersSubmitted.includes(i.number));

        let record = {
            open : issuesSubmitted.filter(i => i.state == "open"),
            closed : issuesSubmitted.filter(i => i.state == "closed"),
            alert : false
        };

        for(let issue of record.open)
        {
            if (issue.labels.find(l => l.name == "non-repro" || l.name == "needs-info"))
            {
                issue.alert = true;
                record.alert = true;
            }
        }

        return record
    }

    async checkVersions() {
        let latest = {};
        WFRP_Utility$1.log("Checking Version Numbers...");
        for (let key in game.wfrp4e.config.premiumModules) {
            if (key == game.system.id) {
                // Have to use release tag instead of manifest version because CORS doesn't allow downloading release asset for some reason
                let release = await fetch(this.github + "releases/latest").then(r => r.json()).catch(e => {
                    console.error("Could not fetch latest versions: " + e);
                    return latest;
                });
                latest[key] = !isNewerVersion(release.tag_name, game.system.version);
            }
            else if (game.modules.get(key)) {
                let manifest = await fetch(`https://foundry-c7-manifests.s3.us-east-2.amazonaws.com/${key}/module.json`).then(r => r.json()).catch(e => {
                    console.error("Could not fetch latest versions: " + e);
                    return latest;
                });
                latest[key] = !isNewerVersion(manifest.version, game.modules.get(key).version);
            }
            WFRP_Utility$1.log(key + ": " + latest[key]);
        }
        WFRP_Utility$1.log("Version Status:", undefined, latest);
        return latest;
    }

    matchIssues(text) {

        let issues = this.constructor.issues.filter(i => i.state == "open");

        let words = text.toLowerCase().split(" ");
        let percentages = new Array(issues.length).fill(0);


        issues.forEach((issue, issueIndex) => {
            let issueWords = (issue.title + " " + issue.body).toLowerCase().trim().split(" ");
            words.forEach((word) => {
                {
                    if (issueWords.includes(word))
                        percentages[issueIndex]++;
                }
            });
        });
        let matchingIssues = [];
        percentages = percentages.map(i => i/issues.length);
        percentages.forEach((p, i) => {
            if (p > 0)
                matchingIssues.push(issues[i]);
        });
        return matchingIssues;
    }

    showMatchingGrudges(element, issues)
    {
        if(!issues || issues?.length <= 0)
            element[0].style.display="none";
        else 
        {
            element[0].style.display="flex";
            let list = element.find(".grudge-list");
            list.children().remove();
            list.append(issues.map(i => `<div class="grudge"><a href="${i.html_url}">${i.title}</div>`));
        }
    }

    checkWarnings(text)
    {
        let publicityWarning = this.element.find(".publicity")[0];
        let discordNameWarning = this.element.find(".discord")[0];
        publicityWarning.style.display = text.includes("@") ? "block" : "none";
        discordNameWarning.style.display = text.includes("#") ? "block" : "none";
    }

    activateListeners(html) {


        let modulesWarning = html.find(".active-modules")[0];
        let title = html.find(".bug-title")[0];
        let description = html.find(".bug-description")[0];
        let matching = html.find(".matching");
        let issuer = html.find(".issuer")[0];

        this.checkWarnings(issuer.value);

        html.find(".issuer").keyup(ev => {
            this.checkWarnings(ev.target.value);
        });

        html.find(".issue-label").change(ev => {
            if (ev.currentTarget.value == "bug") {
                if (game.modules.contents.filter(i => i.active).map(i => i.id).filter(i => !game.wfrp4e.config.premiumModules[i]).length > 0)
                    modulesWarning.style.display = "block";
                else
                    modulesWarning.style.display = "none";
            }
            else
                modulesWarning.style.display = "none";
        });

        html.find(".bug-title, .bug-description").keyup(async ev => {
            let text = title.value + " " + description.value;
            text = text.trim();
            if (text.length > 2) {
                this.showMatchingGrudges(matching, this.matchIssues(text));
            }
        });

        html.find(".bug-submit").click(ev => {
            let data = {};
            let form = $(ev.currentTarget).parents(".bug-report")[0];
            data.domain = $(form).find(".domain")[0].value;
            data.title = $(form).find(".bug-title")[0].value;
            data.description = $(form).find(".bug-description")[0].value;
            data.issuer = $(form).find(".issuer")[0].value;
            let label = $(form).find(".issue-label")[0].value;


            if (!data.domain || !data.title || !data.description)
                return ui.notifications.error(game.i18n.localize("BugReport.ErrorForm"))
            if (!data.issuer)
                return ui.notifications.error(game.i18n.localize("BugReport.ErrorName1"))


            data.title = `[${game.wfrp4e.config.premiumModules[data.domain]}] ${data.title}`;
            data.description = data.description + `<br/>**From**: ${data.issuer}`;

            data.labels = [this.domainKeysToLabel[data.domain]];

            if (label)
                data.labels.push(label);

            game.settings.set("wfrp4e", "bugReportName", data.issuer);

            let wfrp4eModules = Array.from(game.modules).filter(m => game.wfrp4e.config.premiumModules[m.id]);

            let versions = `<br/>foundry: ${game.version}<br/>wfrp4e: ${game.system.version}`;

            for (let mod of wfrp4eModules) {
                let modData = game.modules.get(mod.id);
                if (modData.active)
                    versions = versions.concat(`<br/>${mod.id}: ${modData.version}`);
            }

            data.description = data.description.concat(versions);
            data.description += `<br/>Active Modules: ${game.modules.contents.filter(i => i.active).map(i => i.id).filter(i => !game.wfrp4e.config.premiumModules[i]).join(", ")}`;

            this.submit(data);
            this.close();
        });
    }
}

function sidebar() {
  Hooks.on("renderSidebarTab", async (app, html) => {


    // WFRP styling makes popout sidebars really narrow because of the border so expand it
    if (app.options.id == "chat" && app.options.popOut)
    {
      html[0].style.width = "390px";
    }


    if (app.options.id == "settings")
    {
      let button = $(`<button class='bug-report'>${game.i18n.localize("BUTTON.PostBug")}</button>`);
  
      button.click(ev => {
        new BugReportFormWfrp4e().render(true);
      });
  
      button.insertAfter(html.find("#game-details"));
      
    }

    if (app instanceof RollTableDirectory)
    {

      // Auto-roll tables if table image is clicked
      html.on("click", ".rolltable img", ev => {
        let table = game.tables.get($(ev.currentTarget).parent().attr("data-document-id"));
        let key = table.getFlag("wfrp4e", "key");
        let column = table.getFlag("wfrp4e", "column");

        if (!key)
          return
        
        game.wfrp4e.tables.formatChatRoll(key, {}, column).then(text => {
          let chatOptions = game.wfrp4e.utility.chatDataSetup(text, game.settings.get("core", "rollMode"), true);
          chatOptions.speaker = {alias: table.name};
          ChatMessage.create(chatOptions);
          ui.sidebar.activateTab("chat");
        });
      });
    }


    if (app instanceof ActorDirectory)
    {
      let button = $(`<button class='character-creation'>${game.i18n.localize("BUTTON.CharacterCreation")}</button>`);
  
      button.click(ev => {
        new game.wfrp4e.apps.CharGenWfrp4e().render(true);
      });
  
      button.insertAfter(html.find(".header-actions"));
      
    }
  });
}

function rolltable() {
    Hooks.on("preCreateTableResult", (result, data) => {
        if (!data.img)
            result.updateSource({"img" : "icons/svg/d10-grey.svg"});
    });

    Hooks.on("preCreateRollTable", (table, data) => {
        if (!data.img)
            table.updateSource({"img" : "systems/wfrp4e/ui/buttons/d10.webp"});
    });
}

class StatBlockParser extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "stat-parser";
        options.template = "systems/wfrp4e/templates/apps/stat-parser.hbs";
        options.height = 600;
        options.width = 600;
        options.minimizable = true;
        options.title = "Stat Block Parser";
        return options;
    }

    getData() {

        let types = game.system.template.Actor.types;
        return { types }
    }


    async _updateObject(event, formData) {
        let {name, type, data, items} = await StatBlockParser.parseStatBlock(formData.statBlock, this.object.type);
        await this.object.update({name, type, data});
        await this.object.createEmbeddedDocuments("Item", items);
    }

    static async parseStatBlock(statString, type = "npc") {
        let model = duplicate(game.system.model.Actor[type]);

        let blockArray = statString.split("\n");
        let name = blockArray[0].split("")[0].split(" ").filter(f => !!f);

        name = name.map(word => {
            if (word == "VON")
                return word.toLowerCase();

            word = word.toLowerCase();
            word = word[0].toUpperCase() + word.substring(1, word.length);
            return word;
        });
        name = name.join(" ");

        let status  = -1;
        if (blockArray[0].includes("("))
            status = blockArray[0];
        else if (blockArray[1].includes("("))
            status = blockArray[1];
        
        if (status != -1 && hasProperty(model, "details.status.value"))
        {
            status = status.substring(status.indexOf("(")+1, status.indexOf(")"));
            model.details.status.value = status[0] + status.slice(1).toLowerCase();
        }

        let tableIndex = blockArray.findIndex(v => v.includes(" WS "));
        let characteristicNames = blockArray[tableIndex].split(" ");
        let characteristicValues = blockArray[tableIndex + 1].split(" ");

        for (let i = 0; i < characteristicNames.length; i++) {
            if (characteristicNames[i] == "Agi")
                characteristicNames[i] = "Ag";
            if (characteristicNames[i].toLowerCase() == "m") {
                model.details.move.value = Number(characteristicValues[i]);
                continue;
            }
            if (characteristicNames[i].toLowerCase() == "w")
                continue;

            try {
                model.characteristics[characteristicNames[i].toLowerCase()].initial = Number(characteristicValues[i]);
            }
            catch { }
        }


        let skillRegex = /([a-zA-Z\s]+?)(?:\((.+?)\)|)\s?(\d{1,3}|)(?:,|$)/gm;
        let talentRegex = /(?:,?(.+?)(\d{1,2})?(?:\((.+?)\)\s*(\d{1,2})?|,|$))/gm;
        let traitRegex = /(?:,?(.+?)(\+?\d{1,2}\+?)?\s*?(?:\((.+?)\)\s*(\+?\d{1,2})?|,|$))/gm;

        let skillBlockIndexStart = blockArray.findIndex(v => v.split(" ")[0].includes(game.i18n.localize("Skills")));
        let talentBlockIndexStart = blockArray.findIndex(v => v.split(" ")[0].includes(game.i18n.localize("Talents")));
        let traitBlockIndexStart = blockArray.findIndex(v => v.split(" ")[0].includes(game.i18n.localize("Traits")));
        let trappingBlockIndexStart = blockArray.findIndex(v => v.split(" ")[0].includes(game.i18n.localize("Trappings")) || v.split(" ")[0].includes(game.i18n.localize("Possessions")));


        let skillBlockIndex = skillBlockIndexStart;
        let talentBlockIndex = talentBlockIndexStart;
        let traitBlockIndex = traitBlockIndexStart;
        let trappingBlockIndex = trappingBlockIndexStart;

        let skillBlock = blockArray[skillBlockIndex] || "";
        let talentBlock = blockArray[talentBlockIndex] || "";
        let traitBlock = blockArray[traitBlockIndex] || "";
        let trappingBlock = blockArray[trappingBlockIndex] || "";

        while (skillBlockIndex >= 0) {
            skillBlockIndex++;
            if (skillBlockIndex == talentBlockIndexStart || skillBlockIndex == traitBlockIndexStart || skillBlockIndex == trappingBlockIndexStart || skillBlockIndex >= blockArray.length)
                break;

            skillBlock = skillBlock.concat(" " + blockArray[skillBlockIndex]);
        }
        while (talentBlockIndex >= 0) {
            talentBlockIndex++;
            if (talentBlockIndex == skillBlockIndexStart || talentBlockIndex == traitBlockIndexStart || talentBlockIndex == trappingBlockIndexStart || talentBlockIndex >= blockArray.length)
                break;

            talentBlock = talentBlock.concat(" " + blockArray[talentBlockIndex]);
        }
        while (traitBlockIndex >= 0) {
            traitBlockIndex++;
            if (traitBlockIndex == skillBlockIndexStart || traitBlockIndex == talentBlockIndexStart || traitBlockIndex == trappingBlockIndexStart || traitBlockIndex >= blockArray.length)
                break;

            traitBlock = traitBlock.concat(" " + blockArray[traitBlockIndex]);
        }
        while (trappingBlockIndex >= 0) {
            trappingBlockIndex++;
            if (trappingBlockIndex == skillBlockIndexStart || trappingBlockIndex == talentBlockIndexStart || trappingBlockIndex == traitBlockIndexStart || trappingBlockIndex >= blockArray.length)
                break;

            trappingBlock = trappingBlock.concat(" " + blockArray[trappingBlockIndex]);
        }



        let skillStrings = skillBlock.substring(skillBlock.indexOf(":")+1);
        let talentStrings = talentBlock.substring(talentBlock.indexOf(":")+1);
        let traitStrings = traitBlock.substring(traitBlock.indexOf(":")+1);
        let trappingStrings = trappingBlock.substring(trappingBlock.indexOf(":")+1);


        let skillMatches = skillStrings.matchAll(skillRegex);
        let talentMatches = talentStrings.matchAll(talentRegex);
        let traitMatches = traitStrings.matchAll(traitRegex);
        //let trappingMatches = skillStrings.matchAll(trappingRegex)


        let skills = [];
        let talents = [];
        let traits = [];
        let trappings = [];


        for (let match of skillMatches){

            /**
             * 3 Cases
             * 1. Intution 67
             * 2. Language (Magick) 52
             * 3. Melee (Basic 56, Polearm 62, ...)
             */

            let skillName = match[1]; // Name of the skill, should always exist
            let skillGroup = match[2]; // either null (case 1), a word(s) (case 2) or a group of words-values pairs (case 3)
            let skillValue = match[3];  // Either null (case 3) or a value (case 1 and 2)

            let skillSearches = [];
            let skillItems = [];

            // Case 3
            if (!Number.isNumeric(skillValue))
            {
                let innerMatches = skillGroup.matchAll(skillRegex); // rerun regex on inner group
                for (let inner of innerMatches)
                {
                    skillSearches.push({name : skillName, group : inner[1], value : inner[3]});
                }
            }
            else // case 1 and 2
            {
                skillSearches.push({name : skillName, group : skillGroup, value : skillValue});
            }

            skillSearches.forEach(s => {
                s.name = s.name?.trim();
                s.group = s.group?.trim();
                s.value = s.value?.trim();
            });


            for(let search of skillSearches)
            {
                let skillItem;
                try {skillItem = await WFRP_Utility$1.findSkill(`${search.name} ${search.group ? "(" + search.group + ")" : ""}`.trim());}
                catch {}
                if (!skillItem) {
                    console.error("Could not find " + search.name);
                    ui.notifications.error(game.i18n.format("ERROR.Parser", {name: search.name}), { permanent: true });
                    continue
                }
                else skillItem = skillItem.toObject();

                skillItem.system.advances.value = Number(search.value) - model.characteristics[skillItem.system.characteristic.value].initial;

                skillItems.push(skillItem);

            }
            skills = skills.concat(skillItems);
        }
        
        for (let match of talentMatches){

            let talentName = match[1].trim();
            let talentAdvances = parseInt(match[2] || match[4]); // could be match 2 or 4 depending on if there's a specialization
            let talentSpec = match[3]?.trim();

            let talentItem;
            try { talentItem = await WFRP_Utility$1.findTalent(talentName); }
            catch { }

            if (!talentItem) {
                console.error("Could not find " + talentName);
                ui.notifications.error(game.i18n.format("ERROR.Parser", {name: talentName}), { permanent: true });
                continue
            }
            talentItem = talentItem.toObject();

            if (talentName == game.i18n.localize("NAME.Doomed"))
            {
                talentItem.system.description.value += `<br><br><em>${talentSpec}</em>`;
            }
            else if (talentName == game.i18n.localize("NAME.Etiquette"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("Social Group"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == game.i18n.localize("NAME.Resistance"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("the associated Threat"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == game.i18n.localize("NAME.AcuteSense"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("Sense"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == game.i18n.localize("NAME.Strider"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("the Terrain"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == game.i18n.localize("NAME.Savant"))
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace(game.i18n.localize("chosen Lore"), match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentName == "Craftsman")
            {
                talentItem.system.tests.value = talentItem.system.tests.value.replace("any one", match[3]);
                talentItem.name += ` (${talentSpec})`;
            }
            else if (talentSpec)
                talentItem.name += ` (${talentSpec})`;

            talentItem.system.advances.value = 1;

            if (Number.isNumeric(talentAdvances))
            {
                for (let i = 1; i < talentAdvances; i++)
                    talents.push(talentItem);

            }
            talents.push(talentItem);
        }

        for (let match of traitMatches) {

            let traitName = match[1];
            let traitVal = match[2] || match[4]; // could be match 2 or 4 depending on if there's a specialization
            let traitSpec = match[3];


            let traitItem;
            try {
                traitItem = await WFRP_Utility$1.findItem(traitName, "trait");
            }
            catch { }
            if (!traitItem) {
                console.error("Could not find " + traitName);
                ui.notifications.error(game.i18n.format("ERROR.Parser", {name: traitName}), { permanent: true });
                continue
            }
            traitItem = traitItem.toObject();

            if (Number.isNumeric(traitVal))
            {
                traitItem.system.specification.value = traitName.includes('Weapon','Horns','Tail','Tentacles','Bite') ? traitVal - parseInt(characteristicValues[3]/10) : traitVal;
                traitItem.name = (traitItem.name +  ` ${traitSpec ? "("+ traitSpec + ")" : ""}`).trim();
            }
            else 
                traitItem.system.specification.value = traitSpec;

            traits.push(traitItem);
        }

        if (trappingStrings)
        {
            for (let trapping of trappingStrings.split(",")) {
    
                let trappingItem = await WFRP_Utility$1.findItem(trapping, game.wfrp4e.config.trappingItems);
                if (!trappingItem) {
                    trappingItem = new ItemWfrp4e({ img: "systems/wfrp4e/icons/blank.png", name: trapping, type: "trapping", data: game.system.model.Item.trapping });
                    trappingItem.updateSource({"trappingType.value" : "misc"});
                }
                trappings.push(trappingItem.toObject());
            }
        }

        let moneyItems = await WFRP_Utility$1.allMoneyItems() || [];
        // moneyItems = moneyItems.map(i => i.toObject())
        moneyItems = moneyItems.sort((a, b) => (a.system.coinValue > b.system.coinValue) ? -1 : 1);
        moneyItems.forEach(m => m.system.quantity.value = 0);

        skills.forEach(t => {
            delete t._id;
        });

        trappings.forEach(t => {
            delete t._id;
        });
        
        talents.forEach(t => {
            delete t._id;
        });
        traits.forEach(t => {
            delete t._id;
        });
        let effects = trappings.reduce((total, trapping) => total.concat(trapping.effects), []).concat(talents.reduce((total, talent) => total.concat(talent.effects), [])).concat(traits.reduce((total, trait) => total.concat(trait.effects), []));
        effects = effects.filter(e => !!e);
        effects = effects.filter(e => e.transfer);
    
        effects.forEach(e => {
            let charChanges = e.changes.filter(c => c.key.includes("characteristics"));
            for(let change of charChanges)
            {
                let split = change.key.split(".");
                let target = split.slice(1).join(".");
                setProperty(model, target, (getProperty(model, target) + (-1 * change.value))); // Counteract effect changes
            }
        });

        return { name, type, data: model, items: skills.concat(talents).concat(traits).concat(trappings).concat(moneyItems), effects }

    }

}

function entryContext () {

  /**
   * Add right click option to actors to add all basic skills
   */
  Hooks.on("getActorDirectoryEntryContext", async (html, options) => {
    options.push(
      {
        name: game.i18n.localize("ACTOR.AddBasicSkills"),
        condition: game.user.isGM,
        icon: '<i class="fas fa-plus"></i>',
        callback: target => {
          const actor = game.actors.get(target.attr('data-document-id'));
          actor.addBasicSkills();
        }
      });
    options.push(
      {

        name: game.i18n.localize("ACTOR.ClearMount"),
        icon: '<i class="fas fa-horse"></i>',
        callback: target => {
          const actor = game.actors.get(target.attr('data-document-id'));
          return actor.update({
            "system.status.mount": {
              "id": "",
              "mounted": false,
              "isToken": false,
              "tokenData": {
                "scene": "",
                "token": ""
              }
            }
          })
        }
      });
    options.push(
      {

        name: game.i18n.localize("ACTOR.ImportStatBlock"),
        condition: game.user.isGM,
        icon: '<i class="fa fa-download"></i>',
        callback: target => {
          const actor = game.actors.get(target.attr('data-document-id'));
          new StatBlockParser(actor).render(true);
        }
      });
  });

  /**
 * Add right click option to damage chat cards to allow application of damage
 * Add right click option to use fortune point on own rolls
 */
  Hooks.on("getChatLogEntryContext", (html, options) => {
    let canApply = li => game.messages.get(li.attr("data-message-id")).getOpposedTest() || li.find(".dice-roll").length > 0;
    let canApplyFortuneReroll = function (li) {
      //Condition to have the fortune contextual options:
      //Be owner of the actor
      //actor have fortune point
      //Own the roll
      //Once per roll (or at least, not on a reroll card)
      //Test must be failed 
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return test && test.actor.isOwner && test.actor.status.fortune?.value > 0 && test.result.outcome == "failure" && !test.fortuneUsed.reroll

    };
    let canApplyFortuneAddSL = function (li) {
      //Condition to have the fortune contextual options:
      //Be owner of the actor
      //Have fortune point
      //Own the roll
      //Once per roll (or at least, not on a reroll card)
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return test && test.actor.isOwner && test.actor.status.fortune?.value > 0 && !test.fortuneUsed.SL 
    };
    let canApplyDarkDeals = function (li) {
      //Condition to have the darkdeak contextual options:
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return test && test.actor.isOwner && test.actor.type == "character"
    };

    let canGMReroll = function (li) {
      //Condition to have the darkdeak contextual options:
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return test && game.user.isGM
    };

    let canTarget = function (li) {
      //Condition to be able to target someone with the card
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return test && test.actor.isOwner
    };

    let canCompleteUnopposed = function (li) {
      //Condition to be able to target someone with the card
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return game.user.isGM && test && test.opposedMessages.length >= 2
    };

    let canApplyAllDamage = function (li) {
      //Condition to be able to target someone with the card
      //Be owner of character
      //Own the roll
      let message = game.messages.get(li.attr("data-message-id"));
      let test = message.getTest();
      return game.user.isGM &&  test && test.opposedMessages.length >= 2 && test.opposedMessages.some(m => m?.getOppose()?.resultMessage)
    };

    options.push(
      {
        name: game.i18n.localize("CHATOPT.ApplyDamage"),
        icon: '<i class="fas fa-user-minus"></i>',
        condition: canApply,
        callback: li => {

          if (li.find(".dice-roll").length) {
            let amount = li.find('.dice-total').text();
            canvas.tokens.controlled.map(i => i.document.actor).concat(Array.from(game.user.targets).map(i => i.document.actor)).forEach(a => a.applyBasicDamage(amount));
          }
          else {
            let message = game.messages.get(li.attr("data-message-id"));
            let opposedTest = message.getOpposedTest();

            if (!opposedTest.defenderTest.actor.isOwner)
              return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

            opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.NORMAL)
              .then(updateMsg => OpposedWFRP.updateOpposedMessage(updateMsg, message.id));
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.ApplyDamageNoAP"),
        icon: '<i class="fas fa-user-shield"></i>',
        condition: canApply,
        callback: li => {
          if (li.find(".dice-roll").length) {
            let amount = li.find('.dice-total').text();
            canvas.tokens.controlled.map(i => i.document.actor).concat(Array.from(game.user.targets).map(i => i.document.actor)).forEach(a => a.applyBasicDamage(amount, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP }));
          }
          else {
            let message = game.messages.get(li.attr("data-message-id"));
            let opposedTest = message.getOpposedTest();

            if (!opposedTest.defenderTest.actor.isOwner)
              return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

            opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.IGNORE_AP)
              .then(updateMsg => OpposedWFRP.updateOpposedMessage(updateMsg, message.id));
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.ApplyDamageNoTB"),
        icon: '<i class="fas fa-fist-raised"></i>',
        condition: canApply,
        callback: li => {
          if (li.find(".dice-roll").length) {
            let amount = li.find('.dice-total').text();
            canvas.tokens.controlled.map(i => i.document.actor).concat(Array.from(game.user.targets).map(i => i.document.actor)).forEach(a => a.applyBasicDamage(amount, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_TB }));
          }
          else {
            let message = game.messages.get(li.attr("data-message-id"));
            let opposedTest = message.getOpposedTest();

            if (!opposedTest.defenderTest.actor.isOwner)
              return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

            opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.IGNORE_TB)
              .then(updateMsg => OpposedWFRP.updateOpposedMessage(updateMsg, message.id));
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.ApplyDamageNoTBAP"),
        icon: '<i class="fas fa-skull-crossbones"></i>',
        condition: canApply,
        callback: li => {
          if (li.find(".dice-roll").length) {
            let amount = li.find('.dice-total').text();
            canvas.tokens.controlled.map(i => i.document.actor).concat(Array.from(game.user.targets).map(i => i.document.actor)).forEach(a => a.applyBasicDamage(amount, { damageType: game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL }));
          }
          else {
            let message = game.messages.get(li.attr("data-message-id"));
            let opposedTest = message.getOpposedTest();

            if (!opposedTest.defenderTest.actor.isOwner)
              return ui.notifications.error(game.i18n.localize("ErrorDamagePermission"))

            opposedTest.defenderTest.actor.applyDamage(opposedTest, game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL)
              .then(updateMsg => OpposedWFRP.updateOpposedMessage(updateMsg, message.id));
          }
        }
      },
      {
        name: game.i18n.localize("CHATOPT.UseFortuneReroll"),
        icon: '<i class="fas fa-dice"></i>',
        condition: canApplyFortuneReroll,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          test.actor.useFortuneOnRoll(message, "reroll");
        }
      },
      {
        name: game.i18n.localize("CHATOPT.Reroll"),
        icon: '<i class="fas fa-dice"></i>',
        condition: canGMReroll,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          test.reroll();
        }
      },
      {
        name: game.i18n.localize("CHATOPT.UseFortuneSL"),
        icon: '<i class="fas fa-plus-square"></i>',
        condition: canApplyFortuneAddSL,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          test.actor.useFortuneOnRoll(message, "addSL");
        }
      },
      {
        name: game.i18n.localize("CHATOPT.DarkDeal"),
        icon: '<i class="fas fa-pen-nib"></i>',
        condition: canApplyDarkDeals,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          test.actor.useDarkDeal(message);
        }
      },
      {
        name: game.i18n.localize("CHATOPT.OpposeTarget"),
        icon: '<i class="fas fa-crosshairs"></i>',
        condition: canTarget,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          let targets = Array.from(game.user.targets).map(t => t.actor.speakerData(t.document));

          test.context.targets = test.context.targets.concat(targets);
          targets.map(t => WFRP_Utility$1.getToken(t)).forEach(t => {
            test.createOpposedMessage(t);
          });
        }
      },
      {
        name: game.i18n.localize("CHATOPT.CompleteUnopposed"),
        icon: '<i class="fas fa-angle-double-down"></i>',
        condition: canCompleteUnopposed,
        callback: li => {

          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          test.opposedMessages.forEach(message => {
            if (message)
            {
              let oppose = message.getOppose();
              oppose.resolveUnopposed();
            }
          });
        }
      },
      {
        name: game.i18n.localize("CHATOPT.ApplyAllDamage"),
        icon: '<i class="fas fa-user-minus"></i>',
        condition: canApplyAllDamage,
        callback: li => {
          let message = game.messages.get(li.attr("data-message-id"));
          let test = message.getTest();
          for (let message of test.opposedMessages) {
            if (message) {
              let opposedTest = message.getOppose();
              if (!opposedTest.defenderTest.actor.isOwner) {
                ui.notifications.error(game.i18n.localize("ErrorDamagePermission"));
              } else {
                opposedTest.defender.applyDamage(opposedTest.resultMessage.getOpposedTest(), game.wfrp4e.config.DAMAGE_TYPE.NORMAL)
                  .then(updateMsg => OpposedWFRP.updateOpposedMessage(updateMsg, opposedTest.resultMessage.id));
              }
            }
          }
        }
      }
    );
  });
}

function token() {
  // Adds tooltips to conditions in the condition menu
  Hooks.on("renderTokenHUD", async (obj, html) => {
    for (let condition of html.find("img.effect-control")) {
      condition.title = game.wfrp4e.config.conditions[condition.dataset["statusId"]];
      if (condition.dataset["statusId"] == "dead")
        condition.title = "Dead";
    }
  });

  Hooks.on("preUpdateToken", (token, data) => 
  {
      // AreaHelpers.checkTokenUpdate(token, data, canvas.templates.placeables);
  });



  Hooks.on("createToken", async (token) => {

    if(game.user.isUniqueGM) // Prevents multiple mount tokens
    {
      let scene = token.parent;

      if (token.actor.isMounted && canvas.scene.id == scene.id)
      {
        let mount = token.actor.mount;
        let mountToken = await mount.getTokenDocument();
        mountToken.updateSource({ x : token.x, y : token.y, hidden: token.hidden });

        // Shift token slightly if same size
        if (mountToken.actor.details.size.value == token.actor.details.size.value)
        {
          mountToken.updateSource({
            x : mountToken.x + canvas.grid.size/4,
            y : mountToken.y + canvas.grid.size/4
          });
        }
        mountToken = (await scene.createEmbeddedDocuments("Token", [mountToken]))[0];
        await token.update({"flags.wfrp4e.mount" : mountToken.id }); // place mount id in token so when it moves, the mount moves (see updateToken)
        token.zIndex = 1; // Ensure rider is on top

        if (!mountToken.actorLink)
        {
            let tokenData = {
              scene : scene._id,
              token : mountToken._id
            };
          token.actor.update({"system.status.mount.isToken" : true, "system.status.mount.tokenData" : tokenData});
        }
      }

      AreaHelpers.checkAreas(scene);
    }

  });

  Hooks.on("updateToken", (token, updateData, options) => {
      let scene = token.parent;
      if (game.user.isUniqueGM)
      {
        if (hasProperty(token, "flags.wfrp4e.mount") && (updateData.x || updateData.y) && scene.id == canvas.scene.id)
        {
          if (canvas.tokens.get(token.id).actor.isMounted)
          {
            let mountId = token.getFlag("wfrp4e", "mount");
            let tokenUpdate = {_id : mountId, x : token.x, y: token.y };
            if (token.actor.details.size.value == token.actor.mount.details.size.value)
            {
              tokenUpdate.x += canvas.grid.size / 4;
              tokenUpdate.y += canvas.grid.size / 4;
            }
            scene.updateEmbeddedDocuments("Token", [tokenUpdate]);

          }
        }
        if (updateData.x || updateData.y)
        {
          AreaHelpers.checkAreas(scene);
        }
      }
  });

  Hooks.on('renderTokenHUD', (hud, html) => {
    _addMountButton(hud, html);
    _addPassengerButton(hud, html);
  });

  Hooks.on("refreshToken", token => {
    if (token.document?.getFlag("wfrp4e", "hidePassengers"))
      token.passengers?.destroy();
    else
      passengerRender(token);
  });



  
  function _addMountButton(hud, html)
  {
    if (canvas.tokens.controlled.length == 2)// && canvas.tokens.controlled[0].actor.details.size.value != canvas.tokens.controlled[1].actor.details.size.value)
    {
      const button = $(
        `<div class='control-icon'><i class="fas fa-horse"></i></div>`
      );
      button.attr(
        'title',
        'Mount'
      );

      button.mousedown(event => {
        let token1 = canvas.tokens.controlled[0].document;
        let token2 = canvas.tokens.controlled[1].document;

        if (!token1 || !token2)
          return  

        let mountee = hud.object.document;
        let mounter = hud.object.document.id == token1.id ? token2 : token1;
        if (game.wfrp4e.config.actorSizeNums[mounter.actor.details.size.value] > game.wfrp4e.config.actorSizeNums[mountee.actor.details.size.value])
        {
          let temp = mountee;
          mountee = mounter;
          mounter = temp;
        }

        let tokenData = undefined;
        if (!mountee.actorLink) {
          tokenData = {
            scene: canvas.scene.id,
            token: mountee.id
          };
          if (mounter.actorLink)
            ui.notifications.warn(game.i18n.localize("WarnUnlinkedMount"));
        }
        mounter.actor.update({ "system.status.mount.id": mountee.actorId, "system.status.mount.mounted": true, "system.status.mount.isToken": !mountee.actorLink, "system.status.mount.tokenData": tokenData });
        canvas.scene.updateEmbeddedDocuments("Token", [{ "flags.wfrp4e.mount": mountee.id, _id: mounter.id }, { _id: mounter.id, x: mountee.x, y: mountee.y }]);
        mounter.zIndex = 1; // Ensure rider is on top


      });
      html.find('.col.right').append(button);
    }
  }

  function _addPassengerButton(hud, html)
  {
      if (hud.object.actor?.type != "vehicle")
      {
        return
      }

      const button = $(
        `<div class='control-icon ${hud.object.document.getFlag("wfrp4e", "hidePassengers") ? "active" : ""}'><i class="fa-solid fa-user-slash"></i></div>`
      );
      button.attr(
        'title',
        game.i18n.localize("WFRP4E.TogglePassengers")
      );

      button.mousedown(event => {
        let newState = !hud.object.document.getFlag("wfrp4e", "hidePassengers");
        event.currentTarget.classList.toggle("active", newState);
        
        hud.object.document.setFlag("wfrp4e", "hidePassengers", newState).then(() => {
          // newState ? hud.object.passengers?.destroy() : passengerRender(hud.object);
        });
      });
      html.find('.col.right').append(button);

  }

}

function handlebars () {

    Hooks.on("init", () => {
        Handlebars.registerHelper("ifIsGM", function (options) {
            return game.user.isGM ? options.fn(this) : options.inverse(this)
        });

        Handlebars.registerHelper("isGM", function (options) {
            return game.user.isGM
        });

        Handlebars.registerHelper("config", function (key) {
            return game.wfrp4e.config[key]
        });

        Handlebars.registerHelper("configLookup", function (obj, key) {
            if (obj && key)
                return game.wfrp4e.config[obj]?.[key]
            
        });

        Handlebars.registerHelper("array", function (array, cls) {
            if (typeof cls == "string")
                return array.map((value, index) => `<a data-index=${index} class="${cls}">${value}</a>`).join(`<h1 class="${cls} comma">, </h1>`)
            else
                return array.join(", ")
        });

        Handlebars.registerHelper("hasProperty", function (obj, key) 
        {
            return hasProperty(obj, key);
        });    

        Handlebars.registerHelper("tokenImg", function(actor) {
            let tokens = actor.getActiveTokens();
            let tokenDocument = actor.prototypeToken;
            if(tokens.length == 1) {
                tokenDocument = tokens[0].document;
            }
            return tokenDocument.hidden ? "systems/wfrp4e/tokens/unknown.png" : tokenDocument.texture.src;
        });

        Handlebars.registerHelper("tokenName", function(actor) {
            let tokens = actor.getActiveTokens();
            let tokenDocument = actor.prototypeToken;
            if(tokens.length == 1) {
                tokenDocument = tokens[0].document;
            }
            return tokenDocument.hidden ? "???" : tokenDocument.name;
        });

        Handlebars.registerHelper("settings", function (key) {
            return game.settings.get("wfrp4e", key);
        });
});
}

function templates() 
{
    Hooks.on("updateMeasuredTemplate", (template, data, options, user) => 
    {
        if (game.user.id == user && (data.x || data.y))
        {
            AreaHelpers.checkAreas(template.parent);
        }
    });

    Hooks.on("createMeasuredTemplate", (template, options, user) => 
    {
        if (game.user.id == user)
        {
            AreaHelpers.checkAreas(template.parent);
        }
    });


}

function registerHooks() {
    init();
    ready();
    canvas$1();
    chat();
    combat();
    controlButtons();
    hotbarDrop();
    journal();
    sidebar();
    rolltable();
    entryContext();
    token();
    handlebars();
    i18n();
    settings();
    keepId();
    templates();
    notes();


    Hooks.on("renderApplication", (app, html, data) => {
        WFRP_Utility$1.log(`Rendering ${app.constructor.name}: `, undefined, data);
    });

}

/** Class for the WFRP4e Item Browser that collects all items in the world and compendia and
 *  offers functionality to filter through them to search easily. By default, you can filter
 *  through the name and description, as well as item type. If an item type is selected, more
 *  filters are shown that only apply to those types (mostly). If you select Weapon - you can
 *  then select which weapon group, reach, etc. 
*/
class BrowserWfrp4e extends Application {
  constructor(app) {
    super(app);

    // Initializes filters to false
    this.filters = {
      type: {
        "ammunition": { display: "Ammunition", value: false },
        "armour": { display: "Armour", value: false },
        "career": { display: "Career", value: false },
        "container": { display: "Container", value: false },
        "critical": { display: "Critical", value: false },
        "disease": { display: "Disease", value: false },
        "injury": { display: "Injury", value: false },
        "money": { display: "Money", value: false },
        "mutation": { display: "Mutation", value: false },
        "prayer": { display: "Prayer", value: false },
        "psychology": { display: "Psychology", value: false },
        "talent": { display: "Talent", value: false },
        "trapping": { display: "Trapping", value: false },
        "skill": { display: "Skill", value: false },
        "spell": { display: "Spell", value: false },
        "trait": { display: "Trait", value: false },
        "weapon": { display: "Weapon", value: false }
      },
      attribute: {
        name: "",
        description: "",
        worldItems: true,
      },
      // Various type specific filters that are shown based on type selected. 
      dynamic: {
        careergroup: { value: "", exactMatch: true, type: ["career"], show: false },
        class: { value: "", type: ["career"], show: false },
        level: { value: "", type: ["career"], show: false },
        statusTier: { value: "", type: ["career"], show: false },
        statusStanding: { value: "", relation: "", type: ["career"], show: false },
        characteristics: { value: [], type: ["career"], show: false },
        ammunitionType: { value: "", exactMatch: true, type: ["ammunition"], show: false },
        skills: { value: [], type: ["career"], show: false },
        talents: { value: [], type: ["career"], show: false },
        encumbrance: { value: "", relation: "", type: ["ammunition", "armour", "weapon", "container", "trapping"], show: false },
        availability: { value: "", type: ["ammunition", "armour", "weapon", "container", "trapping"], show: false },
        modifiesDamage: { value: false, type: ["ammunition"], show: false },
        modifiesRange: { value: false, type: ["ammunition"], show: false },
        qualitiesFlaws: { value: [], type: ["ammunition", "armour", "weapon"], show: false },
        armorType: { value: "", type: ["armour"], show: false },
        protects: { value: { head: true, body: true, arms: true, legs: true }, type: ["armour"], show: false },
        carries: { value: "", relation: "", type: ["container"], show: false },
        location: { value: "", type: ["critical", "injury"], show: false },
        wounds: { value: "", relation: "", type: ["critical"], show: false },
        symptoms: { value: [], type: ["disease"], show: false },
        mutationType: { value: "", type: ["mutation"], show: false },
        god: { value: "", type: ["prayer"], show: false },
        prayerType: { value: "", type: ["prayer"], show: false },
        range: { value: "", type: ["prayer", "spell"], show: false },
        duration: { value: "", type: ["prayer", "spell"], show: false },
        target: { value: "", type: ["prayer", "spell"], show: false },
        cn: { value: "", relation: "", type: ["spell"], show: false },
        magicMissile: { value: false, type: ["spell"], show: false },
        aoe: { value: false, type: ["spell"], show: false },
        lore: { value: "", type: ["spell"], show: false },
        extendable: { value: "", type: ["spell"], show: false },
        max: { value: "", type: ["talent"], show: false },
        tests: { value: "", type: ["talent"], show: false },
        trappingType: { value: "", type: ["trapping"], show: false },
        characteristic: { value: "", type: ["skill"], show: false },
        grouped: { value: "", type: ["skill"], show: false },
        advanced: { value: "", type: ["skill"], show: false },
        rollable: { value: false, type: ["trait"], show: false },
        weaponGroup: { value: "", type: ["weapon"], show: false },
        reach: { value: "", type: ["weapon"], show: false },
        weaponRange: { value: "", relation: "", type: ["weapon"], show: false },
        melee: { value: false, type: ["weapon"], show: false },
        ranged: { value: false, type: ["weapon"], show: false },
        twohanded: { value: false, type: ["weapon"], show: false },
        ammunitionGroup: { value: "", type: ["weapon"], show: false },
      }
    };

    // Different values used to filter. As items are read, different aspects are accumulated, such as lores, which are then selectable to filter by.
    this.careerGroups = [];
    this.careerClasses = [];
    this.gods = [];
    this.careerTiers = [1, 2, 3, 4];
    this.statusTiers = ["Gold", "Silver", "Brass"];
    this.lores = foundry.utils.deepClone(game.wfrp4e.config.magicLores);
    this.lores["arcane"] = game.i18n.localize("NAME.Arcane");

  }

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "wfrp4e-browser";
    options.template = "systems/wfrp4e/templates/browser/browser.hbs";
    options.classes.push("wfrp4e", "wfrp-browser");
    options.resizable = true;
    options.height = 900;
    options.width = 600;
    options.minimizable = true;
    options.title = "WFRP Browser";
    return options;
  }

  _getHeaderButtons() {
    let buttons = super._getHeaderButtons();
    // Add "Post to chat" button
    if (game.user.isGM) {
      buttons.push(
        {
          class: "import",
          icon: "fas fa-import",
          onclick: async ev => this.importResults()
        });
    }
    return buttons
  }

  // Save scroll positions and apply current filter when rendering
  async _render(force = false, options = {}) {
    await this.loadItems();
    this._saveScrollPos(); // Save scroll positions
    await super._render(force, options);
    this._setScrollPos(); // Save scroll positions
    this.applyFilter(this._element);
  }


  // Pass filter data to template
  getData() {
    let data = super.getData();
    data.filters = this.filters;
    data.relations = ["<", "<=", "==", ">=", ">"];
    data.availability =  game.wfrp4e.config.availability;
    data.ammunitionGroups =  game.wfrp4e.config.ammunitionGroups;
    data.locations = ["WFRP4E.Locations.head", "WFRP4E.Locations.body", "WFRP4E.Locations.arm", "WFRP4E.Locations.leg"].map(game.i18n.localize.bind(game.i18n));
    data.mutationTypes =  game.wfrp4e.config.mutationTypes;
    data.armorTypes =  game.wfrp4e.config.armorTypes;
    data.gods = this.gods;
    data.weaponGroups =  game.wfrp4e.config.weaponGroups;
    data.weaponReaches =  game.wfrp4e.config.weaponReaches;
    data.talentMax =  game.wfrp4e.config.talentMax;
    data.trappingTypes =  game.wfrp4e.config.trappingTypes;
    data.lores = this.lores;
    data.characteristics =  game.wfrp4e.config.characteristicsAbbrev;
    data.skillTypes =  game.wfrp4e.config.skillTypes;
    data.skillGroup =  game.wfrp4e.config.skillGroup;
    data.prayerTypes =  game.wfrp4e.config.prayerTypes;
    data.careerGroups = this.careerGroups;
    data.careerClasses = this.careerClasses;
    data.careerTiers = this.careerTiers;
    data.statusTiers = this.statusTiers;
    data.items = this.items;

    return data;
  }


  /**
   * Goes through each compendium and if it is an Item compendium,
   * loads the items with addItems(). Then it will add all the world
   * items.
   */
  async loadItems() {
    this.items = [];
    this.filterId = 0;

    let packCount = game.packs.size;
    let packCounter = 0;

    game.wfrp4e.DocumentCache = game.wfrp4e.DocumentCache || {};
  
    async function cacheDocuments(pack, documents) {
      game.wfrp4e.DocumentCache[pack.collection] = documents;
    }
    
  
    async function getCachedDocuments(pack) {
      if (game.wfrp4e.DocumentCache.hasOwnProperty(pack.collection)) {
        return game.wfrp4e.DocumentCache[pack.collection];
      }
    
      const documents = await pack.getDocuments();
      cacheDocuments(pack, documents);
      return documents;
    }

    for (let p of game.packs) {
      packCounter++;
      SceneNavigation.displayProgressBar({label: game.i18n.localize("BROWSER.LoadingBrowser"), pct: Math.round((packCounter / packCount) * 100) });

      if (p.metadata.type == "Item" && (game.user.isGM || !p.private)) {
        const content = await getCachedDocuments(p);
        this.addItems(content);
      }
    }
    this.addItems(game.items.contents.filter(i => i.permission > 1));
    this.items = this.items.sort((a, b) => (a.name.toLowerCase() > b.name.toLowerCase()) ? 1 : -1);
    this.careerGroups.sort((a, b) => (a > b) ? 1 : -1);
    this.careerClasses.sort((a, b) => (a > b) ? 1 : -1);
  }

  /**
   * addItems is used when loading items upon startup, it looks at each item
   * and determines if some values need to be recorded. For instance, we want 
   * to know all the career groups of all the careers being loaded, or all the 
   * lores of spells. This data is then made available to the user to filter by.
   * 
   * @param {Array} itemList List of items to be added
   */
  addItems(itemList) {
    for (let item of itemList) {
      if (item.type == "career") {
        if (!this.careerGroups.includes(item.system.careergroup.value))
          this.careerGroups.push(item.system.careergroup.value);
        if (!this.careerClasses.includes(item.system.class.value))
          this.careerClasses.push(item.system.class.value);
      }
      if (item.type == "prayer") {
        let godList = item.system.god.value.split(", ").map(i => {
          return i.trim();
        });
        godList.forEach(god => {
          if (!this.gods.includes(god))
            this.gods.push(god);
        });
      }

      item.filterId = this.filterId;
      this.filterId++;
    }
    this.items = this.items.concat(itemList);
  }

  /**
   * applyFilter is called each time the filter changes to correctly hide or show
   * different items based on the filter. The most complicated part is the dynamic filters
   * which is a giant case statement for each filter type. Each dynamic filter applied
   * will filter out the items that don't meant the criteria, but does not filter 
   * out items where the filter does not apply. i.e. changing damage does not affect
   * careers if you have both weapons and careers showing.
   * 
   * @param {Object} html html of the item list
   */
  applyFilter(html) {
    let items = this.items;
    let noItemFilter = true;
    let filteredItems = [];
    for (let filter in this.filters.type) {
      if (this.filters.type[filter].value) {
        filteredItems = filteredItems.concat(items.filter(i => i.type == filter));
        noItemFilter = false;
      }
    }

    if (noItemFilter)
      filteredItems = items;

    for (let filter in this.filters.attribute) {
      if (this.filters.attribute[filter] || filter == "worldItems") {
        switch (filter) {
          case "name":
            filteredItems = filteredItems.filter(i => i.name.toLowerCase().includes(this.filters.attribute.name.toLowerCase()));
            break;
          case "description":
            filteredItems = filteredItems.filter(i => i.system.description.value && i.system.description.value.toLowerCase().includes(this.filters.attribute.description.toLowerCase()));
            break;
          case "worldItems":
            filteredItems = filteredItems.filter(i => this.filters.attribute[filter] || !!i.compendium);
            break;
        }
      }
    }

    this.checkDynamicFilters(html);

    for (let filter in this.filters.dynamic) {
      if (this.filters.dynamic[filter].show && this.filters.dynamic[filter].value) {
        switch (filter) {
          case "statusTier":
            filteredItems = filteredItems.filter(i => !i.system.status || (i.system.status && i.system.status.tier.toLowerCase() == this.filters.dynamic[filter].value[0].toLowerCase()));
            break;
          case "statusStanding":
            filteredItems = filteredItems.filter(i => !i.system.status || (i.system.status && this.filters.dynamic[filter].relation && (0, eval)(`${i.system.status.standing}${this.filters.dynamic[filter].relation}${this.filters.dynamic[filter].value}`)));
            break;
          case "qualitiesFlaws":
            if (this.filters.dynamic[filter].value.length && this.filters.dynamic[filter].value.some(x => x))
              filteredItems = filteredItems.filter(i => {
                if (!i.system.qualities.value.length && !i.system.flaws.value.length)
                  return false;
                let properties = (Object.values(i.properties.qualities).concat(Object.values(i.properties.flaws))).map(i => i.display);
                if (!properties.length || (properties.length == 1 && properties[0] == "Special"))
                  return;

                return this.filters.dynamic[filter].value.every(value => { return properties.find(v => v.toLowerCase().includes(value.toLowerCase())) })

              });
            break;
          case "symptoms": {
            if (this.filters.dynamic[filter].value.length && this.filters.dynamic[filter].value.some(x => x))
              filteredItems = filteredItems.filter(i => {
                if (!i.system.symptoms)
                  return true;
                let s = i.system[filter].value.split(",").map(i => {
                  return i.trim().toLowerCase();
                });
                return this.filters.dynamic[filter].value.every(f => s.find(symptom => symptom.includes(f.toLowerCase())))
              });
          }
            break;

          case "characteristics":
          case "skills":
          case "talents":
            if (this.filters.dynamic[filter].value.length && this.filters.dynamic[filter].value.some(x => x))
              filteredItems = filteredItems.filter(i => !i.system[filter] || (i.system[filter] && this.filters.dynamic[filter].value.every(value => { return i.system[filter].find(v => v.toLowerCase().includes(value.toLowerCase())) })));
            break;

          case "twohanded":
          case "rollable":
          case "magicMissile":
          case "wearable":
            filteredItems = filteredItems.filter(i => !i.system[filter] || (i.system[filter] && this.filters.dynamic[filter].value == (!!i.system[filter].value)));
            break;
          case "aoe":
            filteredItems = filteredItems.filter(i => i.type != "spell" || (i.system.target && this.filters.dynamic[filter].value == i.system.target.aoe));
            break;
          case "extendable":
            filteredItems = filteredItems.filter(i => i.type != "spell" || (i.system.duration && this.filters.dynamic[filter].value == i.system.duration.extendable));
            break;

          case "melee":
          case "ranged":
            filteredItems = filteredItems.filter(i => i.type != "weapon" || filter ==  game.wfrp4e.config.groupToType[i.system.weaponGroup.value]);
            break;
          case "weaponRange":
            filteredItems = filteredItems.filter(i => !i.system.range || (i.system.range.value && !isNaN(i.system.range.value) && this.filters.dynamic[filter].relation && (0, eval)(`${i.system.range.value}${this.filters.dynamic[filter].relation}${this.filters.dynamic[filter].value}`)));
            break;
          case "cn":
          case "carries":
          case "encumbrance":
            filteredItems = filteredItems.filter(i => !i.system[filter] || (i.system[filter] && this.filters.dynamic[filter].relation && (0, eval)(`${i.system[filter].value}${this.filters.dynamic[filter].relation}${this.filters.dynamic[filter].value}`)));
            break;
          case "modifiesDamage":
            filteredItems = filteredItems.filter(i => !i.system.damage || (i.system.damage && this.filters.dynamic[filter].value == (!!i.system.damage.value)));
            break;
          case "modifiesRange":
            filteredItems = filteredItems.filter(i => !i.system.range || (i.system.range && this.filters.dynamic[filter].value == (!!i.system.range.value)) && i.system.range.value.toLowerCase() != "as weapon"); // kinda gross but whatev
            break;
          case "protects":
            filteredItems = filteredItems.filter(i => {
              if (!i.system.AP)
                return true;
              let show;
              if (this.filters.dynamic.protects.value.head && i.system.AP.head)
                show = true;
              if (this.filters.dynamic.protects.value.body && i.system.AP.body)
                show = true;
              if (this.filters.dynamic.protects.value.arms && (i.system.AP.lArm || i.system.AP.rArm))
                show = true;
              if (this.filters.dynamic.protects.value.legs && (i.system.AP.lLeg || i.system.AP.rLeg))
                show = true;
              return show;
            });
            break;
          case "prayerType":
            filteredItems = filteredItems.filter(i => !i.system.type || (i.system.type && i.system.type.value == this.filters.dynamic.prayerType.value));
            break;
          case "lore" :         
            // Filter lore key, if filter is on Arcane, search instead for a blank string as a spell's lore
            filteredItems = filteredItems.filter(i => i.system.lore.value == (this.filters.dynamic[filter].value == "arcane" ? "" : this.filters.dynamic[filter].value));
            break;
          default:
            if (this.filters.dynamic[filter].exactMatch)
              filteredItems = filteredItems.filter(i => !i.system[filter] || (i.system[filter] && i.system[filter].value.toString().toLowerCase() == this.filters.dynamic[filter].value.toLowerCase()));
            else
              filteredItems = filteredItems.filter(i => !i.system[filter] || (i.system[filter] && i.system[filter].value.toString().toLowerCase().includes(this.filters.dynamic[filter].value.toLowerCase())));
            break;
        }
      }
    }

    // Each loaded item has a basic filterId number that is used to determine
    // if the item should be shown or not.
    this.filterIds = filteredItems.map(i => i.filterId);
    let list = html.find(".browser-item");
    for (let element of list) {
      if (this.filterIds.includes(Number(element.getAttribute('data-filter-id'))))
        $(element).show();
      else
        $(element).hide();
    }
    return filteredItems;
  }

  // Determines if dynamic filter options should be shown or not.
  // ie. Reach should only be shown if filtering by weapons.
  checkDynamicFilters(html) {
    for (let dynamicFilter in this.filters.dynamic) {
      this.filters.dynamic[dynamicFilter].show = false;
      for (let typeFilter of this.filters.dynamic[dynamicFilter].type) {
        if (this.filters.type[typeFilter].value)
          this.filters.dynamic[dynamicFilter].show = true;
      }

      let filter = html.find(`.${dynamicFilter}`);
      if (this.filters.dynamic[dynamicFilter].show) {
        $(filter).show();
      }
      else {
        $(filter).hide();
      }
    }
  }

  async importResults() {
    let filteredItems = this.applyFilter(this._element).filter(i => i.compendium);
    new Dialog({
      title: game.i18n.localize("Import Results"),
      content: `<p>${game.i18n.format("ITEM.Import", { number: filteredItems.length })}`,
      buttons: {
        yes:
        {
          label: game.i18n.localize("Yes"),
          callback: async html => {
            let folder = await Folder.create({type : "Item", name : "Browser Import"});
            let toCreate = filteredItems.map(i => mergeObject(i.toObject(), {folder : folder.id}));
            Item.create(toCreate, { renderSheet: false }).then(items => {
              ui.notifications.notify(game.i18n.format("BROWSER.Created", {num : items.length}));
            });
          }
        },
        cancel:
        {
          label: game.i18n.localize("Cancel"),
          callback: html => { return }
        }
      }
    }).render(true);
  }


  // All the filter responses as well as dragging and dropping items.
  activateListeners(html) {

    html.find(".browser-item").each((i, li) => {
      let item = this.items.find(i => i.id == $(li).attr("data-id"));

      li.setAttribute("draggable", true);
      li.addEventListener("dragstart", event => {
        let transfer = {
          type: "Item",
          uuid: item.uuid
        };
        event.dataTransfer.setData("text/plain", JSON.stringify(transfer));
    });
  });

    html.on("click", ".item-name", ev => {
      let itemId = $(ev.currentTarget).parents(".browser-item").attr("data-id");
      this.items.find(i => i.id == itemId).sheet.render(true);

    });

    html.on("click", ".filter", ev => {
      this.filters.type[$(ev.currentTarget).attr("data-filter")].value = $(ev.currentTarget).is(":checked");
      this.applyFilter(html);
    });

    html.on("keyup", ".name-filter", ev => {
      this.filters.attribute.name = $(ev.currentTarget).val();
      this.applyFilter(html);
    });
    html.on("keyup", ".description-filter", ev => {
      this.filters.attribute.description = $(ev.currentTarget).val();
      this.applyFilter(html);
    });
    html.on("click", ".world-filter", ev => {
      this.filters.attribute.worldItems = $(ev.currentTarget).is(":checked");
      this.applyFilter(html);
    });
    html.on("keyup change", ".dynamic-filter", ev => {
      this.filters.dynamic[$(ev.currentTarget).attr("data-filter")].value = $(ev.currentTarget).val();
      this.applyFilter(html);
    });
    html.on("change", ".dynamic-filter-comparator", ev => {
      this.filters.dynamic[$(ev.currentTarget).attr("data-filter")].relation = $(ev.currentTarget).val();
      this.applyFilter(html);
    });
    html.on("change", ".csv-filter", ev => {
      this.filters.dynamic[$(ev.currentTarget).attr("data-filter")].value = $(ev.currentTarget).val().split(",").map(i => {
        return i.trim();
      });
      this.applyFilter(html);
    });
    html.on("change", ".boolean-filter", ev => {
      if ($(ev.currentTarget).hasClass("exactMatch"))
        this.filters.dynamic[$(ev.currentTarget).attr("data-filter")].exactMatch = $(ev.currentTarget).is(":checked");

      else if ($(ev.currentTarget).attr("data-filter"))
        this.filters.dynamic[$(ev.currentTarget).attr("data-filter")].value = $(ev.currentTarget).is(":checked");

      this.applyFilter(html);
    });
    html.on("click", ".protects-filter", ev => {
      this.filters.dynamic.protects.value[$(ev.currentTarget).attr("data-filter")] = $(ev.currentTarget).is(":checked");
      this.applyFilter(html);
    });
  }


  _saveScrollPos() {
    if (this.form === null)
      return;

    const html = this._element;
    if (!html) return
    this.scrollPos = [];
    let lists = $(html.find(".save-scroll"));
    for (let list of lists) {
      this.scrollPos.push($(list).scrollTop());
    }
  }
  _setScrollPos() {
    if (this.scrollPos) {
      const html = this._element;
      let lists = $(html.find(".save-scroll"));
      for (let i = 0; i < lists.length; i++) {
        $(lists[i]).scrollTop(this.scrollPos[i]);
      }
    }
  }

}

Hooks.on("renderCompendiumDirectory", (app, html, data) => {
  if (game.user.isGM || game.settings.get("wfrp4e", "playerBrowser")) {
    const button = $(`<button class="browser-btn" data-tooltip="${game.i18n.localize("BROWSER.Button")}"><i class="fa-solid fa-filter"></i></button>`);
    html.find(".header-actions").append(button);

    button.click(ev => {
      new BrowserWfrp4e().render(true);
    });
  }
});

const WFRP4E = {};
CONFIG.ChatMessage.template = "systems/wfrp4e/templates/chat/chat-message.hbs";

WFRP4E.creditOptions = {
    SPLIT: "split",
    EACH: "each",
};

WFRP4E.toTranslate = [
"statusTiers",
"characteristics",
"characteristicsAbbrev",
"characteristicsBonus",
"skillTypes",
"skillGroup",
"talentMax",
"weaponGroups",
"weaponTypes",
"weaponReaches",
"ammunitionGroups",
"itemQualities",
"itemFlaws",
"weaponQualities",
"weaponFlaws",
"armorQualities",
"armorFlaws",
"armorTypes",
"rangeModifiers",
"rangeBands",
"difficultyLabels",
"locations",
"availability",
"trappingTypes",
"trappingCategories",
"actorSizes",
"magicLores",
"magicWind",
"prayerTypes",
"mutationTypes",
"conditions",
"availabilityTable",
"moneyNames",
"hitLocationTables",
"extendedTestCompletion",
"applyScope",
"weaponGroupDescriptions",
"qualityDescriptions",
"flawDescriptions",
"loreEffectDescriptions",
"conditionDescriptions",
"symptoms",
"symptomDescriptions",
"symptomTreatment",
"reachDescription",
"classTrappings",
"effectApplications"
];

// "Trappings" are more than "trapping" type items
WFRP4E.trappingItems = ["trapping", "armour", "weapon", "container", "ammunition", "money"];

CONFIG.controlIcons.defeated = "systems/wfrp4e/icons/defeated.png";

CONFIG.JournalEntry.noteIcons = {
    "Marker": "systems/wfrp4e/icons/buildings/point_of_interest.png",
    "Apothecary": "systems/wfrp4e/icons/buildings/apothecary.png",
    "Beastmen Herd 1": "systems/wfrp4e/icons/buildings/beastmen_camp1.png",
    "Beastmen Herd 2": "systems/wfrp4e/icons/buildings/beastmen_camp2.png",
    "Blacksmith": "systems/wfrp4e/icons/buildings/blacksmith.png",
    "Bretonnian City 1": "systems/wfrp4e/icons/buildings/bret_city1.png",
    "Bretonnian City 2": "systems/wfrp4e/icons/buildings/bret_city2.png",
    "Bretonnian City 3": "systems/wfrp4e/icons/buildings/bret_city3.png",
    "Bretonnian Worship": "systems/wfrp4e/icons/buildings/bretonnia_worship.png",
    "Caste Hill 1": "systems/wfrp4e/icons/buildings/castle_hill1.png",
    "Caste Hill 2": "systems/wfrp4e/icons/buildings/castle_hill2.png",
    "Caste Hill 3": "systems/wfrp4e/icons/buildings/castle_hill3.png",
    "Castle Wall": "systems/wfrp4e/icons/buildings/castle_wall.png",
    "Cave 1": "systems/wfrp4e/icons/buildings/cave1.png",
    "Cave 2": "systems/wfrp4e/icons/buildings/cave2.png",
    "Cave 3": "systems/wfrp4e/icons/buildings/cave3.png",
    "Cemetery": "systems/wfrp4e/icons/buildings/cemetery.png",
    "Chaos Portal": "systems/wfrp4e/icons/buildings/chaos_portal.png",
    "Chaos Worship": "systems/wfrp4e/icons/buildings/chaos_worship.png",
    "Court": "systems/wfrp4e/icons/buildings/court.png",
    "Dwarf Beer": "systems/wfrp4e/icons/buildings/dwarf_beer.png",
    "Dwarf Hold 1": "systems/wfrp4e/icons/buildings/dwarf_hold1.png",
    "Dwarf Hold 2": "systems/wfrp4e/icons/buildings/dwarf_hold2.png",
    "Dwarf Hold 3": "systems/wfrp4e/icons/buildings/dwarf_hold3.png",
    "Empire Barracks": "systems/wfrp4e/icons/buildings/empire_barracks.png",
    "Empire City 1": "systems/wfrp4e/icons/buildings/empire_city1.png",
    "Empire City 2": "systems/wfrp4e/icons/buildings/empire_city2.png",
    "Empire City 3": "systems/wfrp4e/icons/buildings/empire_city3.png",
    "Farm": "systems/wfrp4e/icons/buildings/farms.png",
    "Food 1": "systems/wfrp4e/icons/buildings/food.png",
    "Food 2": "systems/wfrp4e/icons/buildings/food2.png",
    "Guard Post": "systems/wfrp4e/icons/buildings/guards.png",
    "Haunted Hill": "systems/wfrp4e/icons/buildings/haunted_hill.png",
    "Haunted Wood": "systems/wfrp4e/icons/buildings/haunted_wood.png",
    "Inn 1": "systems/wfrp4e/icons/buildings/inn1.png",
    "Inn 2": "systems/wfrp4e/icons/buildings/inn2.png",
    "Kislev City 1": "systems/wfrp4e/icons/buildings/kislev_city1.png",
    "Kislev City 2": "systems/wfrp4e/icons/buildings/kislev_city2.png",
    "Kislev City 3": "systems/wfrp4e/icons/buildings/kislev_city3.png",
    "Lumber": "systems/wfrp4e/icons/buildings/lumber.png",
    "Magic": "systems/wfrp4e/icons/buildings/magic.png",
    "Metal": "systems/wfrp4e/icons/buildings/metal.png",
    "Mountain 1": "systems/wfrp4e/icons/buildings/mountains1.png",
    "Mountain 2": "systems/wfrp4e/icons/buildings/mountains2.png",
    "Orcs": "systems/wfrp4e/icons/buildings/orcs.png",
    "Orc Camp": "systems/wfrp4e/icons/buildings/orc_city.png",
    "Port": "systems/wfrp4e/icons/buildings/port.png",
    "Road": "systems/wfrp4e/icons/buildings/roads.png",
    "Ruins": "systems/wfrp4e/icons/buildings/ruins.png",
    "Scroll": "systems/wfrp4e/icons/buildings/scroll.png",
    "Sigmar": "systems/wfrp4e/icons/buildings/sigmar_worship.png",
    "Stables": "systems/wfrp4e/icons/buildings/stables.png",
    "Standing Stones": "systems/wfrp4e/icons/buildings/standing_stones.png",
    "Swamp": "systems/wfrp4e/icons/buildings/swamp.png",
    "Temple": "systems/wfrp4e/icons/buildings/temple.png",
    "Textile": "systems/wfrp4e/icons/buildings/textile.png",
    "Tower 1": "systems/wfrp4e/icons/buildings/tower1.png",
    "Tower 2": "systems/wfrp4e/icons/buildings/tower2.png",
    "Tower Hill": "systems/wfrp4e/icons/buildings/tower_hill.png",
    "Wizard Tower": "systems/wfrp4e/icons/buildings/wizard_tower.png",
    "Ulric": "systems/wfrp4e/icons/buildings/ulric_worship.png",
    "Village 1": "systems/wfrp4e/icons/buildings/village1.png",
    "Village 2": "systems/wfrp4e/icons/buildings/village2.png",
    "Village 3": "systems/wfrp4e/icons/buildings/village3.png",
    "Wood Elves 1": "systems/wfrp4e/icons/buildings/welves1.png",
    "Wood Elves 2": "systems/wfrp4e/icons/buildings/welves2.png",
    "Wood Elves 3": "systems/wfrp4e/icons/buildings/welves3.png"
};


CONFIG.TextEditor.enrichers = CONFIG.TextEditor.enrichers.concat([
    {
        pattern : /@Table\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("table-click");
            a.dataset.table = match[1];
            a.innerHTML = `<i class="fas fa-list"></i>${(game.wfrp4e.tables.findTable(match[1])?.name && !match[2]) ? game.wfrp4e.tables.findTable(match[1])?.name : match[2]}`;
            return a
        }
    },
    {
        pattern : /@Symptom\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("symptom-tag");
            a.dataset.symptom = match[1];
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-user-injured"></i>${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Condition\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("condition-chat");
            a.dataset.cond = match[1];
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-user-injured"></i>${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Pay\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("pay-link");
            a.dataset.pay = match[1];
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-coins"></i>${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Credit\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("credit-link");
            a.dataset.credit = match[1];
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<i class="fas fa-coins"></i>${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Corruption\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            const a = document.createElement("a");
            a.classList.add("corruption-link");
            a.dataset.strength = match[1];
            let id = match[1];
            let label = match[2];
            a.innerHTML = `<img src="systems/wfrp4e/ui/chaos.svg" height=15px width=15px style="border:none">${label ? label : id}`;
            return a
        }
    },
    {
        pattern : /@Fear\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            let values = match[1].split(",");
            const a = document.createElement("a");
            a.classList.add("fear-link");
            a.dataset.value = values[0];
            a.dataset.name = values[1] || "";
            a.innerHTML = `<img src="systems/wfrp4e/ui/fear.svg" height=15px width=15px style="border:none"> ${game.i18n.localize("WFRP4E.ConditionName.Fear")} ${values[0]}`;
            return a
        }
    },
    {
        pattern : /@Terror\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            let values = match[1].split(",");
            const a = document.createElement("a");
            a.classList.add("terror-link");
            a.dataset.value = values[0];
            a.dataset.name = values[1] || "";
            a.innerHTML = `<img src="systems/wfrp4e/ui/terror.svg" height=15px width=15px style="border:none"> ${game.i18n.localize("NAME.Terror")} ${values[0]}`;
            return a
        }
    },
    {
        pattern : /@Exp\[(.+?)\](?:{(.+?)})?/gm,
        enricher : (match, options) => {
            let values = match[1].split(",");
            const a = document.createElement("a");
            a.classList.add("exp-link");
            a.dataset.amount = values[0];
            a.dataset.reason= values[1] || "";
            let label = match[2];
            a.innerHTML = `<i class="fas fa-plus"></i> ${ label ? label : (values[1] || values[0])}</a>`;
            return a
        }
    },
]);

// Status Tiers
WFRP4E.statusTiers = {
    "g": "TIER.Gold",
    "s": "TIER.Silver",
    "b": "TIER.Brass"
};

// Characteristic Names
WFRP4E.characteristics = {
    "ws": "CHAR.WS",
    "bs": "CHAR.BS",
    "s": "CHAR.S",
    "t": "CHAR.T",
    "i": "CHAR.I",
    "ag": "CHAR.Ag",
    "dex": "CHAR.Dex",
    "int": "CHAR.Int",
    "wp": "CHAR.WP",
    "fel": "CHAR.Fel"
};

// Characteristic Abbreviations
WFRP4E.characteristicsAbbrev = {
    "ws": "CHARAbbrev.WS",
    "bs": "CHARAbbrev.BS",
    "s": "CHARAbbrev.S",
    "t": "CHARAbbrev.T",
    "i": "CHARAbbrev.I",
    "ag": "CHARAbbrev.Ag",
    "dex": "CHARAbbrev.Dex",
    "int": "CHARAbbrev.Int",
    "wp": "CHARAbbrev.WP",
    "fel": "CHARAbbrev.Fel"
};

// Characteristic Abbreviations
WFRP4E.characteristicsBonus = {
    "ws": "CHARBonus.WS",
    "bs": "CHARBonus.BS",
    "s": "CHARBonus.S",
    "t": "CHARBonus.T",
    "i": "CHARBonus.I",
    "ag": "CHARBonus.Ag",
    "dex": "CHARBonus.Dex",
    "int": "CHARBonus.Int",
    "wp": "CHARBonus.WP",
    "fel": "CHARBonus.Fel"
};

WFRP4E.skillTypes = {
    "bsc": "Basic",
    "adv": "Advanced"
};

WFRP4E.xpCost = {
    "characteristic": [25, 30, 40, 50, 70, 90, 120, 150, 190, 230, 280, 330, 390, 450, 520],
    "skill": [10, 15, 20, 30, 40, 60, 80, 110, 140, 180, 220, 270, 320, 380, 440]
};

WFRP4E.skillGroup = {
    "isSpec": "ITEM.IsSpec",
    "noSpec": "ITEM.NoSpec"
};

WFRP4E.talentMax = {
    "1": "1",
    "2": "2",
    "3": "3",
    "4": "4",
    "none": "None",
    "ws": "CHARBonus.WS",
    "bs": "CHARBonus.BS",
    "s": "CHARBonus.S",
    "t": "CHARBonus.T",
    "i": "CHARBonus.I",
    "ag": "CHARBonus.Ag",
    "dex": "CHARBonus.Dex",
    "int": "CHARBonus.Int",
    "wp": "CHARBonus.WP",
    "fel": "CHARBonus.Fel"
};


// Weapon Groups
WFRP4E.weaponGroups = {
    "basic": "SPEC.Basic",
    "cavalry": "SPEC.Cavalry",
    "fencing": "SPEC.Fencing",
    "brawling": "SPEC.Brawling",
    "flail": "SPEC.Flail",
    "parry": "SPEC.Parry",
    "polearm": "SPEC.Polearm",
    "twohanded": "SPEC.TwoHanded",
    "blackpowder": "SPEC.Blackpowder",
    "bow": "SPEC.Bow",
    "crossbow": "SPEC.Crossbow",
    "entangling": "SPEC.Entangling",
    "engineering": "SPEC.Engineering",
    "explosives": "SPEC.Explosives",
    "sling": "SPEC.Sling",
    "throwing": "SPEC.Throwing",
    "vehicle": "SPEC.Vehicle",
};

// Given a group, what's the primary type, melee or ranged
WFRP4E.groupToType = {
    "basic": "melee",
    "cavalry": "melee",
    "fencing": "melee",
    "brawling": "melee",
    "flail": "melee",
    "parry": "melee",
    "polearm": "melee",
    "twohanded": "melee",
    "blackpowder": "ranged",
    "bow": "ranged",
    "crossbow": "ranged",
    "entangling": "ranged",
    "engineering": "ranged",
    "explosives": "ranged",
    "sling": "ranged",
    "throwing": "ranged",
    "vehicle" : "ranged"
};

WFRP4E.weaponTypes = {
    "melee": "Melee",
    "ranged": "Ranged"
};

// Weapon Reach
WFRP4E.weaponReaches = {
    "personal": "WFRP4E.Reach.Personal",
    "vshort": "WFRP4E.Reach.VShort",
    "short": "WFRP4E.Reach.Short",
    "average": "WFRP4E.Reach.Average",
    "long": "WFRP4E.Reach.Long",
    "vLong": "WFRP4E.Reach.VLong",
    "massive": "WFRP4E.Reach.Massive",
};

// Ammo Groups
WFRP4E.ammunitionGroups = {
    "BPandEng": "WFRP4E.BPandEng",
    "bow": "WFRP4E.Bow",
    "crossbow": "WFRP4E.Crossbow",
    "sling": "WFRP4E.Sling",
    "vehicle": "WFRP4E.Vehicle",
    "throwing": "SPEC.Throwing",
    "entangling": "SPEC.Entangling",
};

// Item Qualities
WFRP4E.itemQualities = {
    "durable": "PROPERTY.Durable",
    "fine": "PROPERTY.Fine",
    "lightweight": "PROPERTY.Lightweight",
    "practical": "PROPERTY.Practical",
};

// Item Flaws
WFRP4E.itemFlaws = {
    "ugly": "PROPERTY.Ugly",
    "shoddy": "PROPERTY.Shoddy",
    "unreliable": "PROPERTY.Unreliable",
    "bulky": "PROPERTY.Bulky",
};


// Weapon Qualities
WFRP4E.weaponQualities = {
    "accurate": "PROPERTY.Accurate",
    "blackpowder": "PROPERTY.Blackpowder",
    "blast": "PROPERTY.Blast",
    "damaging": "PROPERTY.Damaging",
    "defensive": "PROPERTY.Defensive",
    "distract": "PROPERTY.Distract",
    "entangle": "PROPERTY.Entangle",
    "fast": "PROPERTY.Fast",
    "hack": "PROPERTY.Hack",
    "impact": "PROPERTY.Impact",
    "impale": "PROPERTY.Impale",
    "penetrating": "PROPERTY.Penetrating",
    "pistol": "PROPERTY.Pistol",
    "precise": "PROPERTY.Precise",
    "pummel": "PROPERTY.Pummel",
    "repeater": "PROPERTY.Repeater",
    "shield": "PROPERTY.Shield",
    "trapblade": "PROPERTY.TrapBlade",
    "unbreakable": "PROPERTY.Unbreakable",
    "slash": "PROPERTY.Slash",
    "wrap": "PROPERTY.Wrap"
};

// Weapon Flaws
WFRP4E.weaponFlaws = {
    "dangerous": "PROPERTY.Dangerous",
    "imprecise": "PROPERTY.Imprecise",
    "reload": "PROPERTY.Reload",
    "slow": "PROPERTY.Slow",
    "tiring": "PROPERTY.Tiring",
    "undamaging": "PROPERTY.Undamaging"
};

// Armor Qualities
WFRP4E.armorQualities = {
    "flexible": "PROPERTY.Flexible",
    "impenetrable": "PROPERTY.Impenetrable",
};

// Armor Flaws
WFRP4E.armorFlaws = {
    "partial": "PROPERTY.Partial",
    "weakpoints": "PROPERTY.Weakpoints",
};

WFRP4E.propertyHasValue = {
    "durable": true,
    "fine": true,
    "lightweight": false,
    "practical": false,
    "ugly": false,
    "shoddy": false,
    "unreliable": false,
    "bulky": false,
    "accurate": false,
    "blackpowder": false,
    "blast": true,
    "damaging": false,
    "defensive": false,
    "distract": false,
    "entangle": false,
    "fast": false,
    "hack": false,
    "impact": false,
    "impale": false,
    "penetrating": false,
    "pistol": false,
    "precise": false,
    "pummel": false,
    "slash": true,
    "repeater": true,
    "shield": true,
    "trapblade": false,
    "unbreakable": false,
    "wrap": false,
    "dangerous": false,
    "imprecise": false,
    "reload": true,
    "slow": false,
    "tiring": false,
    "undamaging": false,
    "flexible": false,
    "impenetrable": false,
    "partial": false,
    "weakpoints": false
};

// Equipment Types
WFRP4E.armorTypes = {
    "softLeather": "WFRP4E.ArmourType.SLeather",
    "boiledLeather": "WFRP4E.ArmourType.BLeather",
    "mail": "WFRP4E.ArmourType.Mail",
    "plate": "WFRP4E.ArmourType.Plate",
    "other": "WFRP4E.ArmourType.Other"
};

// Range Test Modifiers
WFRP4E.rangeModifiers = {
    "Point Blank": "easy",
    "Short Range": "average",
    "Normal": "challenging",
    "Long Range": "difficult",
    "Extreme": "vhard",
};

// Ranges
WFRP4E.rangeBands = {
    "pb": "Point Blank",
    "short": "Short Range",
    "normal": "Normal",
    "long": "Long Range",
    "extreme": "Extreme",
};

// Difficulty Modifiers
WFRP4E.difficultyModifiers = {
    "veasy": 60,
    "easy": 40,
    "average": 20,
    "challenging": 0,
    "difficult": -10,
    "hard": -20,
    "vhard": -30
};

// Difficulty Labels
WFRP4E.difficultyLabels = {

    "veasy": "DIFFICULTY.VEasy",
    "easy": "DIFFICULTY.Easy",
    "average": "DIFFICULTY.Average",
    "challenging": "DIFFICULTY.Challenging",
    "difficult": "DIFFICULTY.Difficult",
    "hard": "DIFFICULTY.Hard",
    "vhard": "DIFFICULTY.VHard"
};

WFRP4E.locations = {
    "head": "WFRP4E.Locations.head",
    "body": "WFRP4E.Locations.body",
    "rArm": "WFRP4E.Locations.rArm",
    "lArm": "WFRP4E.Locations.lArm",
    "rLeg": "WFRP4E.Locations.rLeg",
    "lLeg": "WFRP4E.Locations.lLeg",
};

// Trapping Availability
WFRP4E.availability = {
    "None": "-",
    "common": "WFRP4E.Availability.Common",
    "scarce": "WFRP4E.Availability.Scarce",
    "rare": "WFRP4E.Availability.Rare",
    "exotic": "WFRP4E.Availability.Exotic",
    "special": "WFRP4E.Availability.Special",
};


// Trapping Types
WFRP4E.trappingTypes = {
    "clothingAccessories": "WFRP4E.TrappingType.ClothingAccessories",
    "foodAndDrink": "WFRP4E.TrappingType.FoodDrink",
    "toolsAndKits": "WFRP4E.TrappingType.ToolsKits",
    "booksAndDocuments": "WFRP4E.TrappingType.BooksDocuments",
    "tradeTools": "WFRP4E.TrappingType.TradeTools", // Unused - combined with tools and kits
    "drugsPoisonsHerbsDraughts": "WFRP4E.TrappingType.DrugsPoisonsHerbsDraughts",
    "ingredient": "WFRP4E.TrappingType.Ingredient",
    "misc": "WFRP4E.TrappingType.Misc",
};

// These categories are used to label items in containers (Trapping tab)
WFRP4E.trappingCategories = {
    "weapon": "WFRP4E.TrappingType.Weapon",
    "armour": "WFRP4E.TrappingType.Armour",
    "money": "WFRP4E.TrappingType.Money",
    "ammunition": "WFRP4E.TrappingType.Ammunition",
    "container": "WFRP4E.TrappingType.Container",
    "clothingAccessories": "WFRP4E.TrappingType.ClothingAccessories",
    "foodAndDrink": "WFRP4E.TrappingType.FoodDrink",
    "toolsAndKits": "WFRP4E.TrappingType.ToolsKits",
    "booksAndDocuments": "WFRP4E.TrappingType.BooksDocuments",
    "tradeTools": "WFRP4E.TrappingType.TradeTools",
    "drugsPoisonsHerbsDraughts": "WFRP4E.TrappingType.DrugsPoisonsHerbsDraughts",
    "ingredient": "WFRP4E.TrappingType.Ingredient",
    "misc": "WFRP4E.TrappingType.Misc",
};

// Creature Sizes
WFRP4E.actorSizes = {
    "tiny": "SPEC.Tiny",
    "ltl": "SPEC.Little",
    "sml": "SPEC.Small",
    "avg": "SPEC.Average",
    "lrg": "SPEC.Large",
    "enor": "SPEC.Enormous",
    "mnst": "SPEC.Monstrous"
};
WFRP4E.actorSizeNums = {
    "tiny": 0,
    "ltl": 1,
    "sml": 2,
    "avg": 3,
    "lrg": 4,
    "enor": 5,
    "mnst": 6
};

WFRP4E.tokenSizes = {
    "tiny": 0.3,
    "ltl": 0.5,
    "sml": 0.8,
    "avg": 1,
    "lrg": 2,
    "enor": 3,
    "mnst": 4
};

// Condition Types
WFRP4E.magicLores = {
    "petty": "WFRP4E.MagicLores.petty",
    "beasts": "WFRP4E.MagicLores.beasts",
    "death": "WFRP4E.MagicLores.death",
    "fire": "WFRP4E.MagicLores.fire",
    "heavens": "WFRP4E.MagicLores.heavens",
    "metal": "WFRP4E.MagicLores.metal",
    "life": "WFRP4E.MagicLores.life",
    "light": "WFRP4E.MagicLores.light",
    "shadow": "WFRP4E.MagicLores.shadow",
    "hedgecraft": "WFRP4E.MagicLores.hedgecraft",
    "witchcraft": "WFRP4E.MagicLores.witchcraft",
    "daemonology": "WFRP4E.MagicLores.daemonology",
    "necromancy": "WFRP4E.MagicLores.necromancy",
    "undivided" : "WFRP4E.MagicLores.undivided",
    "nurgle": "WFRP4E.MagicLores.nurgle",
    "slaanesh": "WFRP4E.MagicLores.slaanesh",
    "tzeentch": "WFRP4E.MagicLores.tzeentch",
};

// Given a Lore, what is the Wind
WFRP4E.magicWind = {
    "petty": "WFRP4E.MagicWind.petty",
    "beasts": "WFRP4E.MagicWind.beasts",
    "death": "WFRP4E.MagicWind.death",
    "fire": "WFRP4E.MagicWind.fire",
    "heavens": "WFRP4E.MagicWind.heavens",
    "metal": "WFRP4E.MagicWind.metal",
    "life": "WFRP4E.MagicWind.life",
    "light": "WFRP4E.MagicWind.light",
    "shadow": "WFRP4E.MagicWind.shadow",
    "hedgecraft": "WFRP4E.MagicWind.hedgecraft",
    "witchcraft": "WFRP4E.MagicWind.witchcraft",
    "daemonology": "WFRP4E.MagicWind.daemonology",
    "necromancy": "WFRP4E.MagicWind.necromancy",
    "undivided": "WFRP4E.MagicWind.undivided",
    "nurgle": "WFRP4E.MagicWind.nurgle",
    "slaanesh": "WFRP4E.MagicWind.slaanesh",
    "tzeentch": "WFRP4E.MagicWind.tzeentch",
};



// Types of prayers
WFRP4E.prayerTypes = {
    "blessing": "WFRP4E.prayerTypes.blessing",
    "miracle": "WFRP4E.prayerTypes.miracle"
};

WFRP4E.mutationTypes = {
    "physical": "WFRP4E.mutationTypes.physical",
    "mental": "WFRP4E.mutationTypes.mental"
};


WFRP4E.conditions = {
    "ablaze": "WFRP4E.ConditionName.Ablaze",
    "bleeding": "WFRP4E.ConditionName.Bleeding",
    "blinded": "WFRP4E.ConditionName.Blinded",
    "broken": "WFRP4E.ConditionName.Broken",
    "deafened": "WFRP4E.ConditionName.Deafened",
    "entangled": "WFRP4E.ConditionName.Entangled",
    "fatigued": "WFRP4E.ConditionName.Fatigued",
    "poisoned": "WFRP4E.ConditionName.Poisoned",
    "prone": "WFRP4E.ConditionName.Prone",
    "stunned": "WFRP4E.ConditionName.Stunned",
    "surprised": "WFRP4E.ConditionName.Surprised",
    "unconscious": "WFRP4E.ConditionName.Unconscious",
    "grappling": "WFRP4E.ConditionName.Grappling",
    "fear": "WFRP4E.ConditionName.Fear",
    "engaged": "WFRP4E.ConditionName.Engaged",
    "defeated": "WFRP4E.ConditionName.Defeated"
};


WFRP4E.earningValues = {
    "b": "2d10",
    "s": "1d10",
    "g": "1",
};

WFRP4E.randomExp = {
    speciesRand: 20,
    careerRand: 50,
    careerReroll: 25,
    statsRand: 50,
    statsReorder: 25
};

WFRP4E.reachNum = {
    "personal": 1,
    "vshort": 2,
    "short": 3,
    "average": 4,
    "long": 5,
    "vLong": 6,
    "massive": 7,
};

WFRP4E.traitBonuses = {
    "big": {
        "s": 10,
        "t": 10,
        "ag": -5
    },
    "brute": {
        "m": -1,
        "t": 10,
        "s": 10,
        "ag": -10
    },
    "clever": {
        "int": 20,
        "i": 10
    },
    "cunning": {
        "int": 10,
        "fel": 10,
        "i": 10
    },
    "elite": {
        "ws": 20,
        "bs": 20,
        "wp": 20
    },
    "fast": {
        "ag": 10,
        "m": 1
    },
    "leader": {
        "fel": 10,
        "wp": 10
    },
    "tough": {
        "t": 10,
        "wp": 10
    },
    "swarm": {
        "ws": 10
    }
};

WFRP4E.talentBonuses = {
    "savvy": "int",
    "suave": "fel",
    "marksman": "bs",
    "very strong": "s",
    "sharp": "i",
    "lightning reflexes": "ag",
    "coolheaded": "wp",
    "very resilient": "t",
    "nimble fingered": "dex",
    "warrior born": "ws"
};

WFRP4E.corruptionTables = ["mutatephys", "mutatemental"];

WFRP4E.DAMAGE_TYPE = {
    NORMAL: 0,
    IGNORE_AP: 1,
    IGNORE_TB: 2,
    IGNORE_ALL: 3
};

WFRP4E.PSEUDO_ENTITIES = [
    "Table",
    "Condition",
    "Symptom",
    "Roll",
    "Pay",
    "Credit",
    "Corruption",
    "Fear",
    "Terror",
    "Exp"
];

WFRP4E.availabilityTable = {
    "MARKET.Village": {
        "WFRP4E.Availability.Common": {
            test: 100,
            stock: '2'
        },
        "WFRP4E.Availability.Scarce": {
            test: 30,
            stock: '1'
        },
        "WFRP4E.Availability.Rare": {
            test: 15,
            stock: '1'
        },
        "WFRP4E.Availability.Exotic": {
            test: 0,
            stock: '0'
        }
    },
    "MARKET.Town": {
        "WFRP4E.Availability.Common": {
            test: 100,
            stock: '2d10'
        },
        "WFRP4E.Availability.Scarce": {
            test: 60,
            stock: '1d10'
        },
        "WFRP4E.Availability.Rare": {
            test: 30,
            stock: '1d5'
        },
        "WFRP4E.Availability.Exotic": {
            test: 0,
            stock: '0'
        }
    },
    "MARKET.City": {
        "WFRP4E.Availability.Common": {
            test: 100,
            stock: ''
        },
        "WFRP4E.Availability.Scarce": {
            test: 90,
            stock: ''
        },
        "WFRP4E.Availability.Rare": {
            test: 45,
            stock: ''
        },
        "WFRP4E.Availability.Exotic": {
            test: 0,
            stock: '0'
        }
    }
};

WFRP4E.overCastTable = {
  range: [
    {cost: 1, value: 2},
    {cost: 4, value: 3},
    {cost: 16, value: 4}],
  target: [
    {cost: 1, value: 1},
    {cost: 4, value: 2},
    {cost: 16, value: 3}],
  AoE: [
    {cost: 3, value: 2},
    {cost: 18, value: 3}],
  duration: [
    {cost: 2, value: 2},
    {cost: 6, value: 3}],
  damage: [
    {cost: 1, value: 1},
    {cost: 1, value: 2},
    {cost: 1, value: 3},
    {cost: 2, value: 4},
    {cost: 3, value: 5},
    {cost: 5, value: 6},
    {cost: 8, value: 7}]
};

WFRP4E.dharOverCastTable = {
    range: [
      {cost: 1, value: 2},
      {cost: 2, value: 3},
      {cost: 8, value: 4}],
    target: [
      {cost: 1, value: 1},
      {cost: 2, value: 2},
      {cost: 8, value: 3}],
    AoE: [
      {cost: 2, value: 2},
      {cost: 9, value: 3}],
    duration: [
      {cost: 1, value: 2},
      {cost: 3, value: 3}],
    damage: [
      {cost: 1, value: 1},
      {cost: 1, value: 2},
      {cost: 1, value: 3},
      {cost: 1, value: 4},
      {cost: 1, value: 5},
      {cost: 2, value: 6},
      {cost: 4, value: 7}]
  };

WFRP4E.species = {};
WFRP4E.subspecies = {};
WFRP4E.speciesCharacteristics = {};
WFRP4E.speciesSkills = {};
WFRP4E.speciesTalents = {};
WFRP4E.speciesMovement = {};
WFRP4E.speciesFate = {};
WFRP4E.speciesRes = {};
WFRP4E.speciesExtra = {};
WFRP4E.speciesAge = {};
WFRP4E.speciesHeight = {};
WFRP4E.speciesCareerReplacements = {};
WFRP4E.classTrappings = {};
WFRP4E.weaponGroupDescriptions = {};
WFRP4E.reachDescription = {};
WFRP4E.qualityDescriptions = {};
WFRP4E.flawDescriptions = {};
WFRP4E.loreEffectDescriptions = {};
WFRP4E.loreEffects = {};
WFRP4E.conditionDescriptions = {};
WFRP4E.symptoms = {};
WFRP4E.symptomDescriptions = {};
WFRP4E.symptomTreatment = {};
WFRP4E.modTypes = {};
WFRP4E.symptomEffects = {};

WFRP4E.premiumModules = {
    "wfrp4e" : "WFRP4e System",
    "wfrp4e-core" : "Core Rulebook",
    "wfrp4e-starter-set" : "Starter Set",
    "wfrp4e-rnhd" : "Rough Nights & Hard Days",
    "wfrp4e-eis" : "Enemy In Shadows",
    "wfrp4e-ua1" : "Ubersreik Adventures I",
    "wfrp4e-dotr" : "Death on the Reik",
    "wfrp4e-middenheim" : "Middenheim: City of the White Wolf",
    "wfrp4e-archives1" : "Archives of the Empire: Vol 1.",
    "wfrp4e-pbtt" : "Power Behind the Throne",
    "wfrp4e-altdorf" : "Altdorf: Crown of the Empire",
    "wfrp4e-ua2" : "Ubersreik Adventures II",
    "wfrp4e-owb1" : "Old World Bundle I",
    "wfrp4e-horned-rat" : "The Horned Rat",
    "wfrp4e-empire-ruins" : "Empire in Ruins",
    "wfrp4e-archives2" : "Archives of the Empire: Vol 2.",
    "wfrp4e-up-in-arms" : "Up In Arms",
    "wfrp4e-wom" : "Winds of Magic",
    "wfrp4e-zoo" : "Imperial Zoo",
    "wfrp4e-salzenmund" : "Salzenmund: City of Salt and Silver"
};

WFRP4E.trade = { 
    gazetteer : [],
    settlementRating : {
        "hamlet": { popmax: 200,
          size_rating: 1 },
      
        "village": {
          popmax: 1500,
          size_rating: 2
        },
      
        "town": { popmax: 10000,
          size_rating: 3 },
      
        "city": { popmax: 100000000,
          size_rating: 4 }
      },
      wealthAvailability : [
        { wealth: 0,
          offered: -1.0 },
        
          { wealth: 1,
          offered: -0.5 },
        
        { wealth: 2,
          offered: -0.2 },
        
        { wealth: 3,
          offered: 0 },
        
        { wealth: 4,
          offered: 0.05 },
        
        { wealth: 5,
          offered: 0.1 }
        ],
        cargoTypes : {},
        seasons : {},
        cargoTable : {},
        wineBrandyPrice : [],
        qualities : {}
};

// This defines the standard money used. 
// "moneyNames" is what currency name to look for when creating a character 
// The money keys are used for parsing input (like commands)
// Override these values if you wish to have a campaign in a different setting
WFRP4E.moneyNames = {
    "gc" : "NAME.GC",
    "ss" : "NAME.SS",
    "bp" : "NAME.BP"
};

WFRP4E.moneyValues = {
    "gc" : 240,
    "ss" : 20,
    "bp" : 1
};

WFRP4E.hitLocationTables = {
    "hitloc": "WFRP4E.hitLocationTables.hitloc",
    "snake": "WFRP4E.hitLocationTables.snake",
    "spider": "WFRP4E.hitLocationTables.spider"
};

WFRP4E.extendedTestCompletion = {
    none: "ExtendedTest.None",
    reset: "ExtendedTest.Reset",
    remove: "ExtendedTest.Remove"
};

WFRP4E.actorSizeEncumbrance = {
    "tiny": 0,
    "ltl": 2,
    "sml": 5,
    "avg": 10,
    "lrg": 20,
    "enor": 40,
    "mnst": 100
};

// For modules to add to these, they need to be merged
WFRP4E.systemItems = {};
WFRP4E.systemEffects = {};
WFRP4E.groupAdvantageActions = [
    {
        cost: 1,
        name: "Powalenie",
        description: "W starciu z bardziej wyszkolonym przeciwnikiem czasami brutalna sia moe odnie sukces tam, gdzie inne podejcia zawodz.",
        effect: "<strong>Akcja Specjalna</strong>: Aby Powali przeciwnika, wykonaj Przeciwstawny Test Siy ze swoim Przeciwnikiem (zarwno Ty, jak i Twj przeciwnik przetestujcie swj Atrybut Siy). Kto zdobdzie wysze PS, wygrywa. Jeli wygrasz Test, twj przeciwnik zyskuje stan @Stan[Leenie] i zyskuje +1 Przewag. Jeli przegrasz, Twj przeciwnik zyskuje +1 Przewagi, a Twoja Akcja si koczy.",
        test: {
            type: "characteristic",
            value: "s"
        }
    },
    {
        cost: 1,
        name: "Podstp",
        description: "Powicasz chwil, by rzuci przeciwnikowi brud w oczy lub podpali go odrobin poncego oleju. Ten manewr jest ryzykowny i niewielu wrogw daje si oszuka w ten sam sposb wicej ni raz.",
        effect: "<strong>Akcja specjalna</strong>: Aby oszuka przeciwnika, wykonaj Przeciwstawny Test Zwinnoci (zarwno ty, jak i przeciwnik przetestujcie swj atrybut Zwinnoci). Kto zdobdzie wicej PS, wygrywa. Jeli wygrasz Test, zyskujesz +1 Przewagi. Jeli MG uzna, e okolicznoci do tego pasuj, moesz rwnie zmusi przeciwnika do wybrania stanu @Condition[Podpalenie], @Condition[Olepienie] lub @Condition[Spltanie]. Jeli przegrasz Test, twj przeciwnik zyskuje +1 Przewagi, a Twoja Akcja si koczy. MG moe odrzuci ktrykolwiek z tych Warunkw, jeli nie masz odpowiedniego przedmiotu do rki lub naoye ten sam Stan na przeciwnika wczeniej.",
        test: {
            type: "characteristic",
            value: "ag"
        }
    },
    {
        cost: 2,
        name: "Dodatkowy wysiek",
        description: "In desperate circumstances you can use the momentum you have gained to increase your chance of success.",
        effect: "<strong>Free Action</strong>: You gain a +10% bonus to any Test before you make it. You may spend extra Advantage to add an additional +10% bonus per Advantage spent. For example, you could spend 3 Advantage for a +20% bonus, or 4 Advantage for a +30%bonus. This Test never generates Advantage for the character performing it.",
    },
    {
        cost: 2,
        name: "Uciekaj przed zagroeniem",
        description: "Wykorzystujesz chwilowy zastj lub rozproszenie uwagi, aby oderwa si od walki.",
        effect: "<strong>Ruch</strong>: Moesz oddali si od przeciwnikw bez kary. Zastpuje to reguy @UUID[Compendium.wfrp4e-core.journal-entries.NS3YGlJQxwTggjRX.JournalEntryPage.bdfiyhEYtKs7irqc#disengaging]{Opuszczenie Starcia}.",
    },
    {
        cost: 4,
        name: "Dodatkowa Akcja ",
        description: "Wykorzystujesz okazj, aby osign co niezwykego.",
        effect: "<strong>Darmowa Akcja</strong>: Wykonujesz dodatkow Akcj. Ta Akcja nigdy nie generuje Przewagi dla postaci, ktra j wykonuje. Moesz wyda Przewag, aby wykona Dodatkow Akcj tylko raz na tur.",
    }
];

WFRP4E.PrepareSystemItems = function() {

    this.systemItems = mergeObject(this.systemItems, {
        reload : {
            type: "extendedTest",
            name: "",
            system: {
                SL: {
                },
                test: {
                    value: ""
                },
                completion: {
                    value: "remove"
                }
            },
            flags: {
                wfrp4e: {
                    reloading: ""
                }
            }
        },
        improv : {
            name: game.i18n.localize("NAME.Improvised"),
            type: "weapon",
            effects : [],
            system: {
                damage: { value: "SB + 1" },
                reach: { value: "personal" },
                weaponGroup: { value: "basic" },
                twohanded: { value: false },
                qualities: { value: [] },
                flaws: { value: [{name : "undamaging"}] },
                special: { value: "" },
                range: { value: "" },
                ammunitionGroup: { value: "" },
                offhand: { value: false },
            }
        },
        stomp : {
            name: game.i18n.localize("NAME.Stomp"),
            type: "trait",
            effects : [],
            system: {
                specification: { value: "4" },
                rollable: { value: true, rollCharacteristic: "ws", bonusCharacteristic: "s", defaultDifficulty: "challenging", damage : true, skill : game.i18n.localize("NAME.MeleeBrawling") },
            }
        },
        unarmed : {
            name: game.i18n.localize("NAME.Unarmed"),
            type: "weapon",
            effects : [],
            system: {
                damage: { value: "SB + 0" },
                reach: { value: "personal" },
                weaponGroup: { value: "brawling" },
                twohanded: { value: false },
                qualities: { value: [] },
                flaws: { value: [{name : "undamaging"}] },
                special: { value: "" },
                range: { value: "" },
                ammunitionGroup: { value: "" },
                offhand: { value: false },
            }
        },

        fear : {
            name : game.i18n.localize("NAME.Fear"),
            type : "extendedTest",
            system : {
                completion:{value: 'remove'},
                description:{type: 'String', label: 'Description', value: ''},
                failingDecreases:{value: true},
                gmdescription:{type: 'String', label: 'Description', value: ''},
                hide: { test: false, progress: false },
                negativePossible: { value: false },
                SL: { current: 0, target: 1 },
                test: { value: game.i18n.localize("NAME.Cool") }
            },
            effects:
                [{
                    name: game.i18n.localize("NAME.Fear"),
                    icon: "systems/wfrp4e/icons/conditions/fear.png",
                    transfer: true,
                    statuses : ["fear"],
                    flags: {
                        wfrp4e: {
                            "effectTrigger": "dialogChoice",
                            "effectData": {
                                "description": game.i18n.localize("EFFECT.TestsToAffect"),
                                "slBonus": "-1"
                            },
                            "script": `
                                if (this.flags.wfrp4e.fearName)
                                    this.flags.wfrp4e.effectData.description += " " + this.flags.wfrp4e.fearName
                                else
                                    this.flags.wfrp4e.effectData.description += " " + game.i18n.localize("EFFECT.TheSourceOfFear")
                            `}
                    }
                }
                ]

        },

        terror: {

            name: game.i18n.localize("NAME.Terror"),
            icon: "systems/wfrp4e/icons/conditions/terror.png",
            transfer: true,
            flags: {
                wfrp4e: {
                    "effectTrigger": "oneTime",
                    "effectApplication": "actor",
                    "terrorValue": 1,
                    "script": `
                        let skillName = game.i18n.localize("NAME.Cool");
                        let test = await args.actor.setupSkill(skillName, {terror: true, appendTitle : " - Terror"});
                        await test.roll();
                        let terror = this.effect.flags.wfrp4e.terrorValue;  
                        if (test.result.outcome == "failure") {            
                            if (test.result.SL < 0)
                                terror += Math.abs(test.result.SL)
                            await args.actor.addCondition("broken", terror)
                        } else {
                            await args.actor.applyFear(terror, name);
                        }`
                }
            }
        }
    });


    this.systemEffects = mergeObject(this.systemEffects, {
        "enc1" : {
            name: game.i18n.localize("EFFECT.Encumbrance") + " 1",
            icon: "systems/wfrp4e/icons/effects/enc1.png",
            statuses : ["enc1"],
            flags: {
                wfrp4e: {
                    "effectTrigger": "prePrepareData",
                    "effectApplication": "actor",
                    "script": `
                        args.actor.characteristics.ag.modifier -= 10;
    
                        if (args.actor.details.move.value > 3)
                        {
                            args.actor.details.move.value -= 1;
                            if (args.actor.details.move.value < 3)
                                args.actor.details.move.value = 3
                        }
                        `
                }
            }
        },
        "enc2" : {
            name: game.i18n.localize("EFFECT.Encumbrance") + " 2",
            icon: "systems/wfrp4e/icons/effects/enc2.png",
            statuses : ["enc2"],
            flags: {
                wfrp4e: {
                    "effectTrigger": "prePrepareData",
                    "effectApplication": "actor",
                    "script": `
                        args.actor.characteristics.ag.modifier -= 20;
                        if (args.actor.details.move.value > 2)
                        {
                            args.actor.details.move.value -= 2;
                            if (args.actor.details.move.value < 2)
                                args.actor.details.move.value = 2
                        }
                        `
                }
            }
        },
        "enc3" : {
            name: game.i18n.localize("EFFECT.Encumbrance") + " 3",
            icon: "systems/wfrp4e/icons/effects/enc3.png",
            statuses : ["enc3"],
            flags: {
                wfrp4e: {
                    "effectTrigger": "prePrepareData",
                    "effectApplication": "actor",
                    "script": `
                        args.actor.details.move.value = 0;`
                }
            }
        },
        "cold1" : {
            name: game.i18n.localize("EFFECT.ColdExposure") + " 1",
            icon: "",
            statuses : ["cold1"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -10},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -10},
            ],
            flags: {
                wfrp4e: {
                    "effectTrigger": "",
                    "effectApplication": "actor",
                    "script": ``
                }
            }
        },
        "cold2" : {
            name: game.i18n.localize("EFFECT.ColdExposure") + " 2",
            icon: "",
            statuses : ["cold2"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -10},
                {key : "system.characteristics.s.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.modifier", mode: 2, value: -10},
                {key : "system.characteristics.i.modifier", mode: 2, value: -10},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -10},
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.modifier", mode: 2, value: -10},
                {key : "system.characteristics.fel.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1},
            ],
            flags: {
                wfrp4e: {
                    "effectTrigger": "",
                    "effectApplication": "actor",
                    "script": ``
                }
            }
        },
        "cold3" : {
            name: game.i18n.localize("EFFECT.ColdExposure") + " 3",
            icon: "",
            statuses : ["cold3"],
            flags: {
                wfrp4e: {
                    "effectTrigger": "invoke",
                    "effectApplication": "actor",
                    "script": `
                        let tb = this.actor.characteristics.t.bonus
                        let damage = (await new Roll("1d10").roll()).total
                        damage -= tb
                        if (damage <= 0) damage = 1
                        if (this.actor.status.wounds.value <= damage) {
                            await this.actor.addCondition("unconscious")
                        }
                        this.actor.modifyWounds(-damage)
                        ui.notifications.notify(game.i18n.format("TookDamage", { damage: damage }))
                    `
                }
            }
        },
        "heat1" : {
            name: game.i18n.localize("EFFECT.HeatExposure") + " 1",
            icon: "",
            statuses : ["heat1"],
            changes : [
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1},
            ],
            flags: {
                wfrp4e: {
                    "effectTrigger": "",
                    "effectApplication": "actor",
                    "script": ``
                }
            }
        },
        "heat2" : {
            name: game.i18n.localize("EFFECT.HeatExposure") + " 2",
            icon: "",
            statuses : ["heat2"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -10},
                {key : "system.characteristics.s.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.modifier", mode: 2, value: -10},
                {key : "system.characteristics.i.modifier", mode: 2, value: -10},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -10},
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.modifier", mode: 2, value: -10},
                {key : "system.characteristics.fel.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1},
            ],
            flags: {
                wfrp4e: {
                    "effectTrigger": "",
                    "effectApplication": "actor",
                    "script": ``
                }
            }
        },
        "heat3" : {
            name: game.i18n.localize("EFFECT.HeatExposure") + " 3",
            icon: "",
            statuses : ["heat3"],
            flags: {
                wfrp4e: {
                    "effectTrigger": "invoke",
                    "effectApplication": "actor",
                    "script": `
                        let tb = this.actor.characteristics.t.bonus
                        let damage = (await new Roll("1d10").roll()).total
                        damage -= tb
                        if (damage <= 0) {
                            damage = 1
                        }
                        this.actor.modifyWounds(-damage)
                        ui.notifications.notify(game.i18n.format("TookDamage", { damage: damage }))
                    `
                }
            }
        },
        "thirst1" : {
            name: game.i18n.localize("EFFECT.Thirst") + " 1",
            icon: "",
            statuses : ["thirst1"],
            changes : [
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.modifier", mode: 2, value: -10},
                {key : "system.characteristics.fel.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1},
            ],
            flags: {
                wfrp4e: {
                    "effectTrigger": "",
                    "effectApplication": "actor",
                    "script": ``
                }
            }
        },
        "thirst2" : {
            name: game.i18n.localize("EFFECT.Thirst") + " 2+",
            icon: "",
            statuses : ["thirst2"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -10},
                {key : "system.characteristics.s.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.modifier", mode: 2, value: -10},
                {key : "system.characteristics.i.modifier", mode: 2, value: -10},
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.modifier", mode: 2, value: -10},
                {key : "system.characteristics.fel.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1},
            ],
            flags: {
                wfrp4e: {
                    "effectTrigger": "invoke",
                    "effectApplication": "actor",
                    "script": `
                    let tb = this.actor.characteristics.t.bonus
                    let damage = (await new Roll("1d10").roll()).total
                    damage -= tb
                    if (damage <= 0) {
                        damage = 1
                    }
                    this.actor.modifyWounds(-damage)
                    ui.notifications.notify(game.i18n.format("TookDamage", { damage: damage }))
                `
                }
            }
        },
        "starvation1" : {
            name: game.i18n.localize("EFFECT.Starvation") + " 1",
            icon: "",
            statuses : ["starvation1"],
            changes : [
                {key : "system.characteristics.s.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1},
            ],
            flags: {
                wfrp4e: {
                    "effectTrigger": "",
                    "effectApplication": "actor",
                    "script": ``
                }
            }
        },
        "starvation2" : {
            name: game.i18n.localize("EFFECT.Starvation") + " 2",
            icon: "",
            statuses : ["starvation2"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -10},
                {key : "system.characteristics.s.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.modifier", mode: 2, value: -10},
                {key : "system.characteristics.i.modifier", mode: 2, value: -10},
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -10},
                {key : "system.characteristics.wp.modifier", mode: 2, value: -10},
                {key : "system.characteristics.fel.modifier", mode: 2, value: -10},
                {key : "system.characteristics.t.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.s.calculationBonusModifier", mode: 2, value: 1},
                {key : "system.characteristics.wp.calculationBonusModifier", mode: 2, value: 1},
            ],
            flags: {
                wfrp4e: {
                    "effectTrigger": "invoke",
                    "effectApplication": "actor",
                    "script": `
                    let tb = this.actor.characteristics.t.bonus
                    let damage = (await new Roll("1d10").roll()).total
                    damage -= tb
                    if (damage <= 0) {
                        damage = 1
                    }
                    this.actor.modifyWounds(-damage)
                    ui.notifications.notify(game.i18n.format("TookDamage", { damage: damage }))
                `
                }
            }
        },
        "infighting" : {
            name: game.i18n.localize("EFFECT.Infighting"),
            icon: "modules/wfrp4e-core/icons/talents/in-fighter.png",
            statuses : ["infighting"],
            flags: {
                wfrp4e: {
                    "effectTrigger": "prePrepareItem",
                    "effectApplication": "actor",
                    "script": `
                        if (args.item.type == "weapon" && args.item.isEquipped)
                        {
                            let weaponLength = args.item.reachNum
                            if (weaponLength > 3)
                            {
                                let improv = duplicate(game.wfrp4e.config.systemItems.improv)
                                improv.system.twohanded.value = args.item.twohanded.value
                                improv.system.offhand.value = args.item.offhand.value
                                improv.name = args.item.name + " (" + game.i18n.localize("EFFECT.Infighting") + ")"
                                mergeObject(args.item.system, improv.system, {overwrite : true})
                                args.item.system.qualities = improv.system.qualities
                                args.item.system.flaws = improv.system.flaws
                                args.item.name = improv.name
                                args.item.system.infighting = true;
                            }
                        }
                    `
                }
            }
        },
        "defensive" : {
            name: game.i18n.localize("EFFECT.OnDefensive"),
            icon: "",
            statuses : ["defensive"],
            flags: {
                wfrp4e: {
                    "effectTrigger": "prefillDialog",
                    "effectApplication": "actor",
                    "script": `
                        let skillName = this.effect.name.substring(this.effect.name.indexOf("[") + 1, this.effect.name.indexOf("]"))
                        if (!this.actor.isOpposing)
                        return
                        if ((args.type == "skill" && args.item.name == skillName) ||
                            (args.type == "weapon" && args.item.skillToUse.name == skillName) ||
                            (args.type == "cast" && skillName == (game.i18n.localize("NAME.Language") + " (" + game.i18n.localize("SPEC.Magick") + ")")) ||
                            (args.type == "prayer" && skillName == game.i18n.localize("NAME.Pray")) || 
                            (args.type == "trait" && args.item.rollable.skill == skillName))
                            args.prefillModifiers.modifier += 20` 
                }
            }
        },
        "dualwielder" : {
            name: game.i18n.localize("EFFECT.DualWielder"),
            icon: "modules/wfrp4e-core/icons/talents/dual-wielder.png",
            statuses : ["dualwielder"],
            flags: {
                wfrp4e: {
                    "effectTrigger": "prefillDialog",
                    "effectApplication": "actor",
                    "script": `
                        if (this.actor.isOpposing)
                            args.prefillModifiers.modifier -= 10` 
                }
            }
        },
        "consumealcohol1" : {
            name: game.i18n.localize("EFFECT.ConsumeAlcohol") + " 1",
            icon: "",
            statuses : ["consumealcohol1"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -10},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -10},
                {key : "system.characteristics.int.modifier", mode: 2, value: -10},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -10},
            ]
        },
        "consumealcohol2" : {
            name: game.i18n.localize("EFFECT.ConsumeAlcohol") + " 2",
            icon: "",
            statuses : ["consumealcohol2"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -20},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -20},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -20},
                {key : "system.characteristics.int.modifier", mode: 2, value: -20},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -20},
            ]
        },
        "consumealcohol3" : {
            name: game.i18n.localize("EFFECT.ConsumeAlcohol") + " 3",
            icon: "",
            statuses : ["consumealcohol3"],
            changes : [
                {key : "system.characteristics.bs.modifier", mode: 2, value: -30},
                {key : "system.characteristics.ag.modifier", mode: 2, value: -30},
                {key : "system.characteristics.ws.modifier", mode: 2, value: -30},
                {key : "system.characteristics.int.modifier", mode: 2, value: -30},
                {key : "system.characteristics.dex.modifier", mode: 2, value: -30},
            ]
        },
        "stinkingdrunk1" : {
            name: game.i18n.localize("EFFECT.MarienburghersCourage"),
            icon: "",
            statuses : ["stinkingdrunk1"],
            flags: {
                wfrp4e: {
                    "effectTrigger": "prefillDialog",
                    "effectApplication": "actor",
                    "script": `
                        let skillName = game.i18n.localize("NAME.Cool")
                        if (args.type=="skill" && args.item.name==skillName)
                            args.prefillModifiers.modifier += 20` 
                }
            }
        }
    });

    this.statusEffects = [
        {
            icon: "systems/wfrp4e/icons/conditions/bleeding.png",
            id: "bleeding",
            statuses: ["bleeding"],
            name: "WFRP4E.ConditionName.Bleeding",
            flags: {
                wfrp4e: {
                    "trigger": "endRound",
                    "value": 1
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/poisoned.png",
            id: "poisoned",
            statuses: ["poisoned"],
            name: "WFRP4E.ConditionName.Poisoned",
            flags: {
                wfrp4e: {
                    "trigger": "endRound",
                    "effectTrigger": "prefillDialog",
                    "script": "args.prefillModifiers.modifier -= 10 * this.effect.conditionValue",
                    "value": 1
                }
            }
            
        },
        {
            icon: "systems/wfrp4e/icons/conditions/ablaze.png",
            id: "ablaze",
            statuses: ["ablaze"],
            name: "WFRP4E.ConditionName.Ablaze",
            flags: {
                wfrp4e: {
                    "trigger": "endRound",
                    "value": 1
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/deafened.png",
            id: "deafened",
            statuses: ["deafened"],
            name: "WFRP4E.ConditionName.Deafened",
            flags: {
                wfrp4e: {
                    "trigger": "endRound",
                    "effectTrigger": "dialogChoice",
                    "effectData" : {
                        "description" : game.i18n.localize("EFFECT.TestsRelatedToHearing"),
                        "modifier" : "-10 * this.flags.wfrp4e.value"
                    },
                    "value": 1
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/stunned.png",
            id: "stunned",
            statuses: ["stunned"],
            name: "WFRP4E.ConditionName.Stunned",
            flags: {
                wfrp4e: {
                    "trigger": "endRound",
                    "effectTrigger": "prefillDialog",
                    "script": "args.prefillModifiers.modifier -= 10 * this.effect.conditionValue",
                    "value": 1,
                    "secondaryEffect" :{
                        "effectTrigger": "targetPrefillDialog",
                        "script": "if (args.item && args.item.attackType=='melee') args.prefillModifiers.slBonus += 1",
                    }
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/entangled.png",
            id: "entangled",
            statuses: ["entangled"],
            name: "WFRP4E.ConditionName.Entangled",
            flags: {
                wfrp4e: {
                    "trigger": "startTurn",
                    "effectTrigger": "dialogChoice",
                    "effectData" : {
                        "description" : game.i18n.localize("EFFECT.TestsRelatedToMovementOfAnyKind"),
                        "modifier" : "-10 * this.flags.wfrp4e.value"
                    },
                    "value": 1
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/fatigued.png",
            id: "fatigued",
            statuses: ["fatigued"],
            name: "WFRP4E.ConditionName.Fatigued",
            flags: {
                wfrp4e: {
                    "effectTrigger": "prefillDialog",
                    "script": "args.prefillModifiers.modifier -= 10 * this.effect.conditionValue",
                    "value" : 1
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/blinded.png",
            id: "blinded",
            statuses: ["blinded"],
            name: "WFRP4E.ConditionName.Blinded",
            flags: {
                wfrp4e: {
                    "trigger": "endRound",
                    "effectTrigger": "dialogChoice",
                    "effectData" : {
                        "description" : game.i18n.localize("EFFECT.TestsRelatedToSight"),
                        "modifier" : "-10 * this.flags.wfrp4e.value"
                    },
                    "value": 1,
                    "secondaryEffect" :{
                        "effectTrigger": "targetPrefillDialog",
                        "script": "if (args.item && args.item.attackType=='melee') args.prefillModifiers.modifier += 10 * this.effect.conditionValue",
                    }
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/broken.png",
            id: "broken",
            statuses: ["broken"],
            name: "WFRP4E.ConditionName.Broken",
            flags: {
                wfrp4e: {
                    "trigger": "endRound",
                    "effectTrigger": "prefillDialog",
                    "script": "if (args.item.type != 'skill' || !(args.item.name.includes(game.i18n.localize('NAME.Stealth')) || args.item.name == game.i18n.localize('NAME.Athletics'))) args.prefillModifiers.modifier -= 10 * this.effect.conditionValue",
                    "value": 1
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/prone.png",
            id: "prone",
            statuses: ["prone"],
            name: "WFRP4E.ConditionName.Prone",
            flags: {
                wfrp4e: {
                    "effectTrigger": "dialogChoice",
                    "effectData" : {
                        "description" : game.i18n.localize("EFFECT.TestsRelatedToMovementOfAnyKind"),
                        "modifier" : "-20"
                    },
                    "value": null,
                    "secondaryEffect" :{
                        "effectTrigger": "targetPrefillDialog",
                        "script": "if (args.item?.attackType=='melee') args.prefillModifiers.modifier += 20",
                    }
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/fear.png",
            id: "fear",
            statuses: ["fear"],
            name: "WFRP4E.ConditionName.Fear",
            flags: {
                wfrp4e: {
                    "effectTrigger": "dialogChoice",
                    "effectData" : {
                        "description" : game.i18n.localize("EFFECT.TestsToAffect"),
                        "slBonus" : "-1"
                    },
                    "script" : `
                        if (this.flags.wfrp4e.fearName)
                            this.flags.wfrp4e.effectData.description += " " + this.flags.wfrp4e.fearName
                        else
                            this.flags.wfrp4e.effectData.description += " " + game.i18n.localize("EFFECT.TheSourceOfFear")
                    `,
                    "value": null
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/surprised.png",
            id: "surprised",
            statuses: ["surprised"],
            name: "WFRP4E.ConditionName.Surprised",
            flags: {
                wfrp4e: {
                    "value": null,
                    "secondaryEffect" :{
                        "effectTrigger": "targetPrefillDialog",
                        "script": "if (args.type == 'weapon' && args.item.attackType=='melee') args.prefillModifiers.modifier += 20",
                    }
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/unconscious.png",
            id: "unconscious",
            statuses: ["unconscious"],
            name: "WFRP4E.ConditionName.Unconscious",
            flags: {
                wfrp4e: {
                    "value": null
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/conditions/grappling.png",
            id: "grappling",
            statuses: ["grappling"],
            name: "WFRP4E.ConditionName.Grappling",
            flags: {
                wfrp4e: {
                    "value": null
                }
            }
            
        },
        {
            icon: "systems/wfrp4e/icons/conditions/engaged.png",
            id: "engaged",
            statuses: ["engaged"],
            name: "WFRP4E.ConditionName.Engaged",
            flags: {
                wfrp4e: {
                    "value": null
                }
            }
        },
        {
            icon: "systems/wfrp4e/icons/defeated.png",
            id: "dead",
            statuses: ["dead"],
            name: "WFRP4E.ConditionName.Dead",
            flags: {
                wfrp4e: {
                    "value": null
                }
            }
            
        }
    ];
};

WFRP4E.conditionScripts = {
    "ablaze" : async function (actor) {
        let effect = actor.hasCondition("ablaze");
        let value = effect.conditionValue;
 
        let leastProtectedLoc;
        let leastProtectedValue = 999;
        for (let loc in actor.status.armour)
        {
            if (actor.status.armour[loc].value != undefined && actor.status.armour[loc].value < leastProtectedValue)
            {
                leastProtectedLoc = loc;
                leastProtectedValue = actor.status.armour[loc].value;
            }
        }
        let formula = `1d10 + ${value - 1}`;
        let msg = `<h2>${game.i18n.localize("WFRP4E.ConditionName.Ablaze")}</h2><b>${game.i18n.localize("Formula")}</b>: @FORMULA<br><b>${game.i18n.localize("Roll")}</b>: @ROLLTERMS`; 
        
        let args = {msg, formula};
        await Promise.all(actor.runScripts("preApplyCondition", {effect, data : args}));
        formula = args.formula;
        msg = args.msg;
        let roll = await new Roll(`${formula}`).roll({async: true});
        let terms = roll.terms.map(i => i.total).join(" ");
        msg = msg.replace("@FORMULA", formula);
        msg = msg.replace("@ROLLTERMS", terms);

        value = effect.conditionValue;
        let damageMsg = (`<br>` + await actor.applyBasicDamage(roll.total, {loc: leastProtectedLoc, suppressMsg : true})).split("");
        msg += damageMsg.join("");
        let messageData = game.wfrp4e.utility.chatDataSetup(msg);
        messageData.speaker = {alias: actor.prototypeToken.name};
        await Promise.all(actor.runScripts("applyCondition", {effect, data : {messageData}}));
        return messageData
    },
    "poisoned" : async function (actor) {
        let effect = actor.hasCondition("poisoned");
        let msg = `<h2>${game.i18n.localize("WFRP4E.ConditionName.Poisoned")}</h2>`;

        let damage = effect.conditionValue;
        let args = {msg, damage};
        await Promise.all(actor.runScripts("preApplyCondition", {effect, data : args}));
        msg = args.msg;
        damage = args.damage;
        msg += await actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, suppressMsg : true});
        if (actor.isOwner) {
            let test = await actor.setupSkill(game.i18n.localize("NAME.Endurance"), {appendTitle : " - Zatrucie"});
            await test.roll();
            if (test.result.outcome == "success") {
                await actor.removeCondition("poisoned", Math.min(test.result.SL, conditionValue));
                msg += "Liczba usunitych stanw Zatrucia: " + Math.min(test.result.SL, conditionValue);
            } else {
                msg += "Nie udao si usun stanu Zatrucia";
            }
        }
        let messageData = game.wfrp4e.utility.chatDataSetup(msg);
        messageData.speaker = {alias: actor.prototypeToken.name};
        await Promise.all(actor.runScripts("applyCondition", {effect, data : {messageData}}));
        return messageData
    },
    "bleeding" : async function(actor) {
        let effect = actor.hasCondition("bleeding");
        let bleedingAmt;
        let bleedingRoll;
        let msg = `<h2>${game.i18n.localize("WFRP4E.ConditionName.Bleeding")}</h2>`;

        let damage = effect.conditionValue;
        let args = {msg, damage};
        await Promise.all(actor.runScripts("preApplyCondition", {effect, data : args}));
        msg = args.msg;
        damage = args.damage;
        msg += await actor.applyBasicDamage(damage, {damageType : game.wfrp4e.config.DAMAGE_TYPE.IGNORE_ALL, minimumOne : false, suppressMsg : true});

        if (actor.status.wounds.value == 0 && !actor.hasCondition("unconscious")) {
            let test = await actor.setupSkill(game.i18n.localize("NAME.Endurance"));
            await test.roll();
            if (test.result.outcome == "failure") {
                await actor.addCondition("unconscious");
                msg += `<br>${game.i18n.format("BleedUnc", {name: actor.prototypeToken.name })}`;
            }
        }

        if (actor.hasCondition("unconscious")) {
            bleedingAmt = effect.conditionValue;
            bleedingRoll = (await new Roll("1d100").roll()).total;
            if (bleedingRoll <= bleedingAmt * 10) {
                msg += `<br>${game.i18n.format("BleedFail", {name: actor.prototypeToken.name} )} (${game.i18n.localize("Rolled")} ${bleedingRoll})`;
                await actor.addCondition("dead");
            }
            else if (bleedingRoll % 11 == 0) {
                msg += `<br>${game.i18n.format("BleedCrit", { name: actor.prototypeToken.name } )} (${game.i18n.localize("Rolled")} ${bleedingRoll})`;
                await actor.removeCondition("bleeding");
            }
            else {
                msg += `<br>${game.i18n.localize("BleedRoll")}: ${bleedingRoll}`;
            }
        }

        let messageData = game.wfrp4e.utility.chatDataSetup(msg);
        messageData.speaker = {alias: actor.prototypeToken.name};
        await Promise.all(actor.runScripts("applyCondition", {effect, data : {messageData, bleedingRoll}}));
        return messageData
    },
    "stunned" : async function(actor) {
        let effect = actor.hasCondition("stunned");
        let conditionValue = effect.conditionValue;
        let msg = `<h2>${game.i18n.localize("WFRP4E.ConditionName.Stunned")}</h2>`;
        let damage = effect.conditionValue;
        let args = {msg, damage};
        await Promise.all(actor.runScripts("preApplyCondition", {effect, data : args}));
        if (actor.isOwner) {
            let test = await actor.setupSkill(game.i18n.localize("NAME.Endurance"), {appendTitle : " - Oszoomienie"});
            await test.roll();
            if (test.result.outcome == "success") {
                await actor.removeCondition("stunned", Math.min(test.result.SL, conditionValue));
                msg += "Liczba usunitych stanw Oszoomienia: " + Math.min(test.result.SL, conditionValue);
            } else {
                msg += "Nie udao si usun stanu Oszoomienia";
            }
        }
        let messageData = game.wfrp4e.utility.chatDataSetup(msg);
        messageData.speaker = {alias: actor.prototypeToken.name};
        await Promise.all(actor.runScripts("applyCondition", {effect, data : {messageData}}));
        return messageData
    },
    "broken" : async function(actor) {
        let effect = actor.hasCondition("broken");
        let conditionValue = effect.conditionValue;
        let msg = `<h2>${game.i18n.localize("WFRP4E.ConditionName.Broken")}</h2>`;
        let args = {msg, conditionValue};
        await Promise.all(actor.runScripts("preApplyCondition", {effect, data : args}));
        if (actor.isOwner) {
            let test = await actor.setupSkill(game.i18n.localize("NAME.Cool"), {appendTitle : " - Panika"});
            await test.roll();
            if (test.result.outcome == "success") {
                await actor.removeCondition("broken", Math.min(test.result.SL, conditionValue));
                msg += "Liczba usunitych stanw Paniki: " + Math.min(test.result.SL, conditionValue);
            } else {
                msg += "Nie udao si usun stanu Paniki";
            }
        }
        let messageData = game.wfrp4e.utility.chatDataSetup(msg);
        messageData.speaker = {alias: actor.prototypeToken.name};
        await Promise.all(actor.runScripts("applyCondition", {effect, data : {messageData}}));
        return messageData
    },
    "entangled" : async function(actor) {
        let effect = actor.hasCondition("entangled");
        let conditionValue = effect.conditionValue;
        let conditionStrength = effect.flags.wfrp4e.extra;
        let msg = `<h2>Pochwycenie</h2>`;
        let args = {msg, conditionValue, conditionStrength};
        await Promise.all(actor.runScripts("preApplyCondition", {effect, data : args}));
        let test = await actor.setupCharacteristic("s", {appendTitle : " - Pochwycenie vs " + conditionStrength});
        await test.roll();
        if (conditionStrength) {
            const roll = await new Roll("1d100").roll();
            await game.dice3d.showForRoll(roll, game.user, true, null, false);
            const opponentSl = Math.floor(Number.parseInt(conditionStrength) / 10) - Math.floor(roll.total/ 10);
            if (test.result.SL - opponentSl > 0) {
                await actor.removeCondition("entangled", Math.min(test.result.SL - opponentSl, conditionValue));
                msg += `Test Przeciwstawny: ${opponentSl} (${roll.total} vs ${conditionStrength})<br/>`;
                msg += "Liczba usunitych stanw Pochwycenie: " + Math.min(test.result.SL - opponentSl, conditionValue);
            } else {
                msg += "Nie udao si usun stanu Pochwycenie";
            }
        } else {
            if (test.result.outcome == "success") {
                await actor.removeCondition("entangled", Math.min(test.result.SL, conditionValue));
                msg += "Liczba usunitych stanw Pochwycenie: " + Math.min(test.result.SL, conditionValue);
            } else {
                msg += "Nie udao si usun stanu Pochwycenie";
            }
        }
        let messageData = game.wfrp4e.utility.chatDataSetup(msg);
        messageData.speaker = {alias: actor.prototypeToken.name};
        await Promise.all(actor.runScripts("applyCondition", {effect, data : {messageData}}));
        return messageData
    }
};

WFRP4E.customPrefillModifiers = {

};

WFRP4E.effectTextStyle = CONFIG.canvasTextStyle.clone();
WFRP4E.effectTextStyle.fontSize = "30";
WFRP4E.effectTextStyle.fontFamily="CaslonAntique";

WFRP4E.rollModes = CONFIG.Dice.rollModes;

WFRP4E.effectApplications = {
    document : "EffectApplication.Type.Document",
    damage : "EffectApplication.Type.Damage",
    target : "EffectApplication.Type.Target",
    area : "EffectApplication.Type.Area",
    aura : "EffectApplication.Type.Aura",
    other : "EffectApplication.Type.Other"
};


// To migrate
// "invoke => manual"
// "oneTime" => "immediate"
// "addItems" => "immediate"
// "dialogChoice" => ???
// "prefillDialog" => "dialog"
// "targetPrefillDialog" => "dialog" with targeter option true
WFRP4E.scriptTriggers = {
    "manual" : "Manually Invoked",
    "immediate" : "Immediate",
    "dialog" : "Dialog",
    "update" : "On Update",
    "prePrepareData" : "Pre-Prepare Data",
    "prePrepareItems" : "Pre-Prepare Actor Items",
    "prepareData" : "Prepare Data",
    "prepareOwned" : "Prepare Owned Data (For Items)",
    "preWoundCalc" : "Pre-Wound Calculation",
    "woundCalc" : "Wound Calculation",
    "calculateSize" : "Size Calculation",
    "preAPCalc" : "Pre-Armour Calculation",
    "APCalc" : "Armour Calculation",
    "preApplyDamage" : "Pre-Apply Damage",
    "applyDamage" : "Apply Damage",
    "preTakeDamage" : "Pre-Take Damage",
    "takeDamage" : "Take Damage",
    "preApplyCondition" : "Pre-Apply Condition",
    "applyCondition" : "Apply Condition",
    "prePrepareItem" : "Pre-Prepare Item",
    "prepareItem" : "Prepare Item",
    "preRollTest" : "Pre-Roll Test",
    "preRollWeaponTest" : "Pre-Roll Weapon Test",
    "preRollCastTest" : "Pre-Roll Casting Test",
    "preChannellingTest" : "Pre-Roll Channelling Test",
    "preRollPrayerTest" : "Pre-Roll Prayer Test",
    "preRollTraitTest" : "Pre-Roll Trait Test",
    "rollTest" : "Roll Test",
    "rollIncomeTest" : "Roll Income Test",
    "rollWeaponTest" : "Roll Weapon Test",
    "rollCastTest" : "Roll Casting Test",
    "rollChannellingTest" : "Roll Channelling Test",
    "rollPrayerTest" : "Roll Prayer Test",
    "rollTraitTest" : "Roll Trait Test",
    "preOpposedAttacker" : "Pre-Opposed Attacker",
    "preOpposedDefender" : "Pre-Opposed Defender",
    "opposedAttacker" : "Opposed Attacker",
    "opposedDefender" : "Opposed Defender",
    "calculateOpposedDamage" : "Calculate Opposed Damage",
    "targetPrefillDialog" : "Prefill Targeter's Dialog",
    "getInitiativeFormula" : "Get Initiative",
    "endTurn" : "End Turn",
    "startTurn" : "Start Turn",
    "endRound" : "End Round",
    "endCombat" : "End Combat"
};

WFRP4E.syncTriggers = [
    "prePrepareData",
    "prePrepareItems",
    "prepareData",
    "preWoundCalc",
    "woundCalc",
    "calculateSize",
    "preAPCalc",
    "APCalc",
    "prePrepareItem",
    "prepareItem",
    "getInitiativeFormula"
];

WFRP4E.effectPlaceholder = {

    "invoke" : 
    `This effect is only applied when the Invoke button is pressed. Can be async.
    args:

    none`,
    "oneTime" : 
    `This effect happens once, immediately when applied. Can be async.
    args:

    actor : actor who owns the effect
    `,

    "addItems" : 
    `Like Immediate effects, this happens once, but the effect will remain. This lets the effect also delete the added items when the effect is deleted. Can be async.
    args: 

    actor : actor who owns the effect
    `,

    "prefillDialog" : 
    `This effect is applied before rendering the roll dialog, and is meant to change the values prefilled in the bonus section. Can be async.
    args:

    prefillModifiers : {modifier, difficulty, slBonus, successBonus}
    type: string, 'weapon', 'skill' 'characteristic', etc.
    item: the item used of the aforementioned type
    options: other details about the test (options.rest or options.mutate for example)
    
    Example: 
    if (args.type == "skill" && args.item.name == "Athletics") args.prefillModifiers.modifier += 10`,

    "update" : 
    `This effect runs when an actor or an embedded document is changed. Can be async.
    args:

    item: if an item is modified, it is provided as an argument
    effect: if an effect is modified, it is provided as an argument
    `,

    "prePrepareData" : 
    `This effect is applied before any actor data is calculated. Cannot be async.
    args:

    actor : actor who owns the effect
    `,

    "prePrepareItems" : 
    `This effect is applied before items are sorted and calculated. Cannot be async.

    actor : actor who owns the effect
    `,

    "prepareData" : 
    `This effect is applied after actor data is calculated and processed. Cannot be async.

    args:

    actor : actor who owns the effect
    `,

    "preWoundCalc" : 
    `This effect is applied right before wound calculation, ideal for swapping out characteristics or adding multipiliers. Cannot be async.

    actor : actor who owns the effect
    sb : Strength Bonus
    tb : Toughness Bonus
    wpb : Willpower Bonus
    multiplier : {
        sb : SB Multiplier
        tb : TB Multiplier
        wpb : WPB Modifier
    }

    e.g. for Hardy: "args.multiplier.tb += 1"
    `,

    "woundCalc" : 
    `This effect happens after wound calculation, ideal for multiplying the result. Cannot be async.

    args:

    actor : actor who owns the effect
    wounds : wounds calculated

    e.g. for Swarm: "wounds *= 5"
    `,

    "calculateSize" : 
    `This effect is applied after size calculation, where it can be overridden. Cannot be async.

    args:

    size : Size value

    e.g. for Small: "args.size = 'sml'"
    `,

    "preAPCalc" : `This effect is applied before AP is calculated. Cannot be async.

    args:

    AP : Armour object

    e.g. args.AP.head.value += 1
    `,
    "APCalc" : `This effect is applied after AP is calculated. Cannot be async.

    args:

    AP : Armour object

    e.g. args.AP.head.value += 1
    `,

    "preApplyDamage" : 
    `This effect happens before applying damage in an opposed test. Can be async.

    args:

    actor : actor who is taking damage
    attacker : actor who is attacking
    opposedTest : object containing opposed test data
    damageType : damage type selected (ignore TB, AP, etc.)
    weaponProperties : object of qualities/flaws of the attacking weapon
    applyAP : whether AP is reducing damage
    applyTB : whether TB is reducing damage
    totalWoundLoss : Total Wound Loss BEFORE REDUCTIONS
    AP : Defender's AP object
    `,
    "applyDamage" : 
    `This effect happens after damage in an opposed test is calculated, but before actor data is updated. Can be async.

    args:

    actor : actor who is taking damage
    attacker : actor who is attacking
    opposedTest : object containing opposed test data
    damageType : damage type selected (ignore TB, AP, etc.)
    totalWoundLoss : Wound loss after mitigations
    AP : data about the AP used
    updateMsg : starting string for damage update message
    messageElements : array of strings used to show how damage mitigation was calculated,
    extraMessages : text applied at the end of updateMsg
    `,

    "preTakeDamage" : 
    `This effect happens before taking damage in an opposed test. Can be async.

    args:
    actor : actor who is taking damage
    attacker : actor who is attacking
    opposedTest : object containing opposed test data
    damageType : damage type selected (ignore TB, AP, etc.)
    weaponProperties : object of qualities/flaws of the attacking weapon
    applyAP : whether AP is reducing damage
    applyTB : whether TB is reducing damage
    totalWoundLoss : Total Wound Loss BEFORE REDUCTIONS
    AP : Defender's AP object
    `,
    
    "takeDamage" : 
    `This effect happens after damage in an opposed test is calculated, but before actor data is updated. Can be async.

    args:

    actor : actor who is taking damage
    attacker : actor who is attacking
    opposedTest : object containing opposed test data
    damageType : damage type selected (ignore TB, AP, etc.)
    totalWoundLoss : Wound loss after mitigations
    AP : data about the AP used
    updateMsg : starting string for damage update message
    messageElements : array of strings used to show how damage mitigation was calculated,
    extraMessages : text applied at the end of updateMsg
    `,

    "preApplyCondition" :  
    `This effect happens before effects of a condition are applied. Can be async.

    args:

    effect : condition being applied
    data : {
        msg : Chat message about the application of the condition
        <other data, possibly condition specific>
    }
    `,

    "applyCondition" :  
    `This effect happens after effects of a condition are applied. Can be async.

    args:

    effect : condition being applied
    data : {
        messageData : Chat message about the application of the condition
        <other data, possibly condition specific>
    }
    `,
    "prePrepareItem" : 
    `This effect is applied before an item is processed with actor data. Cannot be async.

    args:

    item : item being processed
    `,
    "prepareItem" : 
    `This effect is applied after an item is processed with actor data. Cannot be async.

    args:

    item : item processed
    `,
    "preRollTest": 
    `This effect is applied before a test is calculated. Can be async.

    args:

    testData: All the data needed to evaluate test results
    chatOptions: Data for the card display, title, template, etc
    `,
    "preRollWeaponTest" :  
    `This effect is applied before a weapon test is calculated. Can be async.

    args:

    testData: All the data needed to evaluate test results
    chatOptions: Data for the card display, title, template, etc
    `,

    "preRollCastTest" :  
    `This effect is applied before a casting test is calculated. Can be async.

    args:

    testData: All the data needed to evaluate test results
    chatOptions: Data for the card display, title, template, etc
    `,

    "preChannellingTest" :  
    `This effect is applied before a channelling test is calculated. Can be async.

    args:

    testData: All the data needed to evaluate test results
    chatOptions: Data for the card display, title, template, etc
    `,

    "preRollPrayerTest" :  
    `This effect is applied before a prayer test is calculated. Can be async.

    args:

    testData: All the data needed to evaluate test results
    chatOptions: Data for the card display, title, template, etc
    `,

    "preRollTraitTest" :  
    `This effect is applied before a trait test is calculated. Can be async.

    args:

    testData: All the data needed to evaluate test results
    chatOptions: Data for the card display, title, template, etc
    `,

    "rollTest" : 
    `This effect is applied after a test is calculated. Can be async.

    args:

    test: object containing test and result information
    chatOptions: Data for the card display, title, template, etc
    `,
    "rollIncomeTest" : 
    `This effect is applied after an income test is calculated. Can be async.

    args:

    test: object containing test and result information
    chatOptions: Data for the card display, title, template, etc
    `,

    "rollWeaponTest" : 
    `This effect is applied after a weapon test is calculated. Can be async.

    args:

    test: object containing test and result information
    chatOptions: Data for the card display, title, template, etc
    `,

    "rollCastTest" : 
    `This effect is applied after a casting test is calculated. Can be async.

    args:

    test: object containing test and result information
    chatOptions: Data for the card display, title, template, etc
    `,

    "rollChannellingTest" : 
    `This effect is applied after a channelling test is calculated. Can be async.

    args:

    test: object containing test and result information
    chatOptions: Data for the card display, title, template, etc
    `,

    "rollPrayerTest" : 
    `This effect is applied after a prayer test is calculated. Can be async.

    args:

    test: object containing test and result information
    chatOptions: Data for the card display, title, template, etc
    `,

    "rollTraitTest" : 
    `This effect is applied after a trait test is calculated. Can be async.

    args:

    test: object containing test and result information
    chatOptions: Data for the card display, title, template, etc
    `,

    "preOpposedAttacker" : 
    `This effect is applied before an opposed test result begins calculation, as the attacker. Can be async.

    args:

    attackerTest: test object of the attacker
    defenderTest: test object of the defender
    opposedTest: opposedTest object, before calculation
    `,
    "preOpposedDefender" : 
    `This effect is applied before an opposed test result begins calculation, as the defender. Can be async.

    args:

    attackerTest: test object of the attacker
    defenderTest: test object of the defender
    opposedTest: opposedTest object, before calculation
    `,

    "opposedAttacker" : 
    `This effect is applied after an opposed test result begins calculation, as the attacker. Can be async.

    args:

    attackerTest: test object of the attacker
    defenderTest: test object of the defender
    opposedTest: opposedTest object, after calculation
    `,

    "opposedDefender" : 
    `This effect is applied after an opposed test result begins calculation, as the defender. Can be async.

    args:

    attackerTest: test object of the attacker
    defenderTest: test object of the defender
    opposedTest: opposedTest object, after calculation
    `,

    "calculateOpposedDamage" : 
    `This effect is applied during an opposed test damage calculation. This effect runs on the attacking actor. Can be async.

    args:

    damage : initial damage calculation before multipliers
    damageMultiplier : multiplier calculated based on size difference
    sizeDiff : numeric difference in sized, will then be used to add damaging/impact
    opposedTest : opposedTest object,
    addDamaging : whether to add the Damaging quality 
    addImpact : whether to add the Impact quality
    `,

    "getInitiativeFormula" : 
    `This effect runs when determining actor's initiative. Cannot be async.

    args:

    initiative: Calculated initiative value
    `,

    "targetPrefillDialog" : 
    `This effect is applied to another actor whenever they target this actor, and is meant to change the values prefilled in the bonus section. Can be async.
    args:

    prefillModifiers : {modifier, difficulty, slBonus, successBonus}
    type: string, 'weapon', 'skill' 'characteristic', etc.
    item: the item used of the aforementioned type
    options: other details about the test (options.rest or options.mutate for example)
    
    Example: 
    if (args.type == "skill" && args.item.name == "Athletics") args.prefillModifiers.modifier += 10`,

    "endTurn" : 
    `This effect runs at the end of an actor's turn. Can be async.

    args:

    combat: current combat
    `,

    "startTurn" : 
    `This effect runs at the start of an actor's turn. Can be async.

    args:

    combat: current combat
    `,

    "endRound" :  
    `This effect runs at the end of a round. Can be async.

    args:

    combat: current combat
    `,
    "endCombat" :  
    `This effect runs when combat has ended. Can be async.

    args:

    combat: current combat
    `,

    "this" : 
    `
    
    All effects have access to: 
        this.actor : actor running the effect
        this.effect : effect being executed
        this.item : item that has the effect, if effect comes from an item`

   
    

};

class ActorSettings extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "actor-settings";
        options.template = "systems/wfrp4e/templates/apps/actor-settings.hbs";
        options.height = "auto";
        options.width = 400;
        options.minimizable = true;
        options.title = "Actor Settings";
        return options;
    }

    getData() {
        let data = super.getData();
        data.tables =  game.wfrp4e.config.hitLocationTables;

        data.displays = {};

        if (this.object.type == "character")
        {
            data.displays.size = true;
            data.displays.movement = true;
            data.displays.wounds = true;
            data.displays.critwounds = true;
            data.displays.corruption = true;
            data.displays.encumbrance = true;
            data.displays.hitloc = true;
            data.displays.equipPoints = true;
        }
        if (this.object.type == "npc")
        {
            data.displays.size = true;
            data.displays.movement = true;
            data.displays.wounds = true;
            data.displays.critwounds = true;
            data.displays.encumbrance = true;
            data.displays.hitloc = true;
            data.displays.equipPoints = true;
        }
        if (this.object.type == "creature")
        {
            data.displays.size = true;
            data.displays.movement = true;
            data.displays.wounds = true;
            data.displays.critwounds = true;
            data.displays.encumbrance = true;
            data.displays.hitloc = true;
            data.displays.equipPoints = true;
        }
        if (this.object.type == "vehicle")
        {
            data.displays.vehicle = true;
            data.displays.critwounds = true;
            data.displays.hitloc = true;
        }

        return data
    }


    async _updateObject(event, formData) {
        this.object.update(formData);
    }

  

}

class EffectScriptConfig extends ScriptConfig
{

    static get defaultOptions() 
    {
        const options = super.defaultOptions;
        options.classes.push("effect-script");
        return options;
    }

    async getData() 
    {
        let data = await super.getData();
        data.extraFieldsHTML = await this._renderExtraFields();
        return data;
    }

    _renderExtraFields()
    {
        return renderTemplate("systems/wfrp4e/templates/apps/script-fields.hbs", {script : this._getScriptObject(), effect : this.object});
    }

    _getScript()
    {
        return this._getScriptObject()?.script;
    }

    _getScriptObject()
    {
        return getProperty(this.object, "flags.wfrp4e.scriptData")?.[this.options.index];
    }

    async _updateObject(ev, formData)
    {
        let script = this.aceActive ? this.editor.getValue() : formData.script; 

        let array = foundry.utils.deepClone(getProperty(this.object, "flags.wfrp4e.scriptData"));
        let scriptObject = array[this.options.index];
        scriptObject.label = formData.label;
        scriptObject.trigger = formData.trigger;
        setProperty(scriptObject, "options.dialog.hideScript", formData.hideScript);
        setProperty(scriptObject, "options.dialog.activateScript", formData.activateScript);
        setProperty(scriptObject, "options.dialog.submissionScript", formData.submissionScript);
        setProperty(scriptObject, "options.dialog.targeter", formData.targeter);
        setProperty(scriptObject, "options.immediate.deleteEffect", formData.deleteEffect);
        scriptObject.script = script;

        return this.object.update({"flags.wfrp4e.scriptData" : array});
    }

    activateListeners(html)
    {
        super.activateListeners(html);

        this.hideTriggerOptions(html);

        html.find("[name='trigger']").change(ev => 
        {
            this.showTriggerOptions(ev.currentTarget.value);
        });

        this.showTriggerOptions(this._getScriptObject().trigger);
    }

    showTriggerOptions(trigger)
    {
        this.hideTriggerOptions(this.element);

        if (trigger)
        {
            this.element.find(`[data-option=${trigger}]`).show();
        }
        this.setTextboxHeight();
    }

    hideTriggerOptions(html)
    {
        html.find("[data-option]").hide();
    }
}

class WFRP4eActiveEffectConfig extends ActiveEffectConfig 
{
    static get defaultOptions() 
    {
        const options = super.defaultOptions;
        options.classes.push("wfrp4e");
        return options;
    }

    async _render(force, options)
    {
        await super._render(force, options);

        let scriptHTML = await renderTemplate("systems/wfrp4e/templates/apps/effect-scripts.hbs", {scripts : this.object.scriptData});
        let effectApplicationHTML = await renderTemplate("systems/wfrp4e/templates/apps/effect-application-config.hbs", this);

        // Add Scripts Tab and tab section
        this.element.find("nav").append(`<a class='item' data-tab="scripts"><i class="fas fa-gavel"></i>${game.i18n.localize("EFFECT.TabWFRP")}</a>`);
        $(`<section class='tab' data-tab="scripts">${scriptHTML}</section>`).insertBefore(this.element.find("footer"));

        // Replace transfer field with Effect Application data (used to derive transfer value)
        this.element.find("[name='transfer']").parents(".form-group").replaceWith(effectApplicationHTML);

        // // Replace attribute key field with a select field
        // let effectsTab = this.element.find("section[data-tab='effects']");

        // // Add a checkbox to toggle between <select> and <input> for effect keys
        // $(`<div class="form-group">
        // <label>${game.i18n.localize("ManualEffectKeys")}</label>
        // <input type="checkbox" class="manual-keys" name="flags.wfrp4e.manualEffectKeys" ${this.object.getFlag("wfrp4e", "manualEffectKeys") ? "checked" : ""}>
        // </div>`).insertBefore(effectsTab.find(".effects-header"));

        // // Replace all key inputs with <select> fields (unless disabled)
        // if (!this.object.getFlag("wfrp4e", "manualEffectKeys"))
        // {
        //     for (let element of effectsTab.find(".key input"))
        //     {
        //         $(element).replaceWith(await renderTemplate("systems/wfrp4e/templates/apps/effect-key-options.hbs", {name : element.name, value : element.value}));
        //     }
        // }

        // Activate Script tab if that is the cause of the rerender. It is added after rendering so won't be automatically handled by the Tabs object
        if (options.data?.flags?.wfrp4e?.scriptData)
        {
            this.activateTab("scripts");
        }
        this.element.css("height", "auto");
    }

    activateListeners(html)
    {
        super.activateListeners(html);

        html.on("click", ".add-script", () => 
        {
            let scripts = this.object.scriptData.concat({label : game.i18n.localize("SCRIPT.NewScript"), string : ""});
            return this.submit({preventClose: true, updateData: {
                [`flags.wfrp4e.scriptData`]: scripts
            }});
        });

        html.on("click", ".script-delete", ev => 
        {
            let index = this._getDataAttribute(ev, "index");
            let scripts = this.object.scriptData.filter((value, i) => i != index);
            return this.submit({preventClose: true, updateData: {
                [`flags.wfrp4e.scriptData`]: scripts
            }});
        });

        html.on("click", ".script-edit", ev => 
        {
            let index = this._getDataAttribute(ev, "index");
            new EffectScriptConfig(this.object, {index}).render(true);
        });

        html.on("click", ".script-config", ev => 
        {
            new ScriptConfig(this.object, {path : this._getDataAttribute(ev, "path")}).render(true);
        });

        html.on("change", ".wfrp4e-effect-config input,.wfrp4e-effect-config select", () => 
        {
            this.submit({preventClose: true});
        });

        html.on("change", ".manual-keys", () => 
        {
            this.submit({preventClose: true});
        });
    }

    _getIndex(ev) 
    {
        return Number(this._getDataAttribute(ev, "index"));
    }
  
    _getPath(ev) 
    {
        return this._getDataAttribute(ev, "path");
    }

  
    /**
     * Search for an HTML data property, specified as data-<property>
     * First search target of the event, then search in parent properties
     * 
     * @param {Event} ev Event triggered
     * @param {String} property data-<property> being searched for
     * @returns 
     */
    _getDataAttribute(ev, property)
    {
        let value = ev.target.dataset[property];
  
        if (!value) 
        {
            const parent = $(ev.target).parents(`[data-${property}]`);
            if (parent) 
            {
                value = parent[0]?.dataset[property];
            }
        }
        return value;
    }
  

}

class Migration {

  static async migrateWorld() {
    ui.notifications.info(`Applying WFRP4e System Migration for version ${game.system.version}. Please be patient and do not close your game or shut down your server.`, { permanent: true });


      let updates = [];
      // Migrate Journals
      for (let i of game.journal.contents) {
        try {
          let updateData = Migration.migrateJournalData(i);
          if (!foundry.utils.isEmpty(updateData) || updateData.pages.length > 0) {
            updates.push(updateData);
            console.log(`Migrating Journal document ${i.name}`);
          }
        } catch (err) {
          err.message = `Failed wfrp4e system migration for Journal ${i.name}: ${err.message}`;
          console.error(err);
        }
      }
      await JournalEntry.updateDocuments(updates);

      updates = [];
      // Migrate Tables
      for (let i of game.tables.contents) {
        try {
          let updateData = Migration.migrateTableData(i);
          if (!foundry.utils.isEmpty(updateData) || updateData.results.length > 0) {
            updates.push(updateData);
            console.log(`Migrating Table document ${i.name}`);
          }
        } catch (err) {
          err.message = `Failed wfrp4e system migration for RollTable ${i.name}: ${err.message}`;
          console.error(err);
        }
      }
      await RollTable.updateDocuments(updates);



    // Migrate World Items
    for (let i of game.items.contents) {
      try {
        let updateData = Migration.migrateItemData(i.toObject());
        if (!foundry.utils.isEmpty(updateData)) {
          console.log(`Migrating Item document ${i.name}`);
          await i.update(updateData, { enforceTypes: false });
        }
        let loreIds = this._loreEffectIds(i);
        if (loreIds.length)
        {
          await i.deleteEmbeddedDocuments("ActiveEffect", loreIds);
        }
      } catch (err) {
        err.message = `Failed wfrp4e system migration for Item ${i.name}: ${err.message}`;
        console.error(err);
      }
    }

    for (let p of game.packs) {
      if (p.metadata.type == "Item" && p.metadata.package == "world")
        await Migration.migrateCompendium(p);
    }
    for (let p of game.packs) {
      if (p.metadata.type == "Actor" && p.metadata.package == "world")
        await Migration.migrateCompendium(p);
    }
    for (let p of game.packs) {
      if (p.metadata.type == "Scene" && p.metadata.package == "world")
        await Migration.migrateCompendium(p);
    }

    // Migrate World Actors
    for (let a of game.actors.contents) {
      try {
        let updateData = Migration.migrateActorData(a);
        if (!foundry.utils.isEmpty(updateData)) {
          console.log(`Migrating Actor document ${a.name}`);
          await a.update(updateData, { enforceTypes: false });
        }
        let loreIds = this._loreEffectIds(a);
        if (loreIds.length)
        {
          await a.deleteEmbeddedDocuments("ActiveEffect", loreIds);
        }
      } catch (err) {
        err.message = `Failed wfrp4e system migration for Actor ${a.name}: ${err.message}`;
        console.error(err);
      }
    }

    // // Migrate Actor Override Tokens
    // for (let s of game.scenes.contents) {
    //   try {
    //     let updateData = Migration.migrateSceneData(s);
    //     if (!foundry.utils.isEmpty(updateData)) {
    //       console.log(`Migrating Scene document ${s.name}`);
    //       await s.update(updateData, { enforceTypes: false });
    //       // If we do not do this, then synthetic token actors remain in cache
    //       // with the un-updated actorData.
    //       s.tokens.contents.forEach(t => t._actor = null);
    //     }
    //   } catch (err) {
    //     err.message = `Failed wfrp4e system migration for Scene ${s.name}: ${err.message}`;
    //     console.error(err);
    //   }
    // }

    // // Set the migration as complete
    ui.notifications.info(`wfrp4e System Migration to version ${game.system.version} completed!`, { permanent: true });
  };

  /* -------------------------------------------- */

  /**
   * Apply migration rules to all Entities within a single Compendium pack
   * @param pack
   * @return {Promise}
   */
  static async migrateCompendium(pack) {
    const document = pack.metadata.document;
    if (!["Actor", "Item", "Scene"].includes(document)) return;

    // Unlock the pack for editing
    const wasLocked = pack.locked;
    await pack.configure({ locked: false });

    // Begin by requesting server-side data model migration and get the migrated content
    await pack.migrate();
    const documents = await pack.getDocuments();

    // Iterate over compendium entries - applying fine-tuned migration functions
    for (let doc of documents) {
      let updateData = {};
      try {
        switch (document) {
          case "Actor":
            updateData = Migration.migrateActorData(doc);
            break;
          case "Item":
            updateData = Migration.migrateItemData(doc);
            break;
          case "Scene":
            updateData = Migration.migrateSceneData(doc);
            break;
        }

        // Save the entry, if data was changed
        if (foundry.utils.isEmpty(updateData)) continue;
        await doc.update(updateData);
        console.log(`Migrated ${document} document ${doc.name} in Compendium ${pack.collection}`);
      }

      // Handle migration failures
      catch (err) {
        err.message = `Failed wfrp4e system migration for document ${doc.name} in pack ${pack.collection}: ${err.message}`;
        console.error(err);
      }
    }

    // Apply the original locked status for the pack
    await pack.configure({ locked: wasLocked });
    console.log(`Migrated all ${document} entities from Compendium ${pack.collection}`);
  };

  /* -------------------------------------------- */
  /*  Entity Type Migration Helpers               */
  /* -------------------------------------------- */

  /**
   * Migrate a single Actor entity to incorporate latest data model changes
   * Return an Object of updateData to be applied
   * @param {object} actor    The actor data object to update
   * @return {Object}         The updateData to apply
   */
  static migrateActorData(actor) {
    let updateData = {};

    // Migrate Owned Items
    if (actor.items) {
      const items = actor.items.reduce((arr, i) => {
        // Migrate the Owned Item
        let itemUpdate = Migration.migrateItemData(i);

        // Update the Owned Item
        if (!isEmpty(itemUpdate)) {
          itemUpdate._id = i.id;
          arr.push(expandObject(itemUpdate));
        }

        return arr;
      }, []);
      if (items.length > 0) updateData.items = items;
    }

    let html = this._migrateV10Links(actor.system.details.biography?.value);
    if (html != actor.system.details.biography?.value)
    {
      updateData["system.details.biography.value"] = html;
    }

    html = this._migrateV10Links(actor.system.details.gmnotes?.value);
    if (html != actor.system.details.gmnotes?.value)
    {
      updateData["system.details.gmnotes.value"] = html;
    }
    
    html = this._migrateV10Links(actor.system.details.description?.value);
    if (html != actor.system.details.description?.value)
    {
      updateData["system.details.description.value"] = html;
    }

    html = this._migrateV10Links(actor.system.details.gmdescription?.value);
    if (html != actor.system.details.gmdescription?.value)
    {
      updateData["system.details.gmdescription.value"] = html;
    }



    // Migrate Effects
    if (actor.effects) {
      const effects = actor.effects.reduce((arr, e) => {
        // Migrate the Owned Item
        let effectUpdate = Migration.migrateEffectData(e);

        // Update the Owned Item
        if (!isEmpty(effectUpdate)) {
          effectUpdate._id = e.id;
          arr.push(expandObject(effectUpdate));
        }

        return arr;
      }, []);
      if (effects.length > 0) updateData.effects = effects;
    }


    return updateData;
  };

  static migrateJournalData(journal)
  {
    let updateData = {_id : journal.id, pages : []};

    for(let page of journal.pages)
    {
      let html = page.text.content;
      console.log(`Checking Journal Page HTML ${journal.name}.${page.name}`);
      let newHTML = this._migrateV10Links(html);

      if (html != newHTML)
      {
        updateData.pages.push({_id : page.id, "text.content" : newHTML});
      }
    }
    return updateData;
  }

  static migrateTableData(table)
  {
    let updateData = {_id : table.id, results : []};

    for(let result of table.results)
    {
      if (result.type == 0)
      {
        let html = result.text;
        let newHTML = this._migrateV10Links(html);

        if (html != newHTML)
        {
          updateData.results.push({_id : result.id, text : newHTML});
        }
      }

      else if (result.type == 2 && this.v10Conversions[result.documentCollection])
      {
        updateData.results.push({_id : result.id, documentCollection : this.v10Conversions[result.documentCollection]});
      }
    }
    return updateData;
  }

  /**
 * Migrate a single Actor entity to incorporate latest data model changes
 * Return an Object of updateData to be applied
 * @param {object} actor    The actor data object to update
 * @return {Object}         The updateData to apply
 */
  static async migrateOwnedItemEffects(actor) {

    let itemsToRemove = [];

    let itemsToAdd = [];

    for (let item of actor.items) {
      if (item.getFlag("core", "sourceId")) {
        let source = item.getFlag("core", "sourceId");
        let newItem = item.toObject();
        let sourceItem = await fromUuid(source);
        if (sourceItem)
          sourceItem = sourceItem.toObject();

        if (sourceItem.name == item.name) {
          newItem.effects = sourceItem.effects;
          itemsToRemove.push(item.id);
          itemsToAdd.push(newItem);
        }
      }
    }

    await actor.deleteEmbeddedDocuments("Item", itemsToRemove);
    await actor.createEmbeddedDocuments("Item", itemsToAdd, { keepId: true });

    console.log(`Replaced Items ${itemsToAdd.map(i => i.name).join(", ")} for actor ${actor.name}`);
  };


  /* -------------------------------------------- */


  /**
   * Scrub an Actor's system data, removing all keys which are not explicitly defined in the system template
   * @param {Object} actorData    The data object for an Actor
   * @return {Object}             The scrubbed Actor data
   */
  static cleanActorData(actorData) {

    // Scrub system data
    const model = game.system.model.Actor[actorData.type];
    actorData.data = filterObject(actorData.data, model);

    // Scrub system flags
    const allowedFlags = CONFIG.wfrp4e.allowedActorFlags.reduce((obj, f) => {
      obj[f] = null;
      return obj;
    }, {});
    if (actorData.flags.wfrp4e) {
      actorData.flags.wfrp4e = filterObject(actorData.flags.wfrp4e, allowedFlags);
    }

    // Return the scrubbed data
    return actorData;
  }


/* -------------------------------------------- */

  /**
   * Migrate a single Item entity to incorporate latest data model changes
   *
   * @param {object} item  Item data to migrate
   * @return {object}      The updateData to apply
   */
   static migrateArmourData(item) {
    let updateData = {};

      mergeObject(updateData, this.migrateProperties(item));

    return updateData;
  };

     static migrateWeaponData(item) {
      let updateData = {};

      mergeObject(updateData, this.migrateProperties(item));
      return updateData;
    };

    static migrateAmmoData(item) {
      let updateData = {};

      mergeObject(updateData, this.migrateProperties(item));
      return updateData;
    };

    static migrateProperties(item)
    {
      let updateData = {};
      if (typeof item.system.qualities.value == "string")
      {
        let allQualities = WFRP_Utility$1.qualityList();
        updateData["system.qualities.value"] = item.system.qualities.value.split(",").map(i => i.trim()).map(i => {return {name : WFRP_Utility$1.findKey(i.split(" ")[0], allQualities), value : Number(i.split(" ")[1]) }}).filter(i => i.name);
      }
      if (typeof item.system.flaws.value == "string")
      {
        let allFlaws = WFRP_Utility$1.flawList();
        updateData["system.flaws.value"] = item.system.flaws.value.split(",").map(i => i.trim()).map(i => {return {name : WFRP_Utility$1.findKey(i.split(" ")[0], allFlaws), value : Number(i.split(" ")[1])}}).filter(i => i.name);
      }
      return updateData;
    }


  /**
   * Migrate a single Item entity to incorporate latest data model changes
   *
   * @param {object} item  Item data to migrate
   * @return {object}      The updateData to apply
   */
  static migrateItemData(item) {
    let updateData = {};

    if (item.type == "armour")
    {
      updateData = Migration.migrateArmourData(item);
    }

    if (item.type == "weapon")
    {
      updateData = Migration.migrateWeaponData(item);
    }

    if (item.type == "ammunition")
    {
      updateData = Migration.migrateAmmoData(item);
    }
    
    if (item.type == "spell")
    {
      if (typeof item.system.lore.effect == "string")
      {
        updateData["system.lore.effectString"] = item.system.lore.effect;
      }
    }

    
    let newDescription = this._migrateV10Links(item.system.description.value);
    let newGMDescription = this._migrateV10Links(item.system.gmdescription.value);

    if (item.system.description.value != newDescription)
    {
      updateData["system.description.value"] = newDescription;
    }

    if (item.system.gmdescription.value != newGMDescription)
    {
      updateData["system.gmdescription.value"] = newGMDescription;
    }

    // Migrate Effects
    if (item.effects) {
      const effects = item.effects.reduce((arr, e) => {

        let effectUpdate = Migration.migrateEffectData(e);

        // Update the Owned Item
        if (!isEmpty(effectUpdate)) {
          effectUpdate._id = e.id;
          arr.push(expandObject(effectUpdate));
        }

        return arr;
      }, []);
      if (effects.length > 0) updateData.effects = effects;
    }

    if (!isEmpty(updateData))
      console.log("Migration data for " + item.name, updateData);
    return updateData;
  };

  static removeLoreEffects(docData)
  {
    let loreEffects = (docData.effects || []).filter(i => i.flags.wfrp4e?.lore);
    if (loreEffects.length)
    {
      WFRP_Utility$1.log("Removing lore effects for " + docData.name, true, loreEffects);
      // return document.deleteEmbeddedDocuments("ActiveEffect", loreEffects.map(i => i.id));
    }
    return docData.effects?.filter(e => !loreEffects.find(le => le._id == e._id)) || [];
  }

  /* -------------------------------------------- */

  /**
   * Migrate a single Effect entity to incorporate latest data model changes
   *
   * @param {object} effect Effect data to migrate
   * @return {object}      The updateData to apply
   */
  static migrateEffectData(effect) {
    let updateData = {};
    Migration._migrateEffectScript(effect, updateData);
    if (!isEmpty(updateData))
      console.log("Migration data for " + effect.name, updateData);
    return updateData;
  };

  /* -------------------------------------------- */

  /**
   * Migrate a single Scene entity to incorporate changes to the data model of it's actor data overrides
   * Return an Object of updateData to be applied
   * @param {Object} scene  The Scene data to Update
   * @return {Object}       The updateData to apply
   */
  static migrateSceneData(scene) {
    const tokens = scene.tokens.map(token => {
      const t = token.toJSON();
      if (!t.actorId || t.actorLink) {
        t.actorData = {};
      }
      else if (!game.actors.has(t.actorId)) {
        t.actorId = null;
        t.actorData = {};
      }
      else if (!t.actorLink) {
        const actorData = duplicate(t.actorData);
        actorData.type = token.actor?.type;
        const update = Migration.migrateActorData(actorData);
        ['items', 'effects'].forEach(embeddedName => {
          if (!update[embeddedName]?.length) return;
          const updates = new Map(update[embeddedName].map(u => [u._id, u]));
          t.actorData[embeddedName].forEach(original => {
            const update = updates.get(original._id);
            if (update) mergeObject(original, update);
          });
          delete update[embeddedName];
        });

        mergeObject(t.actorData, update);
      }
      return t;
    });
    return { tokens };
  };

  /* -------------------------------------------- */
  /*  Low level migration utilities
  /* -------------------------------------------- */

  static _loreEffectIds(document)
  {
    return document.effects.filter(e => e.flags.wfrp4e?.lore).map(i => i.id)
  }

  static _migrateEffectScript(effect, updateData) {
    let script = effect.flags?.wfrp4e?.script;

    if (!script)
      return updateData


    script = script.replaceAll("actor.data.token", "actor.prototypeToken");
    script = script.replaceAll("actor.data", "actor");
    script = script.replaceAll("effect.label", "effect.name");
    script = this._migrateV10Links(script);


    if (script != effect.flags.wfrp4e.script)
      updateData["flags.wfrp4e.script"] = script;

    return updateData
  }
  
  static _migrateV10Links(html)
  {
    try 
    {
      if (!html) return 
      
      for(let key in this.v10Conversions)
      {
        let priorHTML = html;
        html = html.replaceAll(key, this.v10Conversions[key]);
        if (html != priorHTML)
        {
          console.log(`Replacing ${key} with ${this.v10Conversions[key]}`);
        }
      }
      return html;
    }
    catch (e)
    {
      console.error("Error replacing links: " + e);
    }
  }

  static v10Conversions = {
    "wfrp4e-core.journal-entries" : "wfrp4e-core.journals",
    "wfrp4e-core.maps" : "wfrp4e-core.scenes",
    "wfrp4e-core.bestiary" : "wfrp4e-core.actors",
    "wfrp4e-core.careers" : "wfrp4e-core.items",
    "wfrp4e-core.criticals" : "wfrp4e-core.items",
    "wfrp4e-core.skills" : "wfrp4e-core.items",
    "wfrp4e-core.talents" : "wfrp4e-core.items",
    "wfrp4e-core.traits" : "wfrp4e-core.items",
    "wfrp4e-core.psychologies" : "wfrp4e-core.items",
    "wfrp4e-core.mutations" : "wfrp4e-core.items",
    "wfrp4e-core.injuries" : "wfrp4e-core.items",
    "wfrp4e-core.diseases" : "wfrp4e-core.items",
    "wfrp4e-core.spells" : "wfrp4e-core.items",
    "wfrp4e-core.prayers" : "wfrp4e-core.items",
    "wfrp4e-core.trappings" : "wfrp4e-core.items",
    "wfrp4e-eis.mutations" : "wfrp4e-eis.items",
    "wfrp4e-eis.spells" : "wfrp4e-eis.items",
  }
}

class CareerSelector extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "career-selector";
        options.template = "systems/wfrp4e/templates/apps/career-selector.hbs";
        options.height = 800;
        options.width = 400;
        options.minimizable = true;
        options.title = "Career Selector";
        return options;
    }

    constructor(app) {
        super(app);
        this.careers = [];
        this.currentCareer = this.object.currentCareer;
        this.selectedCareer = -1;
    }

    async _render(...args) {
        await super._render(...args);
    }

    async getData() {
        let data = await super.getData();
        if (this.careers.length == 0)
        {
            await this.loadCareers();
        }

        data.careers = this.careers;
        data.careerList = {};

        if (this.careers.length) {
            data.careerList = this.sortCareers();
        }
        return data
    }

    async loadCareers() {
        this.careers = [];
        this.careers = await game.wfrp4e.utility.findAll("career", game.i18n.localize("CAREER.Loading"));
        this.careers = this.careers.sort((a, b) => a.careergroup.value > b.careergroup.value ? 1 : -1);
        this.careers = this.careers.filter(i => (i.compendium && !i.compendium.private) || i.ownership > 2);
    }

    sortCareers() {
        let careerList = {
            inClass: {},
            outOfClass: {},
        };
        if (!this.careers.length)
            return careerList

        this.careers.forEach((tier, i) => {
            try {

                let data = { link: tier.link, level: tier.level.value, img: tier.img, name: tier.name, index: i };
                let type = "outOfClass";
                if (this.currentCareer && this.currentCareer.class.value == tier.class.value)
                    type = "inClass";

                if (careerList[type][tier.careergroup.value]?.length) {
                    if (!careerList[type][tier.careergroup.value].find(i => i.name == tier.name)) // avoid duplicates
                        careerList[type][tier.careergroup.value].push(data);
                }
                else
                    careerList[type][tier.careergroup.value] = [data];
            }
            catch (e) {
                ui.notifications.error(`Error when displaying ${tier.name}: ${e}`);
            }
        });

        for (let career in careerList.inClass)
            careerList.inClass[career] = careerList.inClass[career].sort((a, b) => a.level > b.level ? 1 : -1);
        for (let career in careerList.outOfClass)
            careerList.outOfClass[career] = careerList.outOfClass[career].sort((a, b) => a.level > b.level ? 1 : -1);

        return careerList
    }

    async _updateObject(event, formData) {
        await this.object.createEmbeddedDocuments("Item", [this.selectedCareer.toObject()]);
        let experience = duplicate(this.object.details.experience);
        experience.spent += parseInt(formData.exp);
        experience.log = this.object._addToExpLog(formData.exp, `${game.i18n.format("LOG.CareerChange", { career: this.selectedCareer.name })}`, experience.spent, undefined);
        this.object.update({ "system.details.experience" : experience });
    }

    calculateMoveExp() {
        let exp = 0, reasons = [];
        if (!this.selectedCareer)
            return { exp }

        if (this.currentCareer)
        {
        exp += this.currentCareer.complete.value ? 100 : 200;

        reasons.push(this.currentCareer.complete.value ? game.i18n.localize("CAREER.LeaveComplete") : game.i18n.localize("CAREER.LeaveIncomplete"));




        if (this.selectedCareer.class.value != this.currentCareer.class.value) {
            exp += 100;
            reasons.push(game.i18n.localize("CAREER.DifferentClass"));
        }

        }
        else {
            exp += 100;
        }

        return { exp, tooltip: reasons.join(", ") }
    }

    activateListeners(html) {
        super.activateListeners(html);

        let input = html.find("input")[0];

        html.find(".career-tier").mousedown(ev => {
            if (ev.button == 0) {
                html.find(".career-tier.active").each(function () {
                    $(this).removeClass("active");
                });
                $(ev.currentTarget).toggleClass("active");
                this.selectedCareer = this.careers[Number($(ev.currentTarget).attr("data-index"))];
                let { exp, tooltip } = this.calculateMoveExp();
                input.value = exp;
                input.setAttribute("title", tooltip);
            }
            else if (ev.button == 2) {
                this.careers[Number($(ev.currentTarget).attr("data-index"))].sheet.render(true);
            }
        });
    }



}

class TagManager  {
  createTags()
  {
    this.tags = {};
    Array.from(game.packs.keys()).forEach(packKey => {
      this.tags[packKey] = this.findTagsFromIndex(game.packs.get(packKey).index);
    });
  }

  findTagsFromIndex(index)
  {
    let tags = [];
    index.forEach(i => {
      if (!tags.includes(i.type))
        tags.push(i.type);
    });
    return tags
  }

  getPacksWithTag(tags)
  {

    if (!tags || tags.length == 0)
      return Object.keys(this.tags).map(k => game.packs.get(k))

    if (!Array.isArray(tags))
      tags = [tags];
    
    let keys = [];

    for(let key in this.tags)
      if (this.tags[key].some(t => tags.includes(t)))
        keys.push(key);

    return keys.map(k => game.packs.get(k))
  }

}

class ItemProperties extends FormApplication {
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.id = "item-properties";
        options.template = "systems/wfrp4e/templates/apps/item-properties.hbs";
        options.height = "auto";
        options.width = 400;
        options.minimizable = true;
        options.title = "Item Properties";
        return options;
    }

    constructor(...args) {
        super(...args);
        if (this.object.type == "weapon" || this.object.type == "ammunition"  || (this.object.type == "trait" && this.object.system.rollable.value)) {
            this.qualities = foundry.utils.deepClone(game.wfrp4e.config.weaponQualities);
            this.flaws = foundry.utils.deepClone(game.wfrp4e.config.weaponFlaws);
        }
        else if (this.object.type == "armour" || (this.object.type == "trait" && !this.object.system.rollable.value)) {
            this.qualities = foundry.utils.deepClone(game.wfrp4e.config.armorQualities);
            this.flaws = foundry.utils.deepClone(game.wfrp4e.config.armorFlaws);
        }
        else if (this.object.type == "trapping")
        {
            this.qualities = {};
            this.flaws = {};
        }
        mergeObject(this.qualities, game.wfrp4e.config.itemQualities);
        mergeObject(this.flaws, game.wfrp4e.config.itemFlaws);
        if (this.object.type == "trait")
        {
            ui.notifications.warn(game.i18n.localize("PROPERTIES.TraitWarning"));
        }
    }

    getData() {
        let data = super.getData();

        data.qualities = Object.keys(this.qualities).map(i => {
            return {
                name: this.qualities[i],
                hasValue: game.wfrp4e.config.propertyHasValue[i],
                key: i,
                existing: this.object.originalProperties.qualities[i],
            }
        });

        data.flaws = Object.keys(this.flaws).map(i => {
            return {
                name: this.flaws[i],
                hasValue: game.wfrp4e.config.propertyHasValue[i],
                key: i,
                existing: this.object.originalProperties.flaws[i],
            }
        });

        data.customQualities = this.object.qualities.value.filter(i => i.custom).map(i => `${i.name} ${i.value ? "(" + i.value + ")" : ""}: ${i.description}`).join(" | ");
        data.customFlaws = this.object.flaws.value.filter(i => i.custom).map(i => `${i.name} ${i.value ? "(" + i.value + ")" : ""}: ${i.description}`).join(" | ");

        return data
    }


    async _updateObject(event, formData) {

        let qualities = [];
        let flaws = [];
        let groups = [];

        for (let prop in formData) {

            if (prop == "custom-quality")
                qualities = qualities.concat(this.parseCustomProperty(formData[prop]));
            else if (prop == "custom-flaw")
                flaws = flaws.concat(this.parseCustomProperty(formData[prop]));

            if (formData[prop] && !prop.includes("-value")) {
                let property = {
                    name: prop,
                    value: null
                };
                if (formData[`${prop}-value`]) {
                    let value = formData[`${prop}-value`];
                    if (Number.isNumeric(value))
                        value = parseInt(value);
                    property.value = value;
                }

                if (formData[`${prop}-group`]) 
                {
                    property.group = formData[`${prop}-group`];
                    groups.push(property.group);
                }

                if (this.qualities[prop])
                    qualities.push(property);
                else if (this.flaws[prop])
                    flaws.push(property);
            }
        }


        // Find the first quality for each group, arbitrarily set that to be the active
        // Hack or Impale or Defensive -> Hack is default active
        for(let groupNum of groups)
        {
            let first = qualities.find(q => q.group == groupNum);
            if (first) first.active = true;
        }

        WFRP_Utility$1.log("Updating Qualities/Flaws", false, formData, qualities, flaws);
        this.object.update({ "system.qualities.value": qualities, "system.flaws.value": flaws });
    }

    parseCustomProperty(string)
    {
        let regex = /(.+?)(\((.+?)\))*\s*:(.+?)(\||$)/gm;

        let matches = string.matchAll(regex);
        let traits = [];

        for (let match of matches)
        {
            traits.push({
                key : match[1].trim().slugify(),
                custom : true,
                value : match[3],
                name : match[1].trim(),
                display : (match[1].trim() + ` ${match[3] ? match[3] : ""}`).trim(),
                description : match[4].trim()
            });
        }

        return traits
    }


    activateListeners(html) {
        super.activateListeners(html);
        

        html.find(".property-input").change(ev => {
            let property = ev.target.classList[1];
            let checked = ev.target.value ? true : false;
            let element = $(ev.currentTarget).parents("form").find(`[name=${property}]`)[0];
            if (element)
                element.checked = checked;

        });
    }



}

class ModuleUpdater extends Dialog {

    constructor(module, html) 
    {

        super({
            title: `${game.i18n.localize("UpdaterTitle1")} ${module.title} ${game.i18n.localize("UpdaterTitle2")}`,
            content: html,
            module,
            buttons:
            {
              update:
              {
                label: game.i18n.localize("Update"),
                callback: html => {
                    if (!game.settings.get(module.id, "initialized"))
                        return ui.notifications.notify(game.i18n.localize("UPDATER.Error"))
                    let settings = this.getUpdateSettings(html);
                    this.updateImportedContent(settings);
                }
              }
            },
            default: "update"
          });
    }

    static async create(module)
    {
        let html = await renderTemplate("systems/wfrp4e/templates/apps/module-updater.hbs", module);

        return new this(module, html)
    }

    getUpdateSettings(html)
    {
        let updateSettings = {};
        updateSettings.actors = html.find('[name="actors"]').is(':checked');
        updateSettings.journals = html.find('[name="journals"]').is(':checked');
        updateSettings.items = html.find('[name="items"]').is(':checked');
        updateSettings.scenes = html.find('[name="scenes"]').is(':checked');
        updateSettings.tables = html.find('[name="tables"]').is(':checked');
        updateSettings.excludeNameChange = html.find('[name="excludeNameChange"]').is(':checked');
        return updateSettings
    }

    async updateImportedContent(settings)
    {
        let documents = await this.getDocuments();
        this.count = {created : 0, updated : 0};
        for(let type in settings)
        {
            if (type != "excludeNameChange" && settings[type])
                await this.updateDocuments(documents[type], settings);
        }
        ui.notifications.notify(`${game.i18n.format("UPDATER.Notification", { created: this.count.created,  updated: this.count.updated,  name: this.data.module.id, version: this.data.module.version })}`);

    }

    async updateDocuments(documents, settings)
    {
        if (!documents.length)
            return
        let toCreate = [];
        let toDelete = [];
        let documentClass;
        for (let document of documents)
        {
            if (document?.type == "character")
            {
                continue;
            }

            if (!documentClass)
                documentClass = CONFIG[document.documentName].documentClass;
            if (game[document.collectionName].has(document.id))
            {
                let existingDoc = game[document.collectionName].get(document.id);
                if (!settings.excludeNameChange || (settings.excludeNameChange && document.name == existingDoc.name))
                {
                    let folder = existingDoc.folder;
                    let ownership = existingDoc.ownership;
                    toDelete.push(existingDoc.id);
                    let newDoc = document.toObject();
                    newDoc.folder = folder;
                    newDoc.ownership = ownership;
                    toCreate.push(newDoc);
                    game.wfrp4e.utility.log(`Updated Document ${document.name}`);
                    this.count.updated++;
                }
            }
            else 
            {
                let folder = document.getFlag(this.data.module.id, "initialization-folder");
                folder = game.folders.getName(folder);
                let newDoc = document.toObject();
                if (folder)
                    newDoc.folder = folder.id;
                toCreate.push(newDoc);
                game.wfrp4e.utility.log(`Imported Document ${document.name}`);
                this.count.created++;
            }
        }
        await documentClass.deleteDocuments(toDelete);
        let created = await documentClass.createDocuments(toCreate);

        if (documentClass.name == "Scene")
        {
            created.forEach(async s => {
                let thumb = await s.createThumbnail();
                s.update({ "thumb": thumb.thumb });
            });
        }
    }

    async getDocuments()
    {
        let module = this.data.module;
        let packs = module.flags.initializationPacks.map(i => game.packs.get(i));
        let documents = {
            actors : [],
            journals : [],
            items : [],
            scenes : [],
            tables : [],
        };
        for (let pack of packs)
        {
            let docs = await pack.getDocuments();
            switch (pack.metadata.type)
            {
                case "Actor": documents.actors = documents.actors.concat(docs);
                    break;
                case "JournalEntry": documents.journals = documents.journals.concat(docs);
                    break;
                case "Item": documents.items = documents.items.concat(docs);
                    break;
                case "RollTable": documents.tables = documents.tables.concat(docs);
                    break;
                case "Scene": documents.scenes = documents.scenes.concat(docs);
                    break;
            }
        }
        return documents
    }
}

class ModuleInitializer extends Dialog {

    constructor(module, title, html) {
        super({
            title: title,
            content: html,
            module: game.modules.get(module),
            buttons: {
                initialize: {
                    label: "Initialize",
                    callback: async () => {
                        game.settings.set(module, "initialized", true);
                        await this.initialize();
                        ui.notifications.notify(game.modules.get(module).title + ": Initialization Complete");
                    }
                },
                update: {
                    label: "Update",
                    condition : game.settings.get(module, "initialized"),
                    callback: async () => {
                        let updater = await game.wfrp4e.apps.ModuleUpdater.create(game.modules.get(module), this);
                        updater.render(true);
                    }
                },
                delete : {
                    label: "Delete",
                    condition : game.settings.get(module, "initialized"),
                    callback: async () => {
                        this.deleteModuleContent(module);
                    }
                },
                no: {
                    label: "No",
                    callback: () => {
                        game.settings.set(module, "initialized", true);
                        ui.notifications.notify("Skipped Initialization.");
                    }
                }
            }
        });
    }

    rootFolders = {}

    async initialize() {

        let packList = this.data.module.flags.initializationPacks;

        for (let pack of packList.map(p => game.packs.get(p))) 
        {
            await this.createFolders(pack);
            let documents = await pack.getDocuments();
            try {
            switch (documents[0].documentName) {
                case "Actor":
                    ui.notifications.notify(this.data.module.title + ": Initializing Actors");
                    await this.createOrUpdateDocuments(documents, game.actors);
                    break;
                case "Item":
                    ui.notifications.notify(this.data.module.title + ": Initializing Items");
                    await this.createOrUpdateDocuments(documents, game.items);
                    break;
                case "JournalEntry":
                    ui.notifications.notify(this.data.module.title + ": Initializing Journals");
                    await this.createOrUpdateDocuments(documents, game.journal);
                    break;
                case "RollTable":
                    ui.notifications.notify(this.data.module.title + ": Initializing Tables");
                    await this.createOrUpdateDocuments(documents, game.tables);
                    break;
                case "Scene":
                    ui.notifications.notify(this.data.module.title + ": Initializing Scenes");
                    await this.createOrUpdateDocuments(documents, game.scenes);
                    break;
                }
            }
            catch(e)
            {
                console.error(e);
            }

        }
    }

    createFolders(pack)
    {
        let root = game.modules.get(pack.metadata.packageName).flags.folder;
        root.type = pack.metadata.type;
        root._id = randomID();
        let packFolders = pack.folders.contents.map(f => f.toObject());
        for(let f of packFolders)
        {
            if (!f.folder)
            {
                f.folder = root._id;
            }
        }
        this.rootFolders[pack.metadata.id] = root._id;
        return Folder.create(packFolders.concat(root), {keepId : true})
    }

    async createOrUpdateDocuments(documents, collection, )
    {
        let existingDocuments = documents.filter(i => collection.has(i.id));
        let newDocuments = documents.filter(i => !collection.has(i.id));
        await collection.documentClass.create(this._addFolder(newDocuments));
        if (existingDocuments.length)
        {
            game.wfrp4e.utility.log("Pre Existing Documents: ", null, {args : existingDocuments});
            existingDocuments = await new Promise(resolve => new ModuleDocumentResolver(existingDocuments, {resolve}).render(true));
            game.wfrp4e.utility.log("Post Existing Documents: ", null, {args : existingDocuments});
        }
        this._addFolder(existingDocuments);
        for (let doc of existingDocuments)
        {
            let existing = collection.get(doc.id);
            await existing.update(doc.toObject());
            ui.notifications.notify(`Updated existing document ${doc.name}`);
        }
    }

    _addFolder(documents)
    {
        return documents.map(d => {
            if (!d.folder)
            {
                d.updateSource({folder : this.rootFolders[d.pack]});
            }
            return d;
        })
    }

    async deleteModuleContent(id)
    {
        let proceed = await Dialog.confirm({
            title : game.i18n.localize("UPDATER.DeleteModuleContent"),
            content : game.i18n.format("UPDATER.DeleteModuleContentPrompt", {id}),
            yes : () => {return true},
            no : () => {return false},
        });
        if (proceed)
        {
            ui.notifications.notify(this.data.module.title + ": Deleting Scenes");
            let moduleScenes = game.scenes.filter(doc => doc.flags[id]);
            moduleScenes.forEach(doc => {
                doc.folder?.folder?.delete();
                doc.folder?.delete();});
            Scene.deleteDocuments(moduleScenes.map(doc => doc.id));

            ui.notifications.notify(this.data.module.title + ": Deleting Actors");
            let moduleActors = game.actors.filter(doc => doc.flags[id] && !doc.hasPlayerOwner);
            moduleActors.forEach(doc => {
                doc.folder?.folder?.delete();
                doc.folder?.delete();});
            Actor.deleteDocuments(moduleActors.map(doc => doc.id));

            ui.notifications.notify(this.data.module.title + ": Deleting Items");
            let moduleItems = game.items.filter(doc => doc.flags[id]);
            moduleItems.forEach(doc => {
                doc.folder?.folder?.delete();
                doc.folder?.delete();});
            Item.deleteDocuments(moduleItems.map(doc => doc.id));

            ui.notifications.notify(this.data.module.title + ": Deleting Journals");
            let moduleJournals = game.journal.filter(doc => doc.flags[id]);
            moduleJournals.forEach(doc => {
                doc.folder?.folder?.delete();
                doc.folder?.delete();});
            JournalEntry.deleteDocuments(moduleJournals.map(doc => doc.id));

            ui.notifications.notify(this.data.module.title + ": Deleting Tables");
            let moduleTables = game.tables.filter(doc => doc.flags[id]);
            moduleTables.forEach(doc => {
                doc.folder?.folder?.delete();
                doc.folder?.delete();});
            RollTable.deleteDocuments(moduleTables.map(doc => doc.id));
        }
    }
}


class ModuleDocumentResolver extends FormApplication
{
    static get defaultOptions() {
        const options = super.defaultOptions;
        options.resizable = true;
        options.height = 600;
        options.width = 400;
        options.template = "systems/wfrp4e/templates/apps/document-resolver.hbs";
        options.classes.push("document-resolver");
        options.title = game.i18n.localize("INIT.ResolveDuplicates");
        return options;
    }


    _updateObject(ev, formData)
    {   
        this.options.resolve(this.object.filter(i => formData[i.id]));
    }
}

class WFRPTableConfig extends RollTableConfig {

    static get defaultOptions() {
        return mergeObject(super.defaultOptions, {width: 725})
    }

    activateListeners(html) 
    {
        super.activateListeners(html);

        html.prepend($(`<div class="form-group">
            <label>${game.i18n.localize("TABLE.Key")}</label>
            <input type="text" name="flags.wfrp4e.key" value="${this.object.flags.wfrp4e?.key || ""}"/>
            <label>${game.i18n.localize("TABLE.Column")}</label>
            <input type="text" name="flags.wfrp4e.column" value="${this.object.flags.wfrp4e?.column || ""}"/>
        </div>`));
    }
}

class WFRPJournalTextPageSheet extends JournalTextPageSheet {

    async getData() {
        let data = await super.getData();
        data.headingLevels[4] = "Level 4";
        return data
    }
}


Hooks.on("init", () => {
    // Extend buildTOC to not include headers that have the `no-toc` class

    let buildTOC = JournalEntryPage.buildTOC;

    JournalEntryPage.buildTOC = function(html) {
        let toc = buildTOC.bind(this)(html);
        for(let slug in toc)
        {
            if (toc[slug].element.classList.contains("no-toc"))
                delete toc[slug];
        }
        return toc
    };

    
});

let fields$u = foundry.data.fields;

class CharacteristicsModel extends foundry.abstract.DataModel 
{
    static defineSchema() 
    {
        let schema = {};
        schema.ws = new fields$u.EmbeddedDataField(CharacteristicModel);
        schema.bs = new fields$u.EmbeddedDataField(CharacteristicModel);
        schema.s = new fields$u.EmbeddedDataField(CharacteristicModel);
        schema.t = new fields$u.EmbeddedDataField(CharacteristicModel);
        schema.i = new fields$u.EmbeddedDataField(CharacteristicModel);
        schema.ag = new fields$u.EmbeddedDataField(CharacteristicModel);
        schema.dex = new fields$u.EmbeddedDataField(CharacteristicModel);
        schema.int = new fields$u.EmbeddedDataField(CharacteristicModel);
        schema.wp = new fields$u.EmbeddedDataField(CharacteristicModel);
        schema.fel = new fields$u.EmbeddedDataField(CharacteristicModel);
        return schema;
    }


    compute() 
    {
        for(let ch in this)
        {
            this[ch].computeValue();
            this[ch].computeBonus();
            this[ch].computeCost();
        }
    }
}

class CharacteristicModel extends foundry.abstract.DataModel
{
    static defineSchema() 
    {
        let schema = {};
        schema.initial = new fields$u.NumberField({initial : 20});
        schema.modifier = new fields$u.NumberField({initial : 0});
        schema.advances = new fields$u.NumberField({initial : 0});
        schema.bonusMod = new fields$u.NumberField({initial : 0});
        schema.calculationBonusModifier = new fields$u.NumberField({initial : 0});
        return schema;
    }


    computeValue() 
    {
        this.value = this.initial + this.modifier + this.advances;
    }

    computeBonus() 
    {
        this.bonus = Math.floor(this.value / 10) + this.bonusMod;
    }

    computeCost()
    {
        this.cost = WFRP_Utility$1._calculateAdvCost(this.advances, "characteristic");
    }
}

let fields$t = foundry.data.fields;

class MountModel extends foundry.abstract.DataModel 
{
    static defineSchema() 
    {
        return {
            id : new fields$t.StringField({initial : ""}),
            mounted : new fields$t.BooleanField({initial : false}),
            isToken : new fields$t.BooleanField({initial : false}),
            tokenData : new fields$t.SchemaField({
                scene : new fields$t.StringField({initial : ""}),
                token : new fields$t.StringField({initial : ""})
            }),
        }
    }
}

let fields$s = foundry.data.fields;

class StandardStatusModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.advantage = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 })
        });

        schema.wounds = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 8, min : 0}),
            max: new fields$s.NumberField({initial: 8, min : 0}),
        });
        schema.criticalWounds = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 }),
            max: new fields$s.NumberField(),
        });
        schema.sin = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 })
        });

        schema.corruption = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 })
        });
        schema.roundsToPassOut = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 })
        });

        schema.encumbrance = new fields$s.SchemaField({
            current: new fields$s.NumberField({ initial: 0 }),
            max: new fields$s.NumberField({ initial: 0 }),
        });
        schema.mount = new fields$s.EmbeddedDataField(MountModel);
        return schema;
    }
}


class CharacterStatusModel extends StandardStatusModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.fortune = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 }),
        });
        schema.fate = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 }),
        });
        schema.resilience = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 }),
        });
        schema.resolve = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 }),
        });
        return schema;
    }
}


// DOES NOT INHERIT STANDARD
class VehicleStatusModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.wounds = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 }),
            max: new fields$s.NumberField(),
        });
        schema.criticalWounds = new fields$s.SchemaField({
            value: new fields$s.NumberField({ initial: 0 }),
            max: new fields$s.NumberField(),
        });


        schema.carries = new fields$s.SchemaField({
            current: new fields$s.NumberField({ initial: 0 }),
            max: new fields$s.NumberField({ initial: 10 }),
        });
        schema.encumbrance = new fields$s.SchemaField({
            current: new fields$s.NumberField({ initial: 0 }),
            initial: new fields$s.NumberField({ initial: 0 }),
        });
        return schema;
    }
}

let fields$r = foundry.data.fields;

class StandardDetailsModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.species = new fields$r.SchemaField({
            value: new fields$r.StringField(),
            subspecies: new fields$r.StringField(),
        });
        schema.gender = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.biography = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.gmnotes = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.size = new fields$r.SchemaField({
            value: new fields$r.StringField({ initial: "avg" })
        });
        schema.move = new fields$r.SchemaField({
            value: new fields$r.NumberField({ initial: 4 }),
        });
        schema.god = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.status = new fields$r.SchemaField({
            value: new fields$r.StringField(),
            standing: new fields$r.StringField(),
            tier: new fields$r.NumberField({ initial: 0 }),
            modifier: new fields$r.NumberField({ initial: 0 }),
        });
        schema.corruption = new fields$r.NumberField({ initial: 0 });
        schema.hitLocationTable = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        return schema;
    }
}


class CharacterDetailsModel extends StandardDetailsModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.experience = new fields$r.SchemaField({
            total: new fields$r.NumberField({ initial: 0 }),
            spent: new fields$r.NumberField({ initial: 0 }),
            log: new fields$r.ArrayField(new fields$r.ObjectField())
        });

        schema["personal-ambitions"] = new fields$r.SchemaField({
            "short-term": new fields$r.StringField(),
            "long-term": new fields$r.StringField()
        });
        schema["party-ambitions"] = new fields$r.SchemaField({
            "name": new fields$r.StringField(),
            "short-term": new fields$r.StringField(),
            "long-term": new fields$r.StringField()
        });
        schema.motivation = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.class = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.career = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.careerlevel = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.age = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.height = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.weight = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.haircolour = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.eyecolour = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.distinguishingmark = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.starsign = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        return schema;
    }
}

// DOES NOT INHERIT STANDARD
class VehicleDetailsModel extends foundry.abstract.DataModel {
    static defineSchema() {
        let schema = {};
        schema.vehicletype = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        schema.move = new fields$r.SchemaField({
            value: new fields$r.NumberField()
        });
        schema.length = new fields$r.SchemaField({
            value: new fields$r.NumberField()
        });
        schema.description = new fields$r.SchemaField({
            value: new fields$r.StringField({ initial: "" })
        });
        schema.gmdescription = new fields$r.SchemaField({
            value: new fields$r.NumberField({ initial: "" }),
        });
        schema.price = new fields$r.SchemaField({
            gc: new fields$r.NumberField()
        });
        schema.availability = new fields$r.SchemaField({
            value: new fields$r.StringField(),
        });
        schema.motivePower = new fields$r.SchemaField({
            value: new fields$r.StringField(),
        });
        schema.hitLocationTable = new fields$r.SchemaField({
            value: new fields$r.StringField()
        });
        return schema;
    }
}

foundry.data.fields;
/**
 * Abstract class that interfaces with the Actor class
 */
class BaseActorModel extends foundry.abstract.DataModel {

    static preventItemTypes = [];

    static defineSchema() {
        let schema = {};
        return schema;
    }

    preCreateData(data, options) {
        if (data._id)
            options.keepId = WFRP_Utility$1._keepID(data._id, this);

        let preCreateData = {};

        let defaultToken = game.settings.get("core", "defaultToken");

        // Set wounds, advantage, and display name visibility
        if (!data.prototypeToken)
            mergeObject(preCreateData,
                {
                    "prototypeToken.bar1": { "attribute": "status.wounds" },                  // Default Bar 1 to Wounds
                    "prototypeToken.bar2": { "attribute": "status.advantage" },               // Default Bar 2 to Advantage
                    "prototypeToken.displayName": defaultToken?.displayName || CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,    // Default display name to be on owner hover
                    "prototypeToken.displayBars": defaultToken?.displayBars || CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,    // Default display bars to be on owner hover
                    "prototypeToken.disposition": defaultToken?.disposition || CONST.TOKEN_DISPOSITIONS.HOSTILE,         // Default disposition to neutral
                    "prototypeToken.name": data.name,                                       // Set token name to actor name,
                    "prototypeToken.texture.src": "systems/wfrp4e/tokens/unknown.png"      // Set token image
                });


        // Set custom default token
        if (!data.img || data.img == "icons/svg/mystery-man.svg") {
            preCreateData.img = "systems/wfrp4e/tokens/unknown.png";
        }

        return preCreateData;
    }

    allowCreation() {
        return true;
    }

    initialize() {

    }

    async preUpdateChecks(data) {
        return data;
    }

    updateChecks() {
        this.checkSize();
        return {};
    }

    createChecks() { }

    itemIsAllowed(item) {
        if (this.constructor.preventItemTypes.includes(item.type)) {
            ui.notifications.error(game.i18n.localize("Error.ItemsNotAllowed"), { type: item.type });
            return false;
        }
        else {
            return true;
        }
    }

    computeBase() {
        this.initialize();
    }

    computeDerived() {
        // Abstract
    }

    computeItems()
    {
        
    }

    tokenSize() {
        return {}
    }

    // Resize tokens based on size property
    checkSize() {
        let actor = this.parent;
        if (game.user.id != WFRP_Utility$1.getActiveDocumentOwner(actor)?.id) {
            return
        }
        if (actor.flags.autoCalcSize && game.canvas.ready) {
            let tokenData = this.tokenSize();
            if (actor.isToken) {
                return actor.token.update(tokenData)
            }
            else if (canvas) {
                return actor.update({ prototypeToken: tokenData }).then(() => {
                    actor.getActiveTokens().forEach(t => t.document.update(tokenData));
                })
            }
        }
    }
}

let fields$q = foundry.data.fields;

/**
 * Represents actors that have characteristics and skills
 * Encompasses player characters and NPCs
 */
class StandardActorModel extends BaseActorModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.characteristics = new fields$q.EmbeddedDataField(CharacteristicsModel);
        schema.status = new fields$q.EmbeddedDataField(StandardStatusModel);
        schema.details = new fields$q.EmbeddedDataField(StandardDetailsModel);
        return schema;
    }


    preCreateData(data, options) {
        let preCreateData = super.preCreateData(data, options);
        // Default auto calculation to true
        mergeObject(preCreateData, {
            "flags.autoCalcRun": data.flags?.autoCalcRun || true,
            "flags.autoCalcWalk": data.flags?.autoCalcWalk || true,
            "flags.autoCalcWounds": data.flags?.autoCalcWounds || true,
            "flags.autoCalcCritW": data.flags?.autoCalcCritW || true,
            "flags.autoCalcCorruption": data.flags?.autoCalcCorruption || true,
            "flags.autoCalcEnc": data.flags?.autoCalcEnc || true,
            "flags.autoCalcSize": data.flags?.autoCalcSize || true,
            "prototypeToken.actorLink": true,
            "prototypeToken.disposition": CONST.TOKEN_DISPOSITIONS.HOSTILE,
            "prototypeToken.sight": { enabled: true }
        });
        mergeObject(preCreateData, this.checkWounds(true));
        return preCreateData;
    }

    async preUpdateChecks(data, options) {
        await super.preUpdateChecks(data, options);

        // Treat the custom default token as a true default token
        // If you change the actor image from the default token, it will automatically set the same image to be the token image
        if (this.prototypeToken?.texture?.src == "systems/wfrp4e/tokens/unknown.png" && updateData.img) {
            updateData["prototypeToken.texture.src"] = updateData.img;
        }

        await this._handleGroupAdvantage(data, options);
        this._handleWoundsUpdate(data, options);
        this._handleAdvantageUpdate(data, options);

    }

    updateChecks(data, options) {
        let update = super.updateChecks(data, options);

        if (options.deltaWounds) {
            this.parent._displayScrollingChange(options.deltaWounds > 0 ? "+" + options.deltaWounds : options.deltaWounds);
        }
        if (options.deltaAdv) ;

        // return mergeObject(update, this.checkWounds());
        return update;
    }

    
    computeItems()
    {
        for (let i of this.parent.items) {
            i.prepareOwnedData();
            
            if (i.location && i.location.value && i.type != "critical" && i.type != "injury") 
            ;
            else if (i.encumbrance && i.type != "vehicleMod")
            {
                this.status.encumbrance.current += Number(i.encumbrance.total);
            }
        }
    }

    computeBase() {
        super.computeBase();
        this.characteristics.compute();

        let flags = this.parent.flags;
        // TODO: Find alternative to this
        flags.meleeDamageIncrease = 0;
        flags.rangedDamageIncrease = 0;
        flags.robust = 0;
        flags.resolute = 0;
        flags.ambi = 0;

        this.parent.runScripts("prePrepareData", { actor: this });
    }

    computeDerived() {
        this.parent.runScripts("prePrepareItems", {actor : this});
        this.computeItems();
        super.computeDerived();
        // Recompute bonuses as active effects may have changed it
        this.characteristics.compute();
        if (this.checkWounds())
        {
            return;
        }
        this.computeAdvantage();
        this.computeMove();
        this.computeSize();
        this.computeEncumbranceMax();
        this.computeEncumbranceState();
        this.computeAP();
        this.computeMount();

        this.parent.runScripts("prepareData", { actor: this });
    }

    computeAdvantage() {
        if (!game.settings.get("wfrp4e", "useGroupAdvantage")) {
            if (game.settings.get("wfrp4e", "capAdvantageIB")) {
                this.status.advantage.max = this.characteristics.i.bonus;
                this.status.advantage.value = Math.clamped(this.status.advantage.value, 0, this.status.advantage.max);
            }
            else
                this.status.advantage.max = 10;
        }
    }


    computeMove() {
        let flags = this.parent.flags;
        // Auto calculation values - only calculate if user has not opted to enter ther own values
        if (flags.autoCalcWalk)
            this.details.move.walk = parseInt(this.details.move.value) * 2;

        if (flags.autoCalcRun)
            this.details.move.run = parseInt(this.details.move.value) * 4;

    }
    computeSize() {
        let items = this.parent.itemTypes;
        // Find size based on Traits/Talents
        let size;
        let trait = items.trait.find(i => i.name == game.i18n.localize("NAME.Size"));
        if (trait)
            size = WFRP_Utility$1.findKey(trait.specification.value, game.wfrp4e.config.actorSizes);
        if (!size) // Could not find specialization
        {
            let smallTalent = items.talent.find(i => i.name == game.i18n.localize("NAME.Small"));
            if (smallTalent)
                size = "sml";
            else
                size = "avg";
        }

        let args = { size };
        this.parent.runScripts("calculateSize", args);

        // If the size has been changed since the last known value, update the value 
        this.details.size.value = args.size || "avg";
    }

    computeEncumbranceMax() {
        let flags = this.parent.flags;
        if (flags.autoCalcEnc) {
            this.status.encumbrance.max = this.characteristics.t.bonus + this.characteristics.s.bonus;

            // I don't really like hardcoding this TODO: put this in Large effect script?
            if (this.details.species.value.toLowerCase() == game.i18n.localize("NAME.Ogre").toLowerCase()) {
                this.status.encumbrance.max *= 2;
            }
        }
    }

    computeEncumbranceState() {
        this.status.encumbrance.current = this.status.encumbrance.current;
        this.status.encumbrance.state = this.status.encumbrance.current / this.status.encumbrance.max;
    }


    computeAP() {
        const AP = {
            head: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Head"),
                show: true,
            },
            body: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Body"),
                show: true
            },
            rArm: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Left Arm"),
                show: true
            },
            lArm: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Right Arm"),
                show: true
            },
            rLeg: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Right Leg"),
                show: true

            },
            lLeg: {
                value: 0,
                layers: [],
                label: game.i18n.localize("Left Leg"),
                show: true
            },
            shield: 0,
            shieldDamage: 0
        };

        let args = { AP };
        this.parent.runScripts("preAPCalc", args);

        this.parent.getItemTypes("armour").filter(a => a.isEquipped).forEach(a => a.system._addAPLayer(AP));

        this.parent.getItemTypes("weapon").filter(i => i.properties.qualities.shield && i.isEquipped).forEach(i => {
            AP.shield += i.properties.qualities.shield.value - Math.max(0, i.damageToItem.shield - Number(i.properties.qualities.durable?.value || 0));
            AP.shieldDamage += i.damageToItem.shield;
        });

        this.parent.runScripts("APCalc", args);

        this.status.armour = AP;
    }


    /**
  * Calculates the wounds of an actor based on prepared items
  * 
  * Once all the item preparation is done (prepareItems()), we have a list of traits/talents to use that will
  * factor into Wonuds calculation. Namely: Hardy and Size traits. If we find these, they must be considered
  * in Wound calculation. 
  * 
  * @returns {Number} Max wound value calculated
  */
    computeWounds() {
        let flags = this.parent.flags;

        // Easy to reference bonuses
        let sb = this.characteristics.s.bonus + (this.characteristics.s.calculationBonusModifier || 0);
        let tb = this.characteristics.t.bonus + (this.characteristics.t.calculationBonusModifier || 0);
        let wpb = this.characteristics.wp.bonus + (this.characteristics.wp.calculationBonusModifier || 0);
        let multiplier = {
            sb: 0,
            tb: 0,
            wpb: 0,
        };

        if (flags.autoCalcCritW)
            this.status.criticalWounds.max = tb;

        let effectArgs = { sb, tb, wpb, multiplier, actor: this };
        this.parent.runScripts("preWoundCalc", effectArgs);
        ({ sb, tb, wpb } = effectArgs);

        let wounds = this.status.wounds.max;

        if (flags.autoCalcWounds) {
            switch (this.details.size.value) // Use the size to get the correct formula (size determined in prepare())
            {
                case "tiny":
                    wounds = 1 + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb;
                    break;

                case "ltl":
                    wounds = tb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb;
                    break;

                case "sml":
                    wounds = 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb;
                    break;

                case "avg":
                    wounds = sb + 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb;
                    break;

                case "lrg":
                    wounds = 2 * (sb + 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb);
                    break;

                case "enor":
                    wounds = 4 * (sb + 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb);
                    break;

                case "mnst":
                    wounds = 8 * (sb + 2 * tb + wpb + tb * multiplier.tb + sb * multiplier.sb + wpb * multiplier.wpb);
                    break;
            }
        }

        effectArgs = { wounds, actor: this };
        this.parent.runScripts("woundCalc", effectArgs);
        wounds = effectArgs.wounds;
        return wounds
    }

    checkWounds(force=false) {
        if (game.user.id != WFRP_Utility$1.getActiveDocumentOwner(this.parent)?.id) {
            return
        }
        if (this.parent.flags.autoCalcWounds || force) {
            let wounds = this.computeWounds();

            if (this.status.wounds.max != wounds) // If change detected, reassign max and current wounds
            {
                if (this.parent.compendium || !game.actors || !this.parent.inCollection) // Initial setup, don't send update
                {
                  this.status.wounds.max = wounds;
                  this.status.wounds.value = wounds;
                }
                else
                {
                    this.parent.update({ "system.status.wounds.max": wounds, "system.status.wounds.value": wounds });
                }
            }
        }
    }


    async _handleGroupAdvantage(data, options) {
        if (!options.skipGroupAdvantage && hasProperty(data, "system.status.advantage.value") && game.settings.get("wfrp4e", "useGroupAdvantage")) {
            let combatant = game.combat?.getCombatantByActor(this);

            if (!combatant) {
                ui.notifications.notify(game.i18n.localize("GroupAdvantageNoCombatant"));
            }
            // Don't send groupAdvantage updates if this update is from group advantage
            else if (!options.fromGroupAdvantage) {
                await WFRP_Utility$1.updateGroupAdvantage({ [`${this.parent.advantageGroup}`]: data.system.status.advantage.value });
            }
        }
    }

    _handleWoundsUpdate(data, options) {
        // Prevent wounds from exceeding max
        if (hasProperty(data, "system.status.wounds.value")) {
            if (data.system.status.wounds.value > (getProperty(data, "system.status.wounds.max") || this.status.wounds.max)) {
                data.system.status.wounds.value = this.status.wounds.max;
            }

            options.deltaWounds = data.system.status.wounds.value - this.status.wounds.value;
        }
    }

    _handleAdvantageUpdate(data, options) {
        if (hasProperty(data, "system.status.advantage.value")) 
        {
            let maxAdvantage;
            if (game.settings.get("wfrp4e", "capAdvantageIB"))
                maxAdvantage = this.characteristics.i.bonus;
            else
                maxAdvantage = 10;

            if (data.system.status.advantage.value > maxAdvantage) {
                data.system.status.advantage.value = this.status.advantage.max;
            }

            options.deltaAdv = data.system.status.advantage.value - this.status.advantage.value;
        }
    }

    tokenSize() {
        let tokenData = {};
        let tokenSize = game.wfrp4e.config.tokenSizes[this.details.size.value];
        if (tokenSize < 1) {
            tokenData.texture = { scaleX: tokenSize, scaleY: tokenSize };
            tokenData.width = 1;
            tokenData.height = 1;
        }
        else {
            tokenData.height = tokenSize;
            tokenData.width = tokenSize;
        }
        return tokenData;
    }

    computeMount() {
        let flags = this.parent.flags;

        if (this.isMounted && !game.actors) {
            game.wfrp4e.postReadyPrepare.push(this);
        }
        else if (this.isMounted && this.status.mount.isToken && !canvas) {
            game.wfrp4e.postReadyPrepare.push(this);
        }
        else if (this.isMounted) {
            let mount = this.mount;

            if (mount) {
                if (mount.status.wounds.value == 0)
                    this.status.mount.mounted = false;
                else {

                    this.details.move.value = mount.details.move.value;

                    if (flags.autoCalcWalk)
                        this.details.move.walk = mount.details.move.walk;

                    if (flags.autoCalcRun)
                        this.details.move.run = mount.details.move.run;
                }
            }
        }
    }

    get isMounted() {
        return this.status.mount.mounted && this.status.mount.id
    }

    get mount() {
        if (this.status.mount.isToken) {
            let scene = game.scenes.get(this.status.mount.tokenData.scene);
            if (canvas.scene.id != scene?.id)
                return ui.notifications.error(game.i18n.localize("ErrorTokenMount"))

            let token = canvas.tokens.get(this.status.mount.tokenData.token);

            if (token)
                return token.actor
        }
        let mount = game.actors.get(this.status.mount.id);
        return mount
    }
}

let fields$p = foundry.data.fields;

class CharacterModel extends StandardActorModel {
    static preventItemTypes = [];

    static defineSchema() {
        let schema = super.defineSchema();

        schema.characteristics = new fields$p.EmbeddedDataField(CharacteristicsModel);
        schema.status = new fields$p.EmbeddedDataField(CharacterStatusModel);
        schema.details = new fields$p.EmbeddedDataField(CharacterDetailsModel);

        return schema;
    }

    preCreateData(data, options) {
        let preCreateData = super.preCreateData(data, options);
        mergeObject(preCreateData, {
            "prototypeToken.sight": { enabled: true },
            "prototypeToken.actorLink": true,
            "prototypeToken.disposition": CONST.TOKEN_DISPOSITIONS.FRIENDLY
        });
        return preCreateData;
    }


    async preUpdateChecks(data, options) {
        await super.preUpdateChecks(data, options);

        this._handleExperienceChange(data, options);
    }

    updateChecks(data, options) {
        let update = super.updateChecks(data, options);
        return update;
        // this._checkEncumbranceEffects(this.parent);
    }

    computeBase() {
        super.computeBase();
    }


    computeDerived(items, flags) {
        super.computeDerived(items, flags);

        this.computeCorruption(items, flags);
        this.computeCareer(items, flags);

        this.details.experience.current = this.details.experience.total - this.details.experience.spent;
    }

    computeCorruption()
    {
        let flags = this.parent.flags;
        let tb = this.characteristics.t.bonus;
        let wpb = this.characteristics.wp.bonus;
    
        // If the user has not opted out of auto calculation of corruption, add pure soul value
        if (flags.autoCalcCorruption) {
          this.status.corruption.max = tb + wpb;
        }
    }

    computeCareer()
    {
        let currentCareer = this.currentCareer;
        if (currentCareer) {
          let { standing, tier } = this._applyStatusModifier(currentCareer.status);
          this.details.status.standing = standing;
          this.details.status.tier = tier;
          this.details.status.value = game.wfrp4e.config.statusTiers[this.details.status.tier] + " " + this.details.status.standing;
        }
        else
          this.details.status.value = "";
    
        if (currentCareer) {
          let availableCharacteristics = currentCareer.characteristics;
          for (let char in this.characteristics) {
            if (availableCharacteristics.includes(char))
              this.characteristics[char].career = true;
          }
        }
    }

    get currentCareer() 
    {
        return this.parent.getItemTypes("career").find(c => c.current.value)
    }

    _handleExperienceChange(data) {
        if (hasProperty(data, "system.details.experience") && !hasProperty(data, "system.details.experience.log")) {
            let actorData = this.parent.toObject(); // duplicate so we have old data during callback
            new Dialog({
                content: `<p>${game.i18n.localize("ExpChangeHint")}</p><div class="form-group"><input name="reason" type="text" /></div>`,
                title: game.i18n.localize("ExpChange"),
                buttons: {
                    confirm: {
                        label: game.i18n.localize("Confirm"),
                        callback: (dlg) => { }
                    }
                },
                default: "confirm",
                close: dlg => {
                    let expLog = actorData.system.details.experience.log || [];
                    let newEntry = { reason: dlg.find('[name="reason"]').val() };
                    if (hasProperty(data, "system.details.experience.spent")) {
                        newEntry.amount = data.system.details.experience.spent - actorData.system.details.experience.spent;
                        newEntry.spent = data.system.details.experience.spent;
                        newEntry.total = actorData.system.details.experience.total;
                        newEntry.type = "spent";
                    }
                    if (hasProperty(data, "system.details.experience.total")) {
                        newEntry.amount = data.system.details.experience.total - actorData.system.details.experience.total;
                        newEntry.spent = actorData.system.details.experience.spent;
                        newEntry.total = data.system.details.experience.total;
                        newEntry.type = "total";
                    }

                    expLog.push(newEntry);
                    this.parent.update({ "system.details.experience.log": expLog });
                }
            }).render(true);
        }
    }

    _applyStatusModifier({ standing, tier }) {
        let modifier = this.details.status.modifier || 0;
    
        if (modifier < 0)
          this.details.status.modified = "negative";
        else if (modifier > 0)
          this.details.status.modified = "positive";
    
        let temp = standing;
        standing += modifier;
        modifier = -(Math.abs(temp));
    
        if (standing <= 0 && tier != "b") {
          standing = 5 + standing;
          if (tier == "g")
            tier = "s";
          else if (tier == "s")
            tier = "b";
    
          // If modifier is enough to subtract 2 whole tiers
          if (standing <= 0 && tier != "b") {
            standing = 5 + standing;
            tier = "b"; // only possible case here
          }
    
          if (standing < 0)
            standing = 0;
        }
        // If rock bottom
        else if (standing <= 0 && tier == "b") {
          standing = 0;
        }
        else if (standing > 5 && tier != "g") {
          standing = standing - 5;
          if (tier == "s")
            tier = "g";
          else if (tier == "b")
            tier = "s";
    
          // If modifier is enough to get you 2 whole tiers
          if (standing > 5 && tier != "g") {
            standing -= 5;
            tier = "g"; // Only possible case here
          }
        }
        return { standing, tier }
      }
}

let fields$o = foundry.data.fields;

class VehicleModel extends BaseActorModel {
    static preventItemTypes = [];

    static defineSchema() {
        let schema = super.defineSchema();
        schema.characteristics = new fields$o.SchemaField({
            t: new fields$o.EmbeddedDataField(CharacteristicModel)
        });
        schema.status = new fields$o.EmbeddedDataField(VehicleStatusModel);
        schema.details = new fields$o.EmbeddedDataField(VehicleDetailsModel);
        schema.passengers = new fields$o.ArrayField(new fields$o.ObjectField());
        schema.roles = new fields$o.ArrayField(new fields$o.ObjectField());
        return schema;
    }

    preCreateData(data, options) {

        let preCreateData = super.preCreateData(data, options);
        // Set custom default token
        if (!data.img || data.img == "icons/svg/mystery-man.svg") {
            preCreateData.img = "systems/wfrp4e/tokens/vehicle.png";
        }

        return preCreateData;
    }

    computeDerived(items) {
        super.computeDerived(items);
        this.computeEncumbranceMax(items, flags);
    }


    computeEncumbrance() {
        if (!game.actors) // game.actors does not exist at startup, use existing data
            game.wfrp4e.postReadyPrepare.push(this);
        else {
            if (getProperty(this, "flags.actorEnc"))
                for (let passenger of this.passengers)
                    this.status.encumbrance.current += passenger.enc;
        }


        this.status.encumbrance.current = Math.floor(this.status.encumbrance.current * 10) / 10;
        this.status.encumbrance.mods = this.parent.getItemTypes("vehicleMod").reduce((prev, current) => prev + current.encumbrance.value, 0);
        this.status.encumbrance.over = this.status.encumbrance.mods - this.status.encumbrance.initial;
        this.status.encumbrance.over = this.status.encumbrance.over < 0 ? 0 : this.status.encumbrance.over;

        this.status.encumbrance.max = this.status.carries.max;
        this.status.encumbrance.pct = this.status.encumbrance.over / this.status.encumbrance.max * 100;
        this.status.encumbrance.carryPct = this.status.encumbrance.current / this.status.carries.max * 100;
        if (this.status.encumbrance.pct + this.status.encumbrance.carryPct > 100) {
            this.status.encumbrance.penalty = Math.floor(((this.status.encumbrance.carryPct + this.status.encumbrance.pct) - 100) / 10); // Used in handling tests
        }

    }
}

foundry.data.fields;

class NPCModel extends StandardActorModel 
{
    static preventItemTypes = [];

    static defineSchema() 
    {
        let schema = super.defineSchema();
        return schema;
    }
}

let fields$n = foundry.data.fields;

class CreatureModel extends StandardActorModel 
{
    static preventItemTypes = [];

    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.excludedTraits = new fields$n.ArrayField(new fields$n.StringField());
        return schema;
    }
}

let fields$m = foundry.data.fields;

 class BaseItemModel extends foundry.abstract.DataModel 
 {
 
    //  allowedConditions = [];  // What condition effects can exist on the item
    //  allowedEffectApplications = Object.keys(game.wfrp4e.config.effectApplications);
    //  effectApplicationOptions = {};
 
 
     get id () 
     {
         return this.parent.id;
     }
 
     static defineSchema() 
     {
        return {
            description : new fields$m.SchemaField({
                value: new fields$m.StringField()
            }),
            gmdescription : new fields$m.SchemaField({
                value: new fields$m.StringField()
            }),
        } 
     }
 
     allowCreation()
     {
         if (this.parent.actor)
         {
             return this.parent.actor.system.itemIsAllowed(this.parent);
         }
         else 
         {
             return true;
         }
     }
 

     // *** Creation ***
     async preCreateData(data, options, user)
     {
        let preCreateData = {};
        if (!data.img || data.img == "icons/svg/item-bag.svg")
            preCreateData.img = "systems/wfrp4e/icons/blank.png";

        return preCreateData;
     }

     createChecks()
     {
         
     }

     // *** Updates *** 
     async preUpdateChecks(data)
     {
         return data;
     }
 
     updateChecks()
     {
        
     }


     // *** Deletions ***
     async preDeleteChecks()
     {

     }

     async deleteChecks() 
     {

     }




 
    /**
      * @abstract
      */
     computeBase() 
     {

     }
 
    /**
      * @abstract
      */
     computeDerived() 
     {

     }

     /**
      * @abstract
      */
     computeOwned()
     {
     }

     getOtherEffects()
     {
         return [];
     }

    get skillToUse() {
        return this.getSkillToUse(this.parent.actor)
    }

  /**
   * Sometimes a weapon isn't being used by its owning actor (namely: vehicles)
   * So the simple getter BaseItemModel#skillToUse isn't sufficient, we need to provide
   * an actor to use their skills instead
   * 
   * @abstract
   * @param {Object} actor Actor whose skills are being used
   */
    getSkillToUse(actor)
    {
        
    }


    async expandData(htmlOptions) {
        htmlOptions.async = true;
        const data = this.parent.toObject().system;
        data.properties = [];
        data.description.value = data.description.value || "";
        data.description.value = await TextEditor.enrichHTML(data.description.value, htmlOptions);
        data.targetEffects = this.parent.effects.filter(e => e.application == "target");
        data.invokeEffects = this.parent.effects.filter(e => e.trigger == "manual");
        return data;
      }

    /**
     * @abstract
     */
    chatData()
    {
        
    }
 
    //  computeOwnerDerived() 
    //  {
         
    //  }
 
    //  computeOwnerBase() 
    //  {

    //  }
 
     /**
      * 
      */
    //  effectIsApplicable(effect)
    //  {
    //      return !effect.disabled;
    //  }
 
     // If an item effect is disabled it should still transfer to the actor, so that it's visibly disabled
     shouldTransferEffect(effect)
     {
         return true;
     }
 
 }

let fields$l = foundry.data.fields;

class PhysicalItemModel extends BaseItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.quantity = new fields$l.SchemaField({
            value: new fields$l.NumberField({initial: 1, min : 0})
        });
        schema.encumbrance = new fields$l.SchemaField({
            value: new fields$l.NumberField()
        });
        schema.price = new fields$l.SchemaField({
            gc: new fields$l.NumberField(),
            ss: new fields$l.NumberField(),
            bp: new fields$l.NumberField()
        });
        schema.availability = new fields$l.SchemaField({
            value: new fields$l.StringField()
        });
        schema.location = new fields$l.SchemaField({
            value: new fields$l.StringField()
        });
        schema.damageToItem = new fields$l.SchemaField({
            value: new fields$l.NumberField(),
            shield: new fields$l.NumberField(),
        });
        return schema;
    }

    async preCreateData(data, options, user)
    {
       let preCreateData = await super.preCreateData(data, options, user);

       // Previously this checked if item was still owned, not sure if that's necessary 
       // It seems that every case where a new item is created, it should clear the location
       setProperty(preCreateData, "system.location.value",  "");

       return preCreateData;
    }

    computeBase() 
    {
        this.encumbrance.total = 0;
        super.computeBase();

        this.encumbrance.total = this.computeEncumbrance();
    }

    computeEncumbrance() 
    {
        let enc = 0;
        if (this.encumbrance && this.quantity) 
        {
            enc = (this.encumbrance.value * this.quantity.value);
            if (this.encumbrance.value % 1 != 0)
            {
                enc = enc.toFixed(2);
            }

            if (this.isEquipped) 
            {
                enc = Math.max(0, enc - 1);
            }
        }
        return enc
    }
}

let fields$k = foundry.data.fields;

var PropertiesMixin$1 = PropertiesMixin = (cls) => class extends cls 
{
    static defineSchema() {
        let schema = super.defineSchema();
        schema.qualities = new fields$k.SchemaField({
            value: new fields$k.ArrayField(new fields$k.ObjectField({}))
        });
        schema.flaws = new fields$k.SchemaField({
            value: new fields$k.ArrayField(new fields$k.ObjectField({}))
        });
        return schema;
    }

    //#region getters

    get loading() {
        return this.flaws.reload
    }

    get repeater() {
        return this.qualities.repeater
    }

    get properties() {

        if (this._properties)
        {
            return this._properties;
        }

        else return {
            qualities: this.constructor._propertyArrayToObject(this.qualities.value, game.wfrp4e.utility.qualityList()),
            flaws: this.constructor._propertyArrayToObject(this.flaws.value, game.wfrp4e.utility.flawList()),
        }
    }

    get originalProperties() {
        let properties = {
            qualities: this.constructor._propertyArrayToObject(this._source.qualities.value, game.wfrp4e.utility.qualityList()),
            flaws: this.constructor._propertyArrayToObject(this._source.flaws.value, game.wfrp4e.utility.flawList()),
            unusedQualities: {}
        };
        return properties;
    }

    get OriginalQualities() {
        let qualities = Object.values(this.originalProperties.qualities);
        let ungrouped = qualities.filter(i => !i.group).map(q => q.display);
        let grouped = [];
        let groupNums = this.QualityGroups;
        for (let g of groupNums) {
            grouped.push(qualities.filter(i => i.group == g).map(i => i.display).join(" " + game.i18n.localize("QualitiesOr") + " "));
        }
        return ungrouped.concat(grouped)
    }

    get OriginalFlaws() {
        return Object.values(this.originalProperties.flaws).map(f => f.display)
    }


    // Related to OR qualities - can choose which one is active
    get QualityGroups() {
        // return groups with no duplicates
        return Object.values(this.originalProperties.qualities)
            .map(i => i.group)
            .filter(i => Number.isNumeric(i))
            .filter((value, index, array) => {
                return array.findIndex(i => value == i) == index
            });
    }

    get Qualities() {
        return Object.values(this.properties.qualities).map(q => q.display)
    }

    get UnusedQualities() {
        return Object.values(this.properties.unusedQualities).map(q => q.display)
    }

    get InactiveQualities() {
        return Object.values(this.properties.inactiveQualities).map(q => q.display)
    }

    get Flaws() {
        return Object.values(this.properties.flaws).map(f => f.display)
    }

    //#endregion

    computeBase() {
        this._properties = null;
        super.computeBase();
    }

    computeEncumbrance() 
    {
        let enc = super.computeEncumbrance();

        if (this.properties.qualities?.lightweight && enc >= 1)
            enc -= 1 * this.quantity.value;
        if (this.properties.flaws?.bulky)
            enc += 1 * this.quantity.value;

        return enc
    }

    /**
   * 
   * @param {Object} properties properties object to add
   */
    _addProperties(properties) {
        let qualities = this.qualities.value;
        let flaws = this.flaws.value;

        for (let q in properties.qualities) {
            let hasQuality = qualities.find(quality => quality.name == q);
            if (hasQuality && properties.qualities[q].value) {
                hasQuality.value += properties.qualities[q].value;
            }
            else
                qualities.push({ name: q, value: properties.qualities[q].value });
        }
        for (let f in properties.flaws) {
            let hasQuality = flaws.find(flaw => flaw.name == f);
            if (hasQuality && properties.flaws[f].value) {
                hasQuality.value += properties.flaws[f].value;
            }
            else
                flaws.push({ name: f, value: properties.flaws[f].value });
        }
    }

    static _propertyArrayToObject(array, propertyObject) {

        let properties = {};

        // Convert quality/flaw arry into an properties object (accessible example `item.properties.qualities.accurate` or `item.properties.flaws.reload.value)
        if (array) {
            array.forEach(p => {
                if (propertyObject[p.name]) {
                    properties[p.name] = {
                        key: p.name,
                        display: propertyObject[p.name],
                        value: p.value,
                        group: p.group,
                        active: p.active
                    };
                    if (p.value)
                        properties[p.name].display += " " + (Number.isNumeric(p.value) ? p.value : `(${p.value})`);

                }
                else if (p.custom) {
                    properties[p.key] = {
                        key: p.key,
                        display: p.display
                    };
                }
                // Unrecognized
                else properties[p.name] = {
                    key: p.name,
                    display: p.name
                };
            });
        }

        return properties
    }
};

let fields$j = foundry.data.fields;

class AmmunitionModel extends PropertiesMixin$1(PhysicalItemModel)
{
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.ammunitionType = new fields$j.SchemaField({
            value: new fields$j.StringField()
        });
        schema.range = new fields$j.SchemaField({
            value: new fields$j.StringField()
        });
        schema.damage = new fields$j.SchemaField({
            value: new fields$j.StringField()
        });
        schema.ammunitionType = new fields$j.SchemaField({
            value: new fields$j.StringField()
        });
        schema.special = new fields$j.SchemaField({
            value: new fields$j.StringField()
        });
        return schema;
    }

      // Ammunition Expansion Data
  async expandData(htmlOptions) {
    let data = await super.expandData(htmlOptions);
    let properties = [];
    properties.push(game.wfrp4e.config.ammunitionGroups[this.ammunitionType.value]);

    if (this.range.value)
      properties.push(`${game.i18n.localize("Range")}: ${this.range.value}`);

    if (this.damage.value) {
      let damage = this.damage.value;
      if (this.damage.dice)
        damage += " + " + this.damage.dice;
      properties.push(`${game.i18n.localize("Damage")}: ${damage}`);
    }

    let itemProperties = this.Qualities.concat(this.Flaws);
    for (let prop of itemProperties)
      properties.push("<a class ='item-property'>" + prop + "</a>");

    if (this.special.value)
      properties.push(`${game.i18n.localize("Special")}: ` + this.special.value);

    data.properties = properties.filter(p => !!p);
    return data;
  }

  chatData() {
    let properties = [
      `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
      `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
      `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
    ];

    properties.push(`<b>${game.i18n.localize("ITEM.AmmunitionType")}:</b> ${game.wfrp4e.config.ammunitionGroups[this.ammunitionType.value]}`);

    if (this.range.value)
      properties.push(`<b>${game.i18n.localize("Range")}</b>: ${this.range.value}`);

    if (this.damage.value)
      properties.push(`<b>${game.i18n.localize("Damage")}</b>: ${this.damage.value}`);

    // Make qualities and flaws clickable
    if (this.qualities.value.length)
      properties.push(`<b>${game.i18n.localize("Qualities")}</b>: ${this.OriginalQualities.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);

    if (this.flaws.value.length)
      properties.push(`<b>${game.i18n.localize("Flaws")}</b>: ${this.OriginalFlaws.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);


    properties = properties.filter(p => p != game.i18n.localize("Special"));
    if (this.special.value)
      properties.push(`<b>${game.i18n.localize("Special")}</b>: ` + this.special.value);

    properties = properties.filter(p => !!p);
    return properties;
  }
}

let fields$i = foundry.data.fields;

class ArmourModel extends PropertiesMixin$1(PhysicalItemModel) {
  static defineSchema() {
    let schema = super.defineSchema();
    schema.worn = new fields$i.SchemaField({
      value: new fields$i.BooleanField()
    });
    schema.armorType = new fields$i.SchemaField({ // TODO migrate this to the "correct" spelling
      value: new fields$i.StringField()
    });
    schema.penalty = new fields$i.SchemaField({
      value: new fields$i.StringField()
    });
    schema.special = new fields$i.SchemaField({
      value: new fields$i.StringField()
    });

    schema.AP = new fields$i.SchemaField({
      head: new fields$i.NumberField({ initial: 0 }),
      lArm: new fields$i.NumberField({ initial: 0 }),
      rArm: new fields$i.NumberField({ initial: 0 }),
      lLeg: new fields$i.NumberField({ initial: 0 }),
      rLeg: new fields$i.NumberField({ initial: 0 }),
      body: new fields$i.NumberField({ initial: 0 }),
    });
    schema.APdamage = new fields$i.SchemaField({
      head: new fields$i.NumberField({ initial: 0 }),
      lArm: new fields$i.NumberField({ initial: 0 }),
      rArm: new fields$i.NumberField({ initial: 0 }),
      lLeg: new fields$i.NumberField({ initial: 0 }),
      rLeg: new fields$i.NumberField({ initial: 0 }),
      body: new fields$i.NumberField({ initial: 0 }),
    });
    return schema;
  }

  get isEquipped() {
    return this.worn.value
  }

  get protects() {
    let protects = {};
    for (let loc in this.AP) {
      if (this.AP[loc] > 0)
        protects[loc] = true;
      else
        protects[loc] = false;
    }
    return protects
  }

  get currentAP() {
    let currentAP = foundry.utils.deepClone(this.AP);
    for (let loc in currentAP) {
        currentAP[loc] -= this.properties.qualities.durable  // If durable, subtract its value from APDamage
                          ? Math.max(0, (this.APdamage[loc] - (this.properties.qualities.durable?.value || 0)))
                          : this.APdamage[loc];
    }
    return currentAP
  }

  async preCreateData(data, options, user) {
    let preCreateData = await super.preCreateData(data, options, user);

    if (this.parent.isOwned && this.parent.actor.type != "character" && this.parent.actor.type != "vehicle") {
      setProperty({ preCreateData, "system.worn.value": true }); // TODO: migrate this into a unified equipped property 
    }

    return preCreateData;
  }

  computeBase() {
    super.computeBase();
    this.damaged = {
      "head": false,
      "lArm": false,
      "rArm": false,
      "lLeg": false,
      "rLeg": false,
      "body": false
    };
  }

  shouldTransferEffect(effect)
  {
      return super.shouldTransferEffect(effect) && (!effect.applicationData.equipTransfer || this.isEquipped)
  }

  _addAPLayer(AP) {
    // If the armor protects a certain location, add the AP value of the armor to the AP object's location value
    // Then pass it to addLayer to parse out important information about the armor layer, namely qualities/flaws
    for (let loc in this.currentAP) {
      if (this.currentAP[loc] > 0) {

        AP[loc].value += this.currentAP[loc];

        let layer = {
          value: this.currentAP[loc],
          armourType: this.armorType.value // used for sound
        };

        let properties = this.properties;
        layer.impenetrable = !!properties.qualities.impenetrable;
        layer.partial = !!properties.flaws.partial;
        layer.weakpoints = !!properties.flaws.weakpoints;

        if (this.armorType.value == "plate" || this.armorType.value == "mail")
          layer.metal = true;

        AP[loc].layers.push(layer);
      }
    }
  }

  // Armour Expansion Data
  async expandData(htmlOptions) {
    let data = await super.expandData(htmlOptions);
    let properties = [];
    properties.push(game.wfrp4e.config.armorTypes[this.armorType.value]);
    let itemProperties = this.Qualities.concat(this.Flaws);
    for (let prop of itemProperties)
      properties.push("<a class ='item-property'>" + prop + "</a>");
    properties.push(this.penalty.value);

    data.properties = properties.filter(p => !!p);
    return data;
  }

  chatData() {
    let properties = [
      `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
      `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
      `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
    ];

    if (this.armorType.value)
      properties.push(`<b>${game.i18n.localize("ITEM.ArmourType")}</b>: ${game.wfrp4e.config.armorTypes[this.armorType.value]}`);
    if (this.penalty.value)
      properties.push(`<b>${game.i18n.localize("Penalty")}</b>: ${this.penalty.value}`);


    for (let loc in game.wfrp4e.config.locations)
      if (this.AP[loc])
        properties.push(`<b>${game.wfrp4e.config.locations[loc]} AP</b>: ${this.currentAP[loc]}/${this.AP[loc]}`);



    // Make qualities and flaws clickable
    if (this.qualities.value.length)
      properties.push(`<b>${game.i18n.localize("Qualities")}</b>: ${this.OriginalQualities.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);

    if (this.flaws.value.length)
      properties.push(`<b>${game.i18n.localize("Flaws")}</b>: ${this.OriginalFlaws.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);


    properties = properties.filter(p => p != game.i18n.localize("Special"));
    if (this.special.value)
      properties.push(`<b>${game.i18n.localize("Special")}</b>: ` + this.special.value);

    properties = properties.filter(p => !!p);
    return properties;
  }

  
  static migrateData(data)
  {

    if (data.currentAP)
    {
        data.AP = data.maxAP;
        data.APdamage = data.currentAP;

        for(let loc in data.currentAP)
        {
          if(data.currentAP[loc] == -1)
            data.APdamage[loc] = 0;
          else {
            data.APdamage[loc] = data.maxAP[loc] - data.currentAP[loc];
          }
        }
    }
  }

}

let fields$h = foundry.data.fields;

class CareerModel extends BaseItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.careergroup = new fields$h.SchemaField({
            value: new fields$h.StringField()
        });
        schema.class = new fields$h.SchemaField({
            value: new fields$h.StringField()
        });
        schema.current = new fields$h.SchemaField({
            value: new fields$h.BooleanField()
        });
        schema.complete = new fields$h.SchemaField({
            value: new fields$h.BooleanField()
        });
        schema.level = new fields$h.SchemaField({
            value: new fields$h.NumberField({min: 1})
        });
        schema.status = new fields$h.SchemaField({
            standing: new fields$h.NumberField({min: 1}),
            tier: new fields$h.StringField({choices: ["b", "s", "g"]})
        });
        schema.characteristics = new fields$h.ArrayField(new fields$h.StringField());
        schema.skills = new fields$h.ArrayField(new fields$h.StringField());
        schema.talents = new fields$h.ArrayField(new fields$h.StringField());
        schema.trappings = new fields$h.ArrayField(new fields$h.StringField());
        schema.incomeSkill = new fields$h.ArrayField(new fields$h.NumberField());
        return schema;
    }


    createChecks()
    {
        if (this.parent.actor?.type == "creature") 
        {
            this.parent.actor.advanceNPC(this.parent);
        }
    }


     changeSkillName(oldName, newName) {
        let careerSkills = duplicate(this.skills);

        // If career has the skill, change the name
        if (careerSkills.includes(oldName)) 
        {
            careerSkills[careerSkills.indexOf(oldName)] = newName;
        }
        else // if it doesn't, return
        {
            return;
        }

        // Ask the user to confirm the change
        new Dialog({
            title: game.i18n.localize("SHEET.CareerSkill"),
            content: `<p>${game.i18n.localize("SHEET.CareerSkillPrompt")}</p>`,
            buttons: {
                yes: {
                    label: game.i18n.localize("Yes"),
                    callback: async dlg => {
                        ui.notifications.notify(`${game.i18n.format("SHEET.CareerSkillNotif", { oldName, newName, career: currentCareer.name })}`);
                        this.parent.update({ "system.skills": careerSkills });
                    }
                },
                no: {
                    label: game.i18n.localize("No"),
                    callback: async dlg => {
                        return;
                    }
                },
            },
            default: 'yes'
        }).render(true);
    }
    

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties = [];
        data.properties.push(`<b>${game.i18n.localize("Class")}</b>: ${this.class.value}`);
        data.properties.push(`<b>${game.i18n.localize("Group")}</b>: ${this.careergroup.value}`);
        data.properties.push(game.wfrp4e.config.statusTiers[this.status.tier] + " " + this.status.standing);
        data.properties.push(`<b>${game.i18n.localize("Characteristics")}</b>: ${this.characteristics.map(i => i = " " + game.wfrp4e.config.characteristicsAbbrev[i])}`);
        data.properties.push(`<b>${game.i18n.localize("Skills")}</b>: ${this.skills.map(i => i = " " + i)}`);
        data.properties.push(`<b>${game.i18n.localize("Talents")}</b>: ${this.talents.map(i => i = " " + i)}`);
        data.properties.push(`<b>${game.i18n.localize("Trappings")}</b>: ${this.trappings.map(i => i = " " + i)}`);
        data.properties.push(`<b>${game.i18n.localize("Income")}</b>: ${this.incomeSkill.map(i => ` <a class = 'career-income' data-career-id=${this.id}> ${this.skills[i]} <i class="fas fa-coins"></i></a>`)}`);
        // When expansion data is called, a listener is added for 'career-income'
        return data;
      }

      chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Class")}</b>: ${this.class.value}`);
        properties.push(`<b>${game.i18n.localize("Group")}</b>: ${this.careergroup.value}`);
        properties.push(`<b>${game.i18n.localize("Status")}</b>: ${game.wfrp4e.config.statusTiers[this.status.tier] + " " + this.status.standing}`);
        properties.push(`<b>${game.i18n.localize("Characteristics")}</b>: ${this.characteristics.map(i => i = " " + game.wfrp4e.config.characteristicsAbbrev[i])}`);
        properties.push(`<b>${game.i18n.localize("Skills")}</b>: ${this.skills.map(i => i = " " + "<a class = 'skill-lookup'>" + i + "</a>")}`);
        properties.push(`<b>${game.i18n.localize("Talents")}</b>: ${this.talents.map(i => i = " " + "<a class = 'talent-lookup'>" + i + "</a>")}`);
        properties.push(`<b>${game.i18n.localize("Trappings")}</b>: ${this.trappings.map(i => i = " " + i)}`);
        properties.push(`<b>${game.i18n.localize("Income")}</b>: ${this.incomeSkill.map(i => " " + this.skills[i])}`);
        return properties;
      }
}

let fields$g = foundry.data.fields;

class ContainerModel extends PhysicalItemModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.worn = new fields$g.SchemaField({
            value: new fields$g.BooleanField()
        });
        schema.wearable = new fields$g.SchemaField({
            value: new fields$g.BooleanField()
        });
        schema.carries = new fields$g.SchemaField({
            value: new fields$g.NumberField()
        });
        schema.countEnc = new fields$g.SchemaField({
            value: new fields$g.BooleanField()
        });

        return schema;
    }

    get isEquipped() {
      return this.worn.value
    }

    updateChecks(data, options, user)
    {
        let update = super.updateChecks(data, options, user);

        if (data.system?.location?.value) {
            let allContainers = this.parent.actor?.getItemTypes("container");
            if (this.formsLoop(item, allContainers))
            {
              ui.notifications.error("Loop formed - Resetting Container Location");
              update["system.location.value"] = "";
            }
          }

          return update
    }


    async preDeleteChecks() {
        await super.preDeleteChecks();

        // When deleting a container, remove the flag that determines whether it's collapsed in the sheet
        if (this.parent.actor) 
        {
            // Reset the location of items inside
            let items = this.packsInside.concat(this.carrying).map(i => i.toObject());
            for (let item of items) 
            {
                item.system.location.value = "";
            }

            await this.parent.actor.update({items, [`flags.wfrp4e.sheetCollapsed.-=${this.parent.id}`]: null });
        }
    }


    formsLoop(container, containerList, stack = []) {
      if (!container.location.value)
        return false
      else if (stack.includes(container.id))
        return true
      else {
        stack.push(container.id);
        return this.formsLoop(containerList.find(c => c.id == container.location.value), containerList, stack)
      }
    }


    computeOwned()
    {
      if (!this.countEnc.value)
      {
        this.encumbrance.value = 0;
      }
    }

    shouldTransferEffect(effect)
    {
        return super.shouldTransferEffect(effect) && (!effect.applicationData.equipTransfer || this.isEquipped)
    }


    chatData() {
      let properties = [
        `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} GC, ${this.price.ss || 0} SS, ${this.price.bp || 0} BP`,
        `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
        `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
      ];
  
      properties.push(`<b>${game.i18n.localize("Wearable")}</b>: ${(this.wearable.value ? game.i18n.localize("Yes") : game.i18n.localize("No"))}`);
      properties.push(`<b>${game.i18n.localize("ITEM.CountOwnerEnc")}</b>: ${(this.countEnc.value ? game.i18n.localize("Yes") : game.i18n.localize("No"))}`);
      return properties;
    }

}

let fields$f = foundry.data.fields;

class CriticalModel extends BaseItemModel {
    // allowedConditions = ["bleeding", "stunned", "blinded", "deafened", "incapacitated", "prone", "stunned", "fatigued"];
    // allowedEffectApplications = ["document"];
    // effectApplicationOptions = {documentType : "Actor"};

    static defineSchema() {
        let schema = super.defineSchema();
        schema.wounds = new fields$f.SchemaField({
            value: new fields$f.StringField(),
        });

        schema.modifier = new fields$f.SchemaField({
            value: new fields$f.StringField(),
        });

        schema.location = new fields$f.SchemaField({
            value: new fields$f.StringField(),
        });
        return schema;
    }


    createChecks(data, options, user) {
        if (this.parent.actor && this.parent.actor.type != "vehicle") 
        {
            let actor = this.parent.actor;
            try {

                let newWounds;
                let appliedWounds = Number.parseInt(this.wounds.value);
                if (Number.isInteger(appliedWounds)) 
                {
                    ui.notifications.notify(`${this.wounds.value} ${game.i18n.localize("CHAT.CriticalWoundsApplied")} ${actor.name}`);
                    newWounds = actor.status.wounds.value - appliedWounds;
                    if (newWounds < 0) 
                    {
                        newWounds = 0;
                    }
                } 
                else if (this.wounds.value.toLowerCase() == "death") 
                {
                    newWounds = 0;
                }

                if (game.combat && game.user.isGM) {
                    let minorInfections = game.combat.getFlag("wfrp4e", "minorInfections") || [];
                    minorInfections.push(actor.name);
                    game.combat.setFlag("wfrp4e", "minorInfections", null).then(c => game.combat.setFlag("wfrp4e", "minorInfections", minorInfections));
                }
                return { "system.status.wounds.value": newWounds };
            }
            catch (e) {
                console.error(`createChecks from ${this.parent?.actor?.name} threw error: ${e}.\n Arguments:`, this);
            }
        }
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(`<b>${game.i18n.localize("Wounds")}</b>: ${this.wounds.value}`);
        if (this.modifier.value)
          data.properties.push(`<b>${game.i18n.localize("Modifier")}</b>: ${this.modifier.value}`);
        return data;
      }

      chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Wounds")}</b>: ${this.wounds.value}`);
        properties.push(`<b>${game.i18n.localize("Location")}</b>: ${this.location.value}`);
        if (this.modifier.value)
          properties.push(`<b>${game.i18n.localize("Modifier")}</b>: ${this.modifier.value}`);
        return properties;
      }

}

let fields$e = foundry.data.fields;

/**
 * Represents an Item used by both Patrons and Characters/NPCs
 */
class DiseaseModel extends BaseItemModel
{

    static defineSchema() 
    {
        let schema = {};
        schema.contraction = new fields$e.SchemaField({
            value : new fields$e.StringField(),
        });
        
        schema.incubation = new fields$e.SchemaField({
            value : new fields$e.StringField(),
        });

        schema.duration = new fields$e.SchemaField({
            value : new fields$e.StringField(),
            unit : new fields$e.StringField(),
            active : new fields$e.BooleanField(),
        });

        schema.symptoms = new fields$e.SchemaField({
            value : new fields$e.StringField(),
        });

        schema.permanent = new fields$e.SchemaField({
            value : new fields$e.StringField(),
        });
        return schema;
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(`<b>${game.i18n.localize("Contraction")}:</b> ${this.contraction.value}`);
        data.properties.push(`<b>${game.i18n.localize("Incubation")}:</b> ${this.incubation.value} ${this.incubation.unit}`);
        data.properties.push(`<b>${game.i18n.localize("Duration")}:</b> ${this.duration.value} ${this.duration.unit}`);
        data.properties = data.properties.concat(this.parent.effects.map(i => i = "<a class ='symptom-tag'><i class='fas fa-user-injured'></i> " + i.name.trim() + "</a>").join(", "));
        if (this.permanent.value)
          data.properties.push(`<b>${game.i18n.localize("Permanent")}:</b> ${this.permanent.value}`);
        return data;
      }

      chatData()
      {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Contraction")}:</b> ${this.contraction.value}`);
        properties.push(`<b>${game.i18n.localize("Incubation")}:</b> <a class = 'chat-roll'><i class='fas fa-dice'></i> ${this.incubation.value}</a>`);
        properties.push(`<b>${game.i18n.localize("Duration")}:</b> <a class = 'chat-roll'><i class='fas fa-dice'></i> ${this.duration.value}</a>`);
        properties.push(`<b>${game.i18n.localize("Symptoms")}:</b> ${(this.symptoms.value.split(",").map(i => i = "<a class ='symptom-tag'><i class='fas fa-user-injured'></i> " + i.trim() + "</a>")).join(", ")}`);
        if (this.permanent.value)
          properties.push(`<b>${game.i18n.localize("Permanent")}:</b> ${this.permanent.value}`);
        return properties;
      }
}

let fields$d = foundry.data.fields;

class InjuryModel extends BaseItemModel 
{
    // allowedConditions = ["bleeding", "stunned", "blinded", "deafened", "incapacitated", "prone", "stunned"];
    // allowedEffectApplications = ["document"];
    // effectApplicationOptions = {documentType : "Actor"};

    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.location = new fields$d.SchemaField({
            value : new fields$d.StringField(),
        });
        
        schema.penalty = new fields$d.SchemaField({
            value : new fields$d.StringField(),
        });

        schema.duration = new fields$d.SchemaField({
            value : new fields$d.StringField(),
            active : new fields$d.BooleanField(),
            permanent : new fields$d.BooleanField(),
        });
        return schema;
    }

    chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Location")}</b>: ${this.location.value}`);
        if (this.penalty.value)
          properties.push(`<b>${game.i18n.localize("Penalty")}</b>: ${this.penalty.value}`);
        return properties;
      }

}

let fields$c = foundry.data.fields;

class MoneyModel extends PhysicalItemModel
{
    static defineSchema() 
    {
        // Patron Fields
        let schema = super.defineSchema();

        schema.coinValue = new fields$c.SchemaField({
            value : new fields$c.NumberField({initial: 1}),
        });

        return schema;
    }

    async expandData() {
        let data = await super.expandData(htmlOptions);
        data.properties = [`${game.i18n.localize("ITEM.PenniesValue")}: ${this.coinValue.value}`];
        return data;
      }

      chatData() {
        let properties = [
          `<b>${game.i18n.localize("ITEM.PenniesValue")}</b>: ${this.coinValue.value}`,
          `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
        ];
        return properties;
      }
}

let fields$b = foundry.data.fields;

class MutationModel extends BaseItemModel
{
    static defineSchema() 
    {
        // Patron Fields
        let schema = super.defineSchema();
        schema.mutationType = new fields$b.SchemaField({
            value : new fields$b.StringField(),
        });
        
        schema.modifier = new fields$b.SchemaField({
            value : new fields$b.StringField(),
        });

        schema.modifiesSkills = new fields$b.SchemaField({
            value : new fields$b.BooleanField(),
        });

        return schema;
    }


    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(game.wfrp4e.config.mutationTypes[this.mutationType.value]);
        if (this.modifier.value)
          data.properties.push(this.modifier.value);
        return data;
      }

      chatData() {
        let properties = [
          `<b>${game.i18n.localize("ITEM.MutationType")}</b>: ${game.wfrp4e.config.mutationTypes[this.mutationType.value]}`,
        ];
        if (this.modifier.value)
          properties.push(`<b>${game.i18n.localize("Modifier")}</b>: ${this.modifier.value}`);
        return properties;
      }
    
}

let fields$a = foundry.data.fields;

class OvercastItemModel extends BaseItemModel {


  static defineSchema() 
  {
      let schema = super.defineSchema();
      // Embedded Data Models?
      schema.overcast = new fields$a.SchemaField({
          enabled : new fields$a.BooleanField(),
          label : new fields$a.StringField(),
          valuePerOvercast : new fields$a.SchemaField({
               type : new fields$a.StringField(),
               value : new fields$a.NumberField({initial : 1}),
               SL : new fields$a.BooleanField(),
               characteristic  : new fields$a.StringField(),
               bonus : new fields$a.BooleanField(),
          }),
          initial : new fields$a.SchemaField({
              type : new fields$a.StringField(),
              value : new fields$a.NumberField({initial : 1}),
              SL : new fields$a.BooleanField(),
              characteristic  : new fields$a.StringField(),
              bonus : new fields$a.BooleanField(),
         }),
      });
      return schema;
  }


    /**
   * Turns a formula into a processed string for display
   * 
   * Processes damage formula based - same as calculateSpellAttributes, but with additional
   * consideration to whether its a magic missile or not
   * 
   * @param   {String}  formula         Formula to process - "Willpower Bonus + 4" 
   * @param   {boolean} isMagicMissile  Whether or not it's a magic missile - used in calculating additional damage
   * @returns {String}  Processed formula
   */
      computeSpellDamage(formula, isMagicMissile) {
      try {
        if (formula) {
            formula = formula.toLowerCase();

            if (isMagicMissile) {// If it's a magic missile, damage includes willpower bonus
              formula += "+" + this.parent.actor.characteristics["wp"].bonus;
            }

            let labels = game.wfrp4e.config.characteristics;
            let sortedCharacteristics = Object.entries(this.parent.actor.characteristics).sort((a,b) => -1 * labels[a[0]].localeCompare(labels[b[0]]));
            sortedCharacteristics.forEach(arr => {
              let ch = arr[0];
              // Handle characteristic with bonus first
              formula = formula.replace(game.wfrp4e.config.characteristicsBonus[ch].toLowerCase(), this.parent.actor.characteristics[ch].bonus);
              formula = formula.replace(game.wfrp4e.config.characteristics[ch].toLowerCase(), this.parent.actor.characteristics[ch].value);
            });

            return (0, eval)(formula);
        }
        return 0;
      }
      catch (e) {
        console.error(`Spell from ${this.parent?.actor?.name} threw error: ${e}.\n Arguments:`, this, formula);
        throw ui.notifications.error(game.i18n.format("ERROR.ParseSpell"));
      }
  }

  // Don't really like this here as it uses assumed subclass data, but it'll do for now
  computeOvercastingData() {
    let usage = {
      damage: undefined,
      range: undefined,
      duration: undefined,
      target: undefined,
      other: undefined,
    };

    let damage = this.Damage;
    let target = this.Target;
    let duration = this.Duration;
    let range = this.Range;

    if (this.magicMissile?.value) {
      usage.damage = {
        label: game.i18n.localize("Damage"),
        count: 0,
        initial: parseInt(damage) || damage,
        current: parseInt(damage) || damage,
        available: false
      };
    }
    if (parseInt(target) && !includesMaximum(target)) {
      usage.target = {
        label: game.i18n.localize("Target"),
        count: 0,
        AoE: false,
        initial: parseInt(target) || target,
        current: parseInt(target) || target,
        unit: "",
        available: false
      };
    }
    else if (target.includes("AoE") && !includesMaximum(target)) {
      let aoeValue = target.substring(target.indexOf("(") + 1, target.length - 1);
      usage.target = {
        label: game.i18n.localize("AoE"),
        count: 0,
        AoE: true,
        initial: parseInt(aoeValue) || aoeValue,
        current: parseInt(aoeValue) || aoeValue,
        unit: aoeValue.split(" ")[1],
        available: false
      };
    }
    if (parseInt(duration) && !includesMaximum(duration)) {
      usage.duration = {
        label: game.i18n.localize("Duration"),
        count: 0,
        initial: parseInt(duration) || duration,
        current: parseInt(duration) || duration,
        unit: duration.split(" ")[1],
        available: false
      };
    }
    if (parseInt(range) && !includesMaximum(range)) {
      usage.range = {
        label: game.i18n.localize("Range"),
        count: 0,
        initial: parseInt(range) || aoeValue,
        current: parseInt(range) || aoeValue,
        unit: range.split(" ")[1],
        available: false
      };
    }

    if (this.overcast?.enabled) {
      let other = {
        label: this.overcast.label,
        count: 0
      };


      // Set initial overcast option to type assigned, value is arbitrary, characcteristics is based on actor data, SL is a placeholder for tests
      if (this.overcast.initial.type == "value") {
        other.initial = parseInt(this.overcast.initial.value) || 0;
        other.current = parseInt(this.overcast.initial.value) || 0;
      }
      else if (this.overcast.initial.type == "characteristic") {
        let char = this.parent.actor.characteristics[this.overcast.initial.characteristic];

        if (this.overcast.initial.bonus)
          other.initial = char.bonus;
        else
          other.initial = char.value;

        other.current = other.initial;
      }
      else if (this.overcast.initial.type == "SL") {
        other.initial = "SL";
        other.current = "SL";
      }

      // See if overcast increments are also based on characteristics, store that value so we don't have to look it up in the roll class
      if (this.overcast.valuePerOvercast.type == "characteristic") {
        let char = this.parent.actor.characteristics[this.overcast.valuePerOvercast.characteristic];

        if (this.overcast.valuePerOvercast.bonus)
          other.increment = char.bonus;
        else
          other.increment = char.value;

        //other.increment = other.initial;
      }

      usage.other = other;
    }

    this.overcast.usage = usage;

    // Perhaps not the best implementation, but if a spell range (or other) says "maximum", don't allow overcasting
    function includesMaximum(string) {
      return string.toLowerCase().includes(game.i18n.localize("ITEM.Maximum").toLowerCase());
    }

  }



  /**
   * Turns a formula into a processed string for display
   * 
   * Turns a spell attribute such as "Willpower Bonus Rounds" into a more user friendly, processed value
   * such as "4 Rounds". If the aoe is checked, it wraps the result in AoE (Result).
   * 
   * @param   {String}  formula   Formula to process - "Willpower Bonus Rounds" 
   * @param   {boolean} aoe       Whether or not it's calculating AoE (changes string return)
   * @returns {String}  formula   processed formula
   */
  computeSpellPrayerFormula(type, aoe = false, formulaOverride) {
    let formula = formulaOverride || this[type]?.value;
    try {
      if (Number.isNumeric(formula))
        return formula

      formula = formula.toLowerCase();

      // Do not process these special values
      if (formula != game.i18n.localize("You").toLowerCase() && formula != game.i18n.localize("Special").toLowerCase() && formula != game.i18n.localize("Instant").toLowerCase()) {
        // Iterate through characteristics
        let labels = game.wfrp4e.config.characteristics;
        let sortedCharacteristics = Object.entries(this.parent.actor.characteristics).sort((a,b) => -1 * labels[a[0]].localeCompare(labels[b[0]]));
        sortedCharacteristics.forEach(arr => {
          let ch = arr[0];
          // Handle characteristic with bonus first
          formula = formula.replace(game.wfrp4e.config.characteristicsBonus[ch].toLowerCase(), this.parent.actor.characteristics[ch].bonus);
          formula = formula.replace(game.wfrp4e.config.characteristics[ch].toLowerCase(), this.parent.actor.characteristics[ch].value);
        });

        let total = 0;
        let i = 0;
        let s = formula;
        for (; i < s.length; i++) {
          if (!(!isNaN(parseInt(s[i])) || s[i] == ' ' || s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/')) {
            break;
          }
        }
        if (i > 0) {
          if (i != s.length) {
            total = (0, eval)(s.substr(0, i - 1));
            formula = total.toString() + " " + s.substr(i).trim();
          } else {
            total = (0, eval)(s);
            formula = total.toString();
          }
        }

        // If AoE - wrap with AoE ( )
        if (aoe)
          formula = "AoE (" + formula.capitalize() + ")";
      }
      return formula.capitalize();
    }
    catch (e) {
      console.error(`computeSpellPrayerFormula from ${this.parent?.actor?.name} threw error: ${e}.\n Arguments:`, this, formula);
      return 0;
    }
  }
}

let fields$9 = foundry.data.fields;

class PrayerModel extends OvercastItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();

        schema.type = new fields$9.SchemaField({
            value : new fields$9.StringField(),
        });
        schema.god = new fields$9.SchemaField({
            value : new fields$9.StringField(),
        });             
        schema.range = new fields$9.SchemaField({
            value : new fields$9.StringField(),
        });
        schema.target = new fields$9.SchemaField({
            value : new fields$9.StringField(),
            aoe : new fields$9.BooleanField(),
        });
        schema.duration = new fields$9.SchemaField({
            value : new fields$9.StringField(),
            extendable : new fields$9.BooleanField(),
        });
        schema.damage = new fields$9.SchemaField({
            dice : new fields$9.StringField(),
            value : new fields$9.StringField(),
            addSL : new fields$9.BooleanField(),
        });
        return schema;
    }

    get Target() {
        return this.computeSpellPrayerFormula("target", this.target.aoe)
      }


    get Duration() {
      let duration = this.computeSpellPrayerFormula("duration", this.range?.aoe);
      return duration
    }

      get Range() {
        return this.computeSpellPrayerFormula("range")
    }

    get Damage() {
        return parseInt(this.computeSpellDamage(this.damage.value, false) || 0)
      }
  

    async preCreateData(data, options, user) {
        let preCreateData = await super.preCreateData(data, options, user);

        if (this.parent.isOwned) 
        {
            let actor = this.parent.actor;
            if (actor.type == "character" && this.type.value == "miracle") {
                WFRP_Utility$1.miracleGainedDialog(this.parent, actor);
            }
        }

        return preCreateData;
    }

    computeOwned()
    {
        super.computeOwned();
        this.computeOvercastingData();
    }

    getSkillToUse()
    {
        let skills = this.parent.actor?.getItemTypes("skill");
        let skill = skills.find(i => i.name.toLowerCase() == game.i18n.localize("NAME.Pray").toLowerCase());
        return skill;
    }


    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(`${game.i18n.localize("Range")}: ${this.Range}`);
        data.properties.push(`${game.i18n.localize("Target")}: ${this.Target}`);
        data.properties.push(`${game.i18n.localize("Duration")}: ${this.Duration}`);
        let damage = this.Damage || "";
        if (this.damage.dice)
          damage += " + " + this.damage.dice;
        if (this.damage.addSL)
          damage += " + " + game.i18n.localize("SL");
        if (this.damage.value)
          data.properties.push(`${game.i18n.localize("Damage")}: ${this.DamageString}`);
        return data;
      }

      chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Range")}</b>: ${this.range.value}`);
        properties.push(`<b>${game.i18n.localize("Target")}</b>: ${this.target.value}`);
        properties.push(`<b>${game.i18n.localize("Duration")}</b>: ${this.duration.value}`);
        if (this.damage.value)
          properties.push(`<b>${game.i18n.localize("Damage")}</b>: ${this.damage.value}`);
        return properties;
      }
    
}

foundry.data.fields;

class PsychologyModel extends BaseItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();

        return schema;
    }

    chatData() {
        return [];
      }
}

let fields$8 = foundry.data.fields;

class TalentModel extends BaseItemModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.max = new fields$8.SchemaField({
            value: new fields$8.StringField()
        });
        schema.advances = new fields$8.SchemaField({
            value: new fields$8.NumberField({initial : 1, min: 1}),
            force: new fields$8.BooleanField()
        });
        schema.career = new fields$8.SchemaField({
            value: new fields$8.StringField()
        });
        schema.tests = new fields$8.SchemaField({
            value: new fields$8.StringField()
        });
        return schema;
    }

    get Max() {
        switch (this.max.value) // Turn its max value into "numMax", which is an actual numeric value
        {
            case '1':
                return 1;

            case '2':
                return 2;

            case '3':
                return 3;

            case '4':
                return 4;

            case 'none':
                return "-";

            default:
                return this.parent.actor.characteristics[this.max.value].bonus;
        }
    }

    get cost() {
        return (this.Advances + 1) * 100
    }

    get Advances() {
        if (this.parent.isOwned) {
          let talents = this.parent.actor.getItemTypes("talent");
          return talents.filter(i => i.name == this.parent.name).reduce((prev, current) => prev += current.advances.value, 0)
        }
        else {
          return this.advances.value
        }
      }

    computeOwned() {
        this.advances.indicator = this.advances.force;
    }

    _addCareerData(career) {
        if (!career)
            return

        this.advances.career = this;
        this.advances.indicator = this.advances.indicator || !!this.advances.career || false;
    }

    chatData() {
        let properties = [];
        properties.push(`<b>${game.i18n.localize("Max")}: </b> ${game.wfrp4e.config.talentMax[this.max.value]}`);
        if (this.tests.value)
            properties.push(`<b>${game.i18n.localize("Tests")}: </b> ${this.tests.value}`);
        return properties;
    }
}

let fields$7 = foundry.data.fields;

class TrappingModel extends PropertiesMixin$1(PhysicalItemModel)
{
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.trappingType = new fields$7.SchemaField({
            value: new fields$7.StringField()
        }),
        schema.spellIngredient = new fields$7.SchemaField({
            value: new fields$7.StringField()
        });
        schema.worn = new fields$7.BooleanField();
        return schema;
    }

    get isEquipped() {

        return this.worn
    }

    async preCreateData(data, options, user)
    {
       let preCreateData = await super.preCreateData(data, options, user);

       if (this.trappingType == "clothingAccessories" && this.parent.isOwned && this.parent.actor.type != "character" && this.parent.actor.type != "vehicle")
       {
          setProperty({preCreateData, "system.worn" : true}); // TODO: migrate this into a unified equipped property 
       }
           
       return preCreateData;
    }

    shouldTransferEffect(effect)
    {
        return super.shouldTransferEffect(effect) && (!effect.applicationData.equipTransfer || this.isEquipped)
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
    
        let itemProperties = this.Qualities.concat(this.Flaws);
        for (let prop of itemProperties)
          data.properties.push("<a class ='item-property'>" + prop + "</a>");
    
        return data;
      }

      chatData() {
        let properties = [
          `<b>${game.i18n.localize("ITEM.TrappingType")}</b>: ${game.wfrp4e.config.trappingCategories[this.trappingType.value]}`,
          `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
          `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
          `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
        ];
    
        // Make qualities and flaws clickable
        if (this.qualities.value.length)
          properties.push(`<b>${game.i18n.localize("Qualities")}</b>: ${this.OriginalQualities.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);
    
        if (this.flaws.value.length)
          properties.push(`<b>${game.i18n.localize("Flaws")}</b>: ${this.OriginalFlaws.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);
    
        return properties;
      }

}

let fields$6 = foundry.data.fields;

class SkillModel extends BaseItemModel {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.advanced = new fields$6.SchemaField({
            value: new fields$6.StringField(),
        });
        schema.grouped = new fields$6.SchemaField({
            value: new fields$6.StringField({ initial: "noSpec" })
        });
        schema.characteristic = new fields$6.SchemaField({
            value: new fields$6.StringField({ initial: "ws" }),
        });
        schema.advances = new fields$6.SchemaField({
            value: new fields$6.NumberField(),
            costModifier: new fields$6.NumberField(),
            force: new fields$6.BooleanField(),
        });
        schema.modifier = new fields$6.SchemaField({
            value: new fields$6.NumberField(),
        });
        schema.total = new fields$6.SchemaField({
            value: new fields$6.NumberField(),
        });
        return schema;
    }

    get cost() {
          return WFRP_Utility$1._calculateAdvCost(this.advances.value, "skill", this.advances.costModifier)
    }

    get modified() {
        if (this.modifier) {
          if (this.modifier.value > 0)
            return "positive";
          else if (this.modifier.value < 0)
            return "negative"
        }
        return ""
      }
    

    async preUpdateChecks(data) {
        await super.preUpdateChecks(data);

        if (this.parent.isOwned && this.grouped.value == "isSpec" && data.name) {
            this._handleSkillNameChange(data.name);
        }
    }

    computeOwned()
    {
        this.total.value = this.modifier.value + this.advances.value + this.parent.actor.system.characteristics[this.characteristic.value].value;
        this.advances.indicator = this.advances.force;
    }


    _addCareerData(career) {
        if (!career)
          return
          
        this.advances.career = this;
        if (this.advances.value >= career.level.value * 5)
        {
            this.advances.complete = true;
        }
        this.advances.indicator = this.advances.indicator || !!this.advances.career || false;
      }

    // If an owned (grouped) skill's name is changing, change the career data to match
    _handleSkillNameChange(newName) {
        let oldName = this.parent.name;
        let currentCareer = this.parent.actor?.currentCareer;
        if (!currentCareer) 
        {
            return
        }
        else 
        {
            currentCareer.system.changeSkillName(oldName, newName);
        }
    }

    chatData() {
        let properties = [];
        properties.push(this.advanced == "adv" ? `<b>${game.i18n.localize("Advanced")}</b>` : `<b>${game.i18n.localize("Basic")}</b>`);
        return properties;
    }
    
}

let fields$5 = foundry.data.fields;

class SpellModel extends OvercastItemModel {
    static defineSchema() {
        let schema = super.defineSchema();

        schema.lore = new fields$5.SchemaField({
            value: new fields$5.StringField(),
            effectString: new fields$5.StringField(),
        });
        schema.range = new fields$5.SchemaField({
            value: new fields$5.StringField(),
            vortex: new fields$5.BooleanField(),
        });
        schema.target = new fields$5.SchemaField({
            value: new fields$5.StringField(),
            aoe: new fields$5.BooleanField(),
        });
        schema.duration = new fields$5.SchemaField({
            value: new fields$5.StringField(),
            extendable: new fields$5.BooleanField(),
        });
        schema.damage = new fields$5.SchemaField({
            dice: new fields$5.StringField(),
            value: new fields$5.StringField(),
        });
        schema.cn = new fields$5.SchemaField({
            value: new fields$5.NumberField(),
            SL: new fields$5.NumberField(),
        });
        schema.magicMissile = new fields$5.SchemaField({
            value: new fields$5.BooleanField(),
        });
        schema.ritual = new fields$5.SchemaField({
            value: new fields$5.BooleanField(),
            type: new fields$5.StringField(),
            xp: new fields$5.NumberField(),
        });
        schema.memorized = new fields$5.SchemaField({
            value: new fields$5.BooleanField(),
        });
        schema.skill = new fields$5.SchemaField({
            value: new fields$5.StringField(),
        });
        schema.ingredients = new fields$5.ArrayField(new fields$5.StringField());
        schema.currentIng = new fields$5.SchemaField({
            value: new fields$5.StringField(),
        });
        schema.wind = new fields$5.SchemaField({
            value: new fields$5.StringField(),
        });
        return schema;
    }

    get ingredient() {
        if (this.currentIng.value)
          return this.parent.actor?.items.get(this.currentIng.value)
      }


      get ingredientList() {
        return this.parent.actor?.getItemTypes("trapping").filter(t => t.trappingType.value == "ingredient" && t.spellIngredient.value == this.parent.id)
      }

      get Target() {
        return this.computeSpellPrayerFormula("target", this.target.aoe)
      }

      get Duration() {
        let duration = this.computeSpellPrayerFormula("duration", this.range?.aoe);
        if (this.duration?.extendable)
          duration += "+";
        return duration
      }

      get Range() {
          return this.computeSpellPrayerFormula("range")
      }

      get Damage() {
        return parseInt(this.computeSpellDamage(this.damage.value, this.magicMissile.value) || 0)
      }    
    
    

    async preCreateData(data, options, user) {
        let preCreateData = await super.preCreateData(data, options, user);

        if (this.parent.isOwned) {
            let actor = this.parent.actor;
            if (actor.type != "character" && actor.type != "vehicle") {
                setProperty({ preCreateData, "system.memorized.value": true });
            }

            if (actor.type == "character" && (this.lore.value == "petty" || this.lore.value == game.i18n.localize("WFRP4E.MagicLores.petty"))) {
                WFRP_Utility$1.memorizeCostDialog(this.parent, actor);
            }
        }

        return preCreateData;
    }

    computeBase() {
        let lore = foundry.utils.deepClone(game.wfrp4e.config.loreEffects[this.lore.value]);
        if (lore) {
            this.lore.effect = new EffectWfrp4e(lore, { parent: this.parent });
        }
        this._addSpellDescription();
    }

    computeOwned()
    {
        this.cn.value = this.memorized.value ? this.cn.value : this.cn.value * 2;
        if (this.ritual?.value && !this.memorized.value)
        {
          this.cn.value *= 2; // Unmemorized rituals are 4 * CN
        }
        else 
        {
          this.computeOvercastingData();
        }
    }


    getSkillToUse()
    {
        let skills = this.parent.actor?.getItemTypes("skill");
        let skill;
        // Use skill override, if not found, use Language (Magick)
        if (this.skill.value)
        {
            skill = skills.find(i => i.name.toLowerCase() == this.skill.value.toLowerCase());
        }
        if (!skill)
        {
            skill = skills.find(i => i.name.toLowerCase() == `${game.i18n.localize("NAME.Language")} (${game.i18n.localize("SPEC.Magick")})`.toLowerCase());
        }
        return skill
    }

    getOtherEffects()
    {
        return super.getOtherEffects().concat(this.lore.effect || [])
    }

    /**
    * Augments the spell item's description with the lore effect
    * 
    * The spell's lore is added at the end of the spell's description for
    * an easy reminder. However, this causes issues because we don't want
    * the lore to be 'saved' in the description. So we append the lore
    * if it does not already exist
    * 
    * @param {Object} spell 'spell' type item
    */
    _addSpellDescription() {
        let description = this.description.value;
        if (description && description.includes(game.i18n.localize("SPELL.Lore")))
            return description

        // Use lore override if it exists
        if (this.lore.effectString)
            description += `<p>\n\n <b>${game.i18n.localize("SPELL.Lore")}</b> ${this.lore.effectString}<p>`;
        // Otherwise, use config value for lore effect
        else if (game.wfrp4e.config.loreEffectDescriptions && game.wfrp4e.config.loreEffectDescriptions[this.lore.value])
            description += `<p>\n\n <b>${game.i18n.localize("SPELL.Lore")}</b> ${game.wfrp4e.config.loreEffectDescriptions[this.lore.value]}<p>`;

        this.description.value = description;
    }


    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties.push(`${game.i18n.localize("Range")}: ${this.Range}`);
        let target = this.Target;
        if (target.includes("AoE"))
          target = `<a class='aoe-template' data-id="${this.id}" data-actor-id="${this.parent.actor.id}"><i class="fas fa-ruler-combined"></i>${target}</a>`;
        data.properties.push(`${game.i18n.localize("Target")}: ${target}`);
        data.properties.push(`${game.i18n.localize("Duration")}: ${this.Duration}`);
        if (this.magicMissile.value)
          data.properties.push(`${game.i18n.localize("Magic Missile")}: +${this.Damage}`);
        else if (this.damage.value || this.damage.dices) {
          let damage = this.Damage || "";
          if (this.damage.dice)
            damage += " + " + this.damage.dice;
          data.properties.push(`${game.i18n.localize("Damage")}: ${damage}`);
        }
        return data;
      }

      chatData() {
        let properties = [];
        if (game.wfrp4e.config.magicLores[this.lore.value])
          properties.push(`<b>${game.i18n.localize("Lore")}</b>: ${game.wfrp4e.config.magicLores[this.lore.value]}`);
        else
          properties.push(`<b>${game.i18n.localize("Lore")}</b>: ${this.lore.value}`);
        properties.push(`<b>${game.i18n.localize("CN")}</b>: ${this.cn.value}`);
        properties.push(`<b>${game.i18n.localize("Range")}</b>: ${this.range.value}`);
        properties.push(`<b>${game.i18n.localize("Target")}</b>: ${this.target.value}`);
        properties.push(`<b>${game.i18n.localize("Duration")}</b>: ${this.duration.value}`);
        if (this.damage.value)
          properties.push(`<b>${game.i18n.localize("Damage")}</b>: ${this.damage.value}`);
    
        return properties;
      }


}

let fields$4 = foundry.data.fields;

class TraitModel extends PropertiesMixin$1(BaseItemModel)
{
    static defineSchema() 
    {
        let schema = super.defineSchema();

        schema.rollable = new fields$4.SchemaField({
            value : new fields$4.BooleanField({}),
            damage : new fields$4.BooleanField({}),
            skill : new fields$4.StringField({}),
            rollCharacteristic : new fields$4.StringField({}),
            bonusCharacteristic : new fields$4.StringField({}),
            dice : new fields$4.StringField({}),
            defaultDifficulty : new fields$4.StringField({}),
            SL : new fields$4.BooleanField({}),
            attackType : new fields$4.StringField({initial: "melee"}),
        });

        schema.specification = new fields$4.SchemaField({
            value : new fields$4.StringField(),
        });

        schema.qualities = new fields$4.SchemaField({
            value: new fields$4.ArrayField(new fields$4.ObjectField({}))
        });

        schema.flaws = new fields$4.SchemaField({
            value: new fields$4.ArrayField(new fields$4.ObjectField({}))
        });
    
        return schema;
    }

    
    get isMelee()
    {
        return this.attackType == "melee";
    }

    get isRanged()
    {
        return this.attackType == "ranged";
    }

    get attackType() {
        if (this.rollable.damage)
          return this.rollable.attackType
      }

      get DisplayName() {
        return this.specification.value ? this.parent.name + " (" + this.Specification + ")" : this.parent.name;
      }


    get Damage() {
        let damage;
        let actor = this.parent.actor;
        if (this.rollable.damage)
            damage = this.Specification;
    
    
        //@HOUSE
        if (game.settings.get("wfrp4e", "mooSizeDamage") && actor.sizeNum > 3) 
        {
          if (this.rollable.bonusCharacteristic == "s") 
          {
            game.wfrp4e.utility.logHomebrew("mooSizeDamage");
            let SBsToAdd = actor.sizeNum - 3;
            damage += (actor.characteristics.s.bonus * SBsToAdd);
          }
    
        }
        //@/HOUSE
    
        return parseInt(damage || 0)
      }

      get DamageString() {
        let string = "";
        string += this.Damage;
    
        if (this.damage.dice)
          string += `+ ${this.damage.dice}`;
    
        if (this.ammo && this.ammo.damage.dice)
          string += `+ ${this.ammo.damage.dice}`;
    
        return string
      }

      get mountDamage() {

        let actor = this.parent.actor;
        if (!actor)
            return;

        if (this.attackType != "melee" || !actor.isMounted || !actor.mount)
        {
            return this.Damage
        }
    
        if (this.rollable.bonusCharacteristic == "s") 
        {
          return this.Damage + (actor.mount.characteristics[this.rollable.bonusCharacteristic].bonus - actor.characteristics[this.rollable.bonusCharacteristic].bonus)
        }
        else
        {
            return this.Damage
        }
      }

      get Specification() {

        let actor = this.parent.actor;

        let specification;
        if (this.specification.value) {
          if (this.rollable.bonusCharacteristic)  // Bonus characteristic adds to the specification (Weapon +X includes SB for example)
          {
            specification = parseInt(this.specification.value) || 0;
            specification += actor.characteristics[this.rollable.bonusCharacteristic].bonus;
            if (this.attackType && actor)
            {
              specification += (actor.flags[`${this.attackType}DamageIncrease`] || 0);
            }
          }
          else
            specification = this.specification.value;
        }
        return specification
      }
    
      get SpecificationBonus() {
        return this.parent.actor?.characteristics[this.rollable.bonusCharacteristic].bonus
      }

    computeBase() 
    {
        super.computeBase();
    }

    computeOwnerDerived(actor) 
    {

    }
      
    getSkillToUse()
    {
        let skills = this.parent.actor?.getItemTypes("skill");
        let skill = skills.find(i => i.name == this.rollable.skill);
        return skill;
    }


    chatData() {
        let properties = [];
        if (this.specification.value)
          properties.push(`<b>${game.i18n.localize("Specification")}: </b> ${this.specification.value}`);
        return properties;
      }


}

let fields$3 = foundry.data.fields;

class WeaponModel extends PropertiesMixin$1(PhysicalItemModel) {
    static defineSchema() {
        let schema = super.defineSchema();
        schema.damage = new fields$3.SchemaField({
            value: new fields$3.StringField({ initial: "" })
        });
        schema.weaponGroup = new fields$3.SchemaField({
            value: new fields$3.StringField({ initial: "basic" })
        });
        schema.reach = new fields$3.SchemaField({
            value: new fields$3.StringField({ initial: "" })
        });
        schema.range = new fields$3.SchemaField({
            value: new fields$3.StringField({ initial: "" })
        });
        schema.skill = new fields$3.SchemaField({
            value: new fields$3.StringField({ initial: "" })
        });
        schema.modeOverride = new fields$3.SchemaField({
            value: new fields$3.StringField({ initial: "" })
        });
        schema.twohanded = new fields$3.SchemaField({
            value: new fields$3.BooleanField({ initial: false })
        });
        schema.ammunitionGroup = new fields$3.SchemaField({
            value: new fields$3.StringField({ initial: "" })
        });
        schema.currentAmmo = new fields$3.SchemaField({
            value: new fields$3.StringField({ initial: "" })
        });
        schema.consumesAmmo = new fields$3.SchemaField({
            value: new fields$3.BooleanField({ initial: false })
        });
        schema.special = new fields$3.SchemaField({
            value: new fields$3.StringField({ initial: "" })
        });
        schema.value = new fields$3.BooleanField({ initial: false });
        schema.loaded = new fields$3.SchemaField({
            value: new fields$3.BooleanField({ initial: false }),
            repeater: new fields$3.BooleanField({ initial: false }),
            amt: new fields$3.NumberField({ initial: 0 })
        });
        schema.offhand = new fields$3.SchemaField({
            value: new fields$3.BooleanField({ initial: false })
        });

        schema.equipped = new fields$3.BooleanField({ initial: false });

        return schema;
    }

    //#region getters 

    get isMelee() {
        return this.modeOverride?.value == "melee" || (game.wfrp4e.config.groupToType[this.weaponGroup.value] == "melee" && this.modeOverride?.value != "ranged")
    }

    get isRanged() {
        return this.modeOverride?.value == "ranged" || (game.wfrp4e.config.groupToType[this.weaponGroup.value] == "ranged" && this.modeOverride?.value != "melee")
    }

    get isEquipped() {

        return this.equipped
    }

    get WeaponGroup() {
        return game.wfrp4e.config.weaponGroups[this.weaponGroup.value]
    }

    get Reach() {
        return game.wfrp4e.config.weaponReaches[this.reach.value];
    }

    get Range() {
        return this.applyAmmoMods(this.computeWeaponFormula("range"), "range")
      }
    

    get attackType() {
        return this.modeOverride?.value || game.wfrp4e.config.groupToType[this.weaponGroup.value]
    }

    get reachNum() {
        return game.wfrp4e.config.reachNum[this.reach.value]
    }

    get ammo() {
        if (this.attackType == "ranged" && this.currentAmmo?.value && this.parent.isOwned)
          return this.parent.actor.items.get(this.currentAmmo.value)
    }

    get ammoList() {
    if (this.ammunitionGroup.value == "throwing")
        return this.parent.actor.getItemTypes("weapon").filter(i => i.weaponGroup.value == "throwing")
    else 
        return this.parent.actor.getItemTypes("ammunition").filter(a => a.ammunitionType.value == this.ammunitionGroup.value)
    }

    get Damage() {

        let actor = this.parent.actor;
        let damage = this.applyAmmoMods(this.computeWeaponFormula("damage"), "damage") + (actor.flags[`${this.attackType}DamageIncrease`] || 0) - Math.max((this.damageToItem.value - (this.properties.qualities.durable?.value || 0)), 0);

        //@HOUSE
        if (game.settings.get("wfrp4e", "mooSizeDamage") && actor.sizeNum > 3) 
        {
          if (this.damage.value.includes("SB")) 
          {
            game.wfrp4e.utility.logHomebrew("mooSizeDamage");
            let SBsToAdd = actor.sizeNum - 3;
            damage += (actor.characteristics.s.bonus * SBsToAdd);
          }
    
        }
        //@/HOUSE
    
        return parseInt(damage || 0)
      }

      get DamageString() {
        let string = this.Damage;
    
        if (this.damage.dice)
          string += `+ ${this.damage.dice}`;
    
        if (this.ammo && this.ammo.damage.dice)
          string += `+ ${this.ammo.damage.dice}`;
    
        return string
      }

      get mountDamage() {

        let actor = this.parent.actor;
        if (!actor)
            return;

        if (this.attackType != "melee" || !actor.isMounted || !actor.mount)
        {
            return this.Damage
        }
                                                                                                                                // Account for Durable, Math.max so durable doesn't go past damageToItem
        return this.applyAmmoMods(this.computeWeaponFormula("damage", actor.mount), "damage") + (actor.flags[`${this.attackType}DamageIncrease`] || 0) - Math.max((this.damageToItem.value - (this.properties.qualities.durable?.value || 0)), 0)

      }

      //#endregion


    async preCreateData(data, options, user) {
        let preCreateData = await super.preCreateData(data, options, user);

        if (this.parent.isOwned && this.parent.actor.type != "character" && this.parent.actor.type != "vehicle") {
            setProperty({ preCreateData, "system.equipped": true }); // TODO: migrate this into a unified equipped property 
        }

        return preCreateData;
    }


    async preUpdateChecks(data) {
        await super.preUpdateChecks(data);

        if (this.weaponGroup.value == "throwing" && getProperty(data, "system.ammunitionGroup.value") == "throwing") {
            delete data.system.ammunitionGroup.value;
            return ui.notifications.notify(game.i18n.localize("SHEET.ThrowingAmmoError"))
        }
    }

    get properties() {
        if (this._properties)
        {
            return this._properties;
        }

        let properties = super.properties;
        properties.unusedQualities = {},
        properties.inactiveQualities = {};

        //TODO: Don't like having to check for type here
        if (this.parent.isOwned && !this.skillToUse && this.parent.actor.type != "vehicle") {
            properties.unusedQualities = properties.qualities;
            properties.qualities = {};
            if (this.ammo)
                properties.qualities = this.ammo.properties.qualities;
        }

        if (this.isOwned) {
            for (let prop in properties.qualities) {
                let property = properties.qualities[prop];
                if (Number.isNumeric(property.group) && !property.active) {
                    properties.inactiveQualities[prop] = property;
                    delete properties.qualities[prop];
                }
            }
        }

        properties.special = this.special?.value;
        if (this.ammo)
            properties.specialAmmo = this.ammo.properties.special;

        return properties;
    }


    computeOwned() {
        if (this.attackType == "ranged" && this.ammo && this.skillToUse && this.parent.actor.type != "vehicle")
            this._addProperties(this.ammo.properties);

        if (this.weaponGroup.value == "flail" && !this.skillToUse && !this.flaws.value.find(i => i.name == "dangerous"))
            this.flaws.value.push({ name: "dangerous" });

        if (game.settings.get("wfrp4e", "mooQualities")) {
            game.wfrp4e.utility.logHomebrew("mooQualities");
            let momentum = this.qualities.value.find(q => q.name == "momentum" && q.value);
            if (momentum?.value && this.parent.actor.status.advantage.value > 0) {
                let qualityString = momentum.value;
                this._addProperties({ qualities: game.wfrp4e.utility.propertyStringToObject(qualityString, game.wfrp4e.utility.allProperties()), flaws: {} });
                this.qualities.value.splice(this.qualities.value.findIndex(q => q.name == "momentum"), 1);
            }
        }

        this.range.bands = this.computeRangeBands();

        if (this.loading) {
            this.loaded.max = 1;
            if (this.repeater) {
                this.loaded.max = this.repeater.value;
                if (!this.loaded.max)
                    this.loaded.max = 1;
            }
        }
    }

    computeEncumbrance() 
    {
        let enc = super.computeEncumbrance();
        // Weapons don't lower encumbrance when equipped
        if (this.isEquipped && this.encumbrance.value > 0) // Check if encumbrance > 0 because we don't want to add encumbrance back if there wasn't any to begin with
        {
            enc++;
        }
        return enc
    }


    computeRangeBands() {

        let range = this.applyAmmoMods(this.computeWeaponFormula("range"), "range");
        if (!range || this.attackType == "melee")
            return

        let rangeBands = {};

        rangeBands[`${game.i18n.localize("Point Blank")}`] = {
            range: [0, 4],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Point Blank"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Point Blank"]
        };
        rangeBands[`${game.i18n.localize("Short Range")}`] = {
            range: [4 + 1, Math.ceil(range / 2)],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Short Range"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Short Range"]
        };
        rangeBands[`${game.i18n.localize("Normal")}`] = {
            range: [Math.ceil(range / 2) + 1, range],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Normal"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Normal"]
        };
        rangeBands[`${game.i18n.localize("Long Range")}`] = {
            range: [range + 1, range * 2],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Long Range"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Long Range"]
        };
        rangeBands[`${game.i18n.localize("Extreme")}`] = {
            range: [range * 2 + 1, range * 3],
            modifier: game.wfrp4e.config.difficultyModifiers[game.wfrp4e.config.rangeModifiers["Extreme"]],
            difficulty: game.wfrp4e.config.rangeModifiers["Extreme"]
        };

        //@HOUSE
        if (game.settings.get("wfrp4e", "mooRangeBands")) {
            game.wfrp4e.utility.logHomebrew("mooRangeBands");
            if (!this.getFlag("wfrp4e", "optimalRange"))
                game.wfrp4e.utility.log("Warning: No Optimal Range set for " + this.name);

            rangeBands[`${game.i18n.localize("Point Blank")}`].modifier = game.wfrp4e.utility.optimalDifference(this, game.i18n.localize("Point Blank")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Point Blank")}`].difficulty;
            rangeBands[`${game.i18n.localize("Short Range")}`].modifier = game.wfrp4e.utility.optimalDifference(this, game.i18n.localize("Short Range")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Short Range")}`].difficulty;
            rangeBands[`${game.i18n.localize("Normal")}`].modifier = game.wfrp4e.utility.optimalDifference(this, game.i18n.localize("Normal")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Normal")}`].difficulty;
            rangeBands[`${game.i18n.localize("Long Range")}`].modifier = game.wfrp4e.utility.optimalDifference(this, game.i18n.localize("Long Range")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Long Range")}`].difficulty;
            rangeBands[`${game.i18n.localize("Extreme")}`].modifier = game.wfrp4e.utility.optimalDifference(this, game.i18n.localize("Extreme")) * -20 + 20;
            delete rangeBands[`${game.i18n.localize("Extreme")}`].difficulty;
        }
        //@/HOUSE


        // If entangling and has no ammunition (implying non-projectiles like a whip)
        if (this.weaponGroup.value == "entangling" && this.ammunitionGroup.value == "none") {
            rangeBands[`${game.i18n.localize("Point Blank")}`].modifier = 0;
            rangeBands[`${game.i18n.localize("Short Range")}`].modifier = 0;
            rangeBands[`${game.i18n.localize("Normal")}`].modifier = 0;
            rangeBands[`${game.i18n.localize("Long Range")}`].modifier = 0;
            rangeBands[`${game.i18n.localize("Extreme")}`].modifier = 0;
        }
        return rangeBands;
    }

    applyAmmoMods(value, type) {
        // If weapon ammo, just use its damage
        if (this.ammo?.type == "weapon" && type == "damage") {
            return Number(this.ammo.damage.value)
        }

        // If no ammo or has weapon ammo, don't apply mods
        if (!this.ammo || this.ammo.type == "weapon")
            return value

        let ammoValue = this.ammo[type].value;

        if (!ammoValue)
            return value

        // If range modification was handwritten, process it
        if (ammoValue.toLowerCase() == game.i18n.localize("as weapon")) ;
        else if (ammoValue.toLowerCase() == "as weapon") ;
        // Do nothing to weapon's range
        else if (ammoValue.toLowerCase() == game.i18n.localize("half weapon"))
            value /= 2;
        else if (ammoValue.toLowerCase() == "half weapon")
            value /= 2;
        else if (ammoValue.toLowerCase() == game.i18n.localize("third weapon"))
            value /= 3;
        else if (ammoValue.toLowerCase() == "third weapon")
            value /= 3;
        else if (ammoValue.toLowerCase() == game.i18n.localize("quarter weapon"))
            value /= 4;
        else if (ammoValue.toLowerCase() == "quarter weapon")
            value /= 4;
        else if (ammoValue.toLowerCase() == game.i18n.localize("twice weapon"))
            value *= 2;
        else if (ammoValue.toLowerCase() == "twice weapon")
            value *= 2;
        else // If the range modification is a formula (supports +X -X /X *X)
        {
            try // Works for + and -
            {
                ammoValue = (0, eval)(ammoValue);
                value = Math.floor((0, eval)(value + ammoValue));
            }
            catch // if *X and /X
            {                                      // eval (50 + "/5") = eval(50/5) = 10
                value = Math.floor((0, eval)(value + ammoRange));
            }
        }
        return value
    }


    /**
   * Calculates a weapon's range or damage formula.
   * 
   * Takes a weapon formula for Damage or Range (SB + 4 or SBx3) and converts to a numeric value.
   * 
   * @param {String} formula formula to be processed (SBx3 => 9).
   * 
   * @return {Number} Numeric formula evaluation
   */
    computeWeaponFormula(type, mount) {
        let formula = this[type].value || 0;
        let actorToUse = this.parent.actor;
        try {
            formula = formula.toLowerCase();
            // Iterate through characteristics
            for (let ch in this.parent.actor.characteristics) {
                if (ch == "s" && mount)
                    actorToUse = mount;
                else
                    actorToUse = this.parent.actor;
                // Determine if the formula includes the characteristic's abbreviation + B (SB, WPB, etc.)
                if (formula.includes(ch.concat('b'))) {
                    // Replace that abbreviation with the Bonus value
                    formula = formula.replace(ch.concat('b'), actorToUse.characteristics[ch].bonus.toString());
                }
            }
            // To evaluate multiplication, replace x with *
            formula = formula.replace('x', '*');

            return (0, eval)(formula);
        }
        catch
        {
            console.error(`computeWeaponFormula from ${this.parent?.actor?.name} threw error: ${e}.\n Arguments:`, this, formula);
            return formula
        }
    }

    getSkillToUse() {
        let skills = this.parent.actor?.getItemTypes("skill") || [];
        let skill = skills.find(x => x.name.toLowerCase() == this.skill.value.toLowerCase());
        if (!skill) {
            skill = skills.find(x => x.name.toLowerCase().includes(`(${this.WeaponGroup.toLowerCase()})`));
        }
        return skill
    }

    
    getOtherEffects()
    {
        return super.getOtherEffects().concat(this.ammo?.effects.contents || [])
    }

    shouldTransferEffect(effect)
    {
        return super.shouldTransferEffect(effect) && (!effect.applicationData.equipTransfer || this.isEquipped)
    }


    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);

        if (this.weaponGroup.value)
            data.properties.push(this.WeaponGroup);
        if (this.range.value)
            data.properties.push(`${game.i18n.localize("Range")}: ${this.range.value}`);
        if (this.damage.value) {
            let damage = this.damage.value;
            if (this.damage.dice)
                damage += " + " + this.damage.dice;
            data.properties.push(`${game.i18n.localize("Damage")}: ${damage}`);
        }
        if (this.twohanded.value)
            data.properties.push(game.i18n.localize("ITEM.TwoHanded"));
        if (this.reach.value)
            data.properties.push(`${game.i18n.localize("Reach")}: ${game.wfrp4e.config.weaponReaches[this.reach.value] + " - " + game.wfrp4e.config.reachDescription[this.reach.value]}`);
        if (this.damageToItem.value)
            data.properties.push(`${game.i18n.format("ITEM.WeaponDamaged", { damage: this.damageToItem.value })}`);
        if (this.damageToItem.shield)
            data.properties.push(`${game.i18n.format("ITEM.ShieldDamaged", { damage: this.damageToItem.shield })}`);

        let itemProperties = this.OriginalQualities.concat(this.OriginalFlaws);
        for (let prop of itemProperties)
            data.properties.push("<a class ='item-property'>" + prop + "</a>");

        if (this.special.value)
            data.properties.push(`${game.i18n.localize("Special")}: ` + this.special.value);

        data.properties = data.properties.filter(p => !!p);
        return data;
    }

    chatData() {
        let properties = [
            `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
            `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
            `<b>${game.i18n.localize("Availability")}</b>: ${game.wfrp4e.config.availability[this.availability.value] || "-"}`
        ];

        if (this.weaponGroup.value)
            data.properties.push(`<b>${game.i18n.localize("Group")}</b>: ${this.WeaponGroup}`);
        if (this.range.value)
            data.properties.push(`<b>${game.i18n.localize("Range")}</b>: ${this.range.value}`);
        if (this.damage.value)
            data.properties.push(`<b>${game.i18n.localize("Damage")}</b>: ${this.damage.value}`);
        if (this.twohanded.value)
            data.properties.push(`<b>${game.i18n.localize("ITEM.TwoHanded")}</b>`);
        if (this.reach.value)
            data.properties.push(`<b>${game.i18n.localize("Reach")}</b>: ${game.wfrp4e.config.weaponReaches[this.reach.value] + " - " + game.wfrp4e.config.reachDescription[this.reach.value]}`);
        if (this.damageToItem.value)
            data.properties.push(`${game.i18n.format("ITEM.WeaponDamaged", { damage: this.damageToItem.value })}`);
        if (this.damageToItem.shield)
            data.properties.push(`${game.i18n.format("ITEM.ShieldDamaged", { damage: this.damageToItem.shield })}`);

        // Make qualities and flaws clickable
        if (this.qualities.value.length)
            data.properties.push(`<b>${game.i18n.localize("Qualities")}</b>: ${this.OriginalQualities.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);

        if (this.flaws.value.length)
            data.properties.push(`<b>${game.i18n.localize("Flaws")}</b>: ${this.OriginalFlaws.map(i => i = "<a class ='item-property'>" + i + "</a>").join(", ")}`);


        properties = properties.filter(p => p != game.i18n.localize("Special"));
        if (this.special.value)
            data.properties.push(`<b>${game.i18n.localize("Special")}</b>: ` + this.special.value);

        properties = properties.filter(p => !!p);
        return properties;
    }
}

let fields$2 = foundry.data.fields;

class ExtendedTestModel extends BaseItemModel {
    static defineSchema() {
        let schema = super.defineSchema();

        schema.SL = new fields$2.SchemaField({
            current: new fields$2.NumberField({ initial: 0 }),
            target: new fields$2.NumberField({ initial: 1 }),
        });

        schema.test = new fields$2.SchemaField({
            value: new fields$2.StringField({})
        });

        schema.negativePossible = new fields$2.SchemaField({
            value: new fields$2.BooleanField({ initial: false })
        });

        schema.failingDecreaeses = new fields$2.SchemaField({
            value: new fields$2.BooleanField({ initial: true })
        });

        schema.completion = new fields$2.SchemaField({
            value: new fields$2.StringField({ initial: "none" })
        });

        schema.hide = new fields$2.SchemaField({
            current: new fields$2.BooleanField({ initial: false }),
            target: new fields$2.BooleanField({ initial: false }),
        });

        schema.difficulty = new fields$2.SchemaField({
            value: new fields$2.StringField({ initial: "challenging" })
        });

        return schema;
    }



    computeOwned() {
        this.SL.pct = 0;
        if (this.SL.target > 0)
            this.SL.pct = this.SL.current / this.SL.target * 100;
        if (this.SL.pct > 100)
            this.SL.pct = 100;
        if (this.SL.pct < 0)
            this.SL.pct = 0;
    }

    chatData() {
        let properties = [];
        let pct = 0;
        if (this.SL.target > 0)
            pct = this.SL.current / this.SL.target * 100;
        if (pct > 100)
            pct = 100;
        if (pct < 0)
            pct = 0;
        properties.push(`<b>${game.i18n.localize("Test")}</b>: ${this.test.value}`);
        if (!this.hide.test && !this.hide.progress)
            properties.push(`<div class="test-progress">
      <div class="progress-bar-container">
        <div class="progress-bar" style="width: ${pct}%"></div>
      </div>
      <span><a class="extended-SL">${this.SL.current}</a> / ${this.SL.target} SL</span>
    </div>`);

        return properties;
    }
}

let fields$1 = foundry.data.fields;

class VehicleModModel extends PhysicalItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.modType = new fields$1.SchemaField({
            value : new fields$1.StringField({})
        });
        return schema;
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
        data.properties = [game.wfrp4e.config.modTypes[this.modType.value]];
        return data;
      }

      chatData() {
        let properties = [
          `<b>${game.i18n.localize("VEHICLE.ModType")}</b>: ${game.wfrp4e.config.modTypes[this.modType.value]}`,
          `<b>${game.i18n.localize("Price")}</b>: ${this.price.gc || 0} ${game.i18n.localize("MARKET.Abbrev.GC")}, ${this.price.ss || 0} ${game.i18n.localize("MARKET.Abbrev.SS")}, ${this.price.bp || 0} ${game.i18n.localize("MARKET.Abbrev.BP")}`,
          `<b>${game.i18n.localize("Encumbrance")}</b>: ${this.encumbrance.value}`,
        ];
        return properties
      }
}

let fields = foundry.data.fields;

class CargoModel extends PhysicalItemModel
{
    static defineSchema() 
    {
        let schema = super.defineSchema();
        schema.cargoType = new fields.SchemaField({
            value: new fields.StringField()
        });
        schema.unitPrice = new fields.SchemaField({
            value: new fields.NumberField()
        });
        schema.origin = new fields.SchemaField({
            value: new fields.StringField()
        });
        schema.quality = new fields.SchemaField({
            value: new fields.StringField({initial : "average"})
        });
        return schema;
    }

    computeBase()
    {
        if (this.cargoType.value != "wine" && this.cargoType.value != "brandy")
        {
            this.quality.value = "average";
        }
    }

    async expandData(htmlOptions) {
        let data = await super.expandData(htmlOptions);
    
        if (this.origin.value)
          data.properties.push(`<b>${game.i18n.localize("ITEM.Origin")}</b>: ${this.origin.value}`);
    
        if (game.wfrp4e.config.trade.cargoTypes)
          data.properties.push(`<b>${game.i18n.localize("ITEM.CargoType")}</b>: ${game.wfrp4e.config.trade.cargoTypes[this.cargoType.value]}`);
    
        if (game.wfrp4e.config.trade.qualities && (this.cargoType.value == "wine" || this.cargoType.value == "brandy"))
          data.properties.push(`<b>${game.i18n.localize("ITEM.CargoQuality")}</b>: ${game.wfrp4e.config.trade.qualities[this.quality.value]}`);
    
        return data;
      }

      chatData() {
        let properties = [];
    
        if (this.origin.value)
          properties.push(`<b>${game.i18n.localize("ITEM.Origin")}</b>: ${this.origin.value}`);
    
        if (game.wfrp4e.config.trade.cargoTypes)
          properties.push(`<b>${game.i18n.localize("ITEM.CargoType")}</b>: ${game.wfrp4e.config.trade.cargoTypes[this.cargoType.value]}`);
    
        if (game.wfrp4e.config.trade.qualities && (this.cargoType.value == "wine" || this.cargoType.value == "brandy"))
          properties.push(`<b>${game.i18n.localize("ITEM.CargoQuality")}</b>: ${game.wfrp4e.config.trade.qualities[this.quality.value]}`);
        return properties;
      }
    
}

/* -------------------------------------------- */
/*  Foundry VTT Initialization                  */
/* -------------------------------------------- */

Hooks.once("init", function () {

  CONFIG.debug.wfrp4e = true;
  WFRP_Utility$1.log("Development Mode: Logs on");

  // Register sheet application classes
  Actors.unregisterSheet("core", ActorSheet);
  Actors.registerSheet("wfrp4e", ActorSheetWfrp4eCharacter, { types: ["character"], makeDefault: true });
  Actors.registerSheet("wfrp4e", ActorSheetWfrp4eNPC, { types: ["npc"], makeDefault: true });
  Actors.registerSheet("wfrp4e", ActorSheetWfrp4eCreature, { types: ["creature"], makeDefault: true });
  Actors.registerSheet("wfrp4e", ActorSheetWfrp4eVehicle, { types: ["vehicle"], makeDefault: true });
  Items.unregisterSheet("core", ItemSheet);
  Items.registerSheet("wfrp4e", ItemSheetWfrp4e, { makeDefault: true });
  DocumentSheetConfig.registerSheet(RollTable, "wfrp4e", WFRPTableConfig, {makeDefault: true});
  DocumentSheetConfig.registerSheet(ActiveEffect, "wfrp4e", WFRP4eActiveEffectConfig, {makeDefault :true});
  // DocumentSheetConfig.registerSheet(JournalEntry, "wfrp4e", WFRPJournalSheet, {makeDefault :true})
  DocumentSheetConfig.registerSheet(JournalEntryPage, "wfrp4e", WFRPJournalTextPageSheet, {types: ["text"], makeDefault: true, label : "WFRP Journal Sheet (ProseMirror)"});

  CONFIG.Actor.dataModels["character"] = CharacterModel;
  CONFIG.Actor.dataModels["npc"] = NPCModel;
  CONFIG.Actor.dataModels["creature"] = CreatureModel;
  CONFIG.Actor.dataModels["vehicle"] = VehicleModel;

  CONFIG.Item.dataModels["ammunition"] = AmmunitionModel;
  CONFIG.Item.dataModels["armour"] = ArmourModel;
  CONFIG.Item.dataModels["career"] = CareerModel;
  CONFIG.Item.dataModels["container"] = ContainerModel;
  CONFIG.Item.dataModels["critical"] = CriticalModel;
  CONFIG.Item.dataModels["disease"] = DiseaseModel;
  CONFIG.Item.dataModels["injury"] = InjuryModel;
  CONFIG.Item.dataModels["money"] = MoneyModel;
  CONFIG.Item.dataModels["mutation"] = MutationModel;
  CONFIG.Item.dataModels["prayer"] = PrayerModel;
  CONFIG.Item.dataModels["psychology"] = PsychologyModel;
  CONFIG.Item.dataModels["talent"] = TalentModel;
  CONFIG.Item.dataModels["trapping"] = TrappingModel;
  CONFIG.Item.dataModels["skill"] = SkillModel;
  CONFIG.Item.dataModels["spell"] = SpellModel;
  CONFIG.Item.dataModels["trait"] = TraitModel;
  CONFIG.Item.dataModels["weapon"] = WeaponModel;
  CONFIG.Item.dataModels["vehicleMod"] = VehicleModModel;
  CONFIG.Item.dataModels["extendedTest"] = ExtendedTestModel;
  CONFIG.Item.dataModels["cargo"] = CargoModel;

  game.wfrp4e = {
    apps: {
      ActorSheetWfrp4e,
      ActorSheetWfrp4eCharacter,
      ActorSheetWfrp4eCreature,
      ActorSheetWfrp4eNPC,
      ActorSheetWfrp4eVehicle,
      ItemSheetWfrp4e,
      CharGenWfrp4e,
      StatBlockParser,
      BrowserWfrp4e,
      ActorSettings,
      WFRPActiveEffectConfig: WFRP4eActiveEffectConfig,
      HomebrewSettings,
      CareerSelector,
      ItemProperties,
      ModuleUpdater,
      ModuleInitializer,
      ItemDialog,
      ChargenStage
    },
    entities: {
      ActorWfrp4e,
      ItemWfrp4e
    },
    rolls : {
      TestWFRP,
      CharacteristicTest,
      SkillTest,
      WeaponTest,
      CastTest,
      WomCastTest,
      ChannelTest,
      PrayerTest,
      TraitTest
    },
    utility: WFRP_Utility$1,
    tables: WFRP_Tables,
    config: WFRP4E,
    chat: ChatWFRP,
    market: MarketWfrp4e,
    audio: WFRP_Audio,
    opposed: OpposedWFRP,
    opposedTest: OpposedTest,
    names: NameGenWfrp,
    combat: CombatHelpers,
    aoe: AbilityTemplate,
    migration: Migration,
    tags : new TagManager()
  };

  CONFIG.Actor.documentClass = ActorWfrp4e;
  CONFIG.Item.documentClass = ItemWfrp4e;
  CONFIG.ActiveEffect.documentClass = EffectWfrp4e;
  CONFIG.ActiveEffect.legacyTransferral = false;

  //TODO: CHNECK IF NEEDED.
  CONFIG.ChatMessage.documentClass.prototype.getTest = function () {
    if (hasProperty(this, "flags.testData"))
      return game.wfrp4e.rolls.TestWFRP.recreate(this.flags.testData)   
  };
  CONFIG.ChatMessage.documentClass.prototype.getOppose = function () {
    if (hasProperty(this, "flags.wfrp4e.opposeData"))
      return new OpposedWFRP(getProperty(this, "flags.wfrp4e.opposeData"))
  };

  CONFIG.ChatMessage.documentClass.prototype.getOpposedTest = function () {
    if (hasProperty(this, "flags.wfrp4e.opposeTestData"))
      return game.wfrp4e.opposedTest.recreate(getProperty(this, "flags.wfrp4e.opposeTestData"))
  };
});

registerHooks();
